<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AI 基础概念介绍</title>
      <link href="posts/3c395b1.html"/>
      <url>posts/3c395b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/ai-agents_page-0001.jpg" alt="ai-agents_page-0001"></p><ul><li>人工智能系统分为三个级别：大型语言模型 (LLM)、人工智能工作流（AI Workflows）和人工智能代理（AI Agents），每个级别代表着不断增加的自主性和复杂性。<ul><li><strong>LLMs:</strong> 这些模型根据用户提示生成响应(Input → Output)，但缺乏自主性或独立行动的能力。 </li><li><strong>AI Workflows:</strong>  AI Workflow 使用预定义逻辑自动执行重复性任务（Input → Predefined Path → Output），虽然提高了效率，但缺乏针对创造性或动态场景的灵活性和适应性。</li><li><strong>AI Agents</strong>  是最先进的，能够独立推理、行动和迭代以实现复杂的目标（Goal → Reason → Act → Iterate → Final Output），并且有检索增强生成 (RAG) 和 ReAct 等框架加持。</li></ul></li></ul><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="AI-中的流式响应"><a href="#AI-中的流式响应" class="headerlink" title="AI 中的流式响应"></a>AI 中的流式响应</h2><p>流式响应允许 AI 系统在计算响应的同时逐步生成并显示输出。系统无需等待整个响应生成后再显示，而是在 chunks 数据（tokens）准备就绪时发送它们。此功能使交互感觉更流畅、更自然，就像进行真实的对话一样。</p><h3 id="流式响应是如何工作的"><a href="#流式响应是如何工作的" class="headerlink" title="流式响应是如何工作的"></a>流式响应是如何工作的</h3><h4 id="Token-by-Token-Generation"><a href="#Token-by-Token-Generation" class="headerlink" title="Token-by-Token Generation"></a><strong>Token-by-Token Generation</strong></h4><p>LLM 每次生成一个 token。一个 token 是文本的一个单位，可以是：</p><ul><li>一个词（例如“happy”）</li><li>单词的一部分（例如“happiness”中的“happ-”）</li><li>单个字符（例如“a”或标点符号“，”）。</li></ul><p>当用户提交查询时，LLM 会开始按顺序生成tokens。第一个 token 生成后，会立即发送到客户端界面，并持续执行该过程，直到完整响应完成。这种 token 的增量交付构成了流式响应的基础。</p><h4 id="Streaming-APIs"><a href="#Streaming-APIs" class="headerlink" title="Streaming APIs"></a><strong>Streaming APIs</strong></h4><p>大多数 LLM 支持通过专用 API 进行流式传输。例如，OpenAI 的 API 包含一个<code>stream</code>参数，允许客户端接收实时 tokens 流，而无需等待完整的响应。具体流程如下：</p><ul><li><strong>步骤 1：</strong>客户端向启用流式传输的服务器发送查询。</li><li><strong>第 2 步：</strong>服务器处理输入并开始生成 token。</li><li><strong>步骤 3：</strong>tokens 准备好后，会以 chunks 的形式逐个发送给客户端。</li><li><strong>步骤4：</strong>客户端实时将每个块附加到显示屏。</li></ul><p>这让用户产生了人工智能正在“输入”回应的错觉。</p><h4 id="客户端实时渲染"><a href="#客户端实时渲染" class="headerlink" title="客户端实时渲染"></a><strong>客户端实时渲染</strong></h4><p>在客户端，应用程序被设计为立即渲染接收到的 tokens 或 chunks。例如：</p><ul><li>一旦收到新的 tokens，Web 应用程序可能会立即更新用户界面。</li><li>基于终端的程序可能会将每个标记直接刷新到输出流，以实现实时“打字”效果。</li></ul><h3 id="支持流媒体的关键技术"><a href="#支持流媒体的关键技术" class="headerlink" title="支持流媒体的关键技术"></a><strong>支持流媒体的关键技术</strong></h3><p>多种核心技术共同作用，使流式响应成为可能：</p><h4 id="服务器发送事件（SSE）"><a href="#服务器发送事件（SSE）" class="headerlink" title="服务器发送事件（SSE）"></a><strong>服务器发送事件（SSE）</strong></h4><p>服务器发送事件 (SSE) 是一种协议，允许服务器通过单个 HTTP 连接实时向客户端推送更新。每块数据都作为单独的事件发送。</p><p>以下是 SSE 实际运行的一个示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: Hello</span><br><span class="line"></span><br><span class="line">data: how</span><br><span class="line"></span><br><span class="line">data: are</span><br><span class="line"></span><br><span class="line">data: you?</span><br></pre></td></tr></table></figure><p>每个<code>data</code>字段代表客户端可以立即显示的响应块。</p><h4 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a><strong>WebSockets</strong></h4><p>WebSocket 在客户端和服务器之间提供双向通信通道，这对于流式传输尤其有用。虽然 WebSocket 在简单的文本流式传输中并不常见，但它们通常用于更复杂的实时应用程序，例如协作编辑器或实时仪表板。</p><h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a><strong>异步编程</strong></h4><p>像 Python<code>asyncio</code>或 JavaScript 这样的异步编程框架<code>Node.js</code>对于高效处理流式传输至关重要。这些框架使服务器能够：</p><ul><li>同时处理多个客户端请求。</li><li>将令牌发送给客户端，而不会阻止后续令牌的生成。</li></ul><h3 id="LLM-中的流程优化"><a href="#LLM-中的流程优化" class="headerlink" title="LLM 中的流程优化"></a><strong>LLM 中的流程优化</strong></h3><p>通过 LLM 中高度优化的架构和解码策略，可以实现流式传输：</p><h4 id="Transformer-架构"><a href="#Transformer-架构" class="headerlink" title="Transformer 架构"></a><strong>Transformer 架构</strong></h4><p>LLM 采用 Transformer 架构，该架构并行处理输入，但按顺序生成输出。每个 token 都根据前一个 token 的上下文进行预测，从而实现流畅的生成流程。</p><h4 id="解码策略"><a href="#解码策略" class="headerlink" title="解码策略"></a><strong>解码策略</strong></h4><p>LLM 依赖以下策略：</p><ul><li><strong>定向搜索：</strong>生成多个潜在序列并选择最可能的序列。</li><li><strong>采样：</strong>引入随机性以产生不同的响应。</li><li><strong>Top-k 采样或核心采样：</strong>通过将标记选择限制在最有可能的候选范围内来平衡质量和创造力。</li></ul><p>这些策略确保有效生成标记，同时保持一致性和相关性。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><p>以下是如何使用 Python和 Java 实现流式响应的示例：</p><h4 id="Python-示例"><a href="#Python-示例" class="headerlink" title="Python 示例"></a><strong>Python 示例</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the OpenAI API with streaming enabled</span></span><br><span class="line">response = openai.ChatCompletion.create(</span><br><span class="line">    model=<span class="string">&quot;gpt-4&quot;</span>,</span><br><span class="line">    messages=[&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Tell me a story&quot;</span>&#125;],</span><br><span class="line">    stream=<span class="literal">True</span>  <span class="comment"># Enable streaming</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stream the response token by token</span></span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> response:</span><br><span class="line">    print(chunk.choices[<span class="number">0</span>].delta.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>), end=<span class="string">&quot;&quot;</span>, flush=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="Java-示例"><a href="#Java-示例" class="headerlink" title="Java 示例"></a><strong>Java 示例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://api.openai.com/v1/chat/completions&quot;</span>);</span><br><span class="line">            HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">            conn.setRequestMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer YOUR_API_KEY&quot;</span>);</span><br><span class="line">            conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            String body = <span class="string">&quot;&#123;\&quot;model\&quot;: \&quot;gpt-4\&quot;, \&quot;messages\&quot;: [&#123;\&quot;role\&quot;: \&quot;user\&quot;, \&quot;content\&quot;: \&quot;Tell me a story\&quot;&#125;], \&quot;stream\&quot;: true&#125;&quot;</span>;</span><br><span class="line">            conn.getOutputStream().write(body.getBytes());</span><br><span class="line"></span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流式响应的好处"><a href="#流式响应的好处" class="headerlink" title="流式响应的好处"></a><strong>流式响应的好处</strong></h3><h4 id="更快的感知响应时间"><a href="#更快的感知响应时间" class="headerlink" title="更快的感知响应时间"></a><strong>更快的感知响应时间</strong></h4><p>即使响应时间较长，用户也能立即看到结果，从而创造更流畅的体验。</p><h4 id="增强互动性"><a href="#增强互动性" class="headerlink" title="增强互动性"></a><strong>增强互动性</strong></h4><p>实时反馈使互动更具活力，更具对话性。用户可以在回复过程中中断或调整查询。</p><h4 id="高效的资源利用"><a href="#高效的资源利用" class="headerlink" title="高效的资源利用"></a><strong>高效的资源利用</strong></h4><p>流式传输避免了将整个响应保存在服务器或客户端的内存中，从而减少了资源使用。</p><h3 id="流式响应的挑战"><a href="#流式响应的挑战" class="headerlink" title="流式响应的挑战"></a><strong>流式响应的挑战</strong></h3><ul><li><strong>网络延迟：</strong>缓慢或不稳定的连接可能会破坏实时体验。</li><li><strong>错误处理：</strong>确保从中断或 tokens 生成失败中正常恢复需要谨慎实施。</li><li><strong>复杂性：</strong>实现流式响应会增加服务器端和客户端代码的复杂性。</li></ul><h2 id="Reasoning-vs-Standard-Models"><a href="#Reasoning-vs-Standard-Models" class="headerlink" title="Reasoning vs Standard Models"></a>Reasoning vs Standard Models</h2><p>推理模型将任务分解为清晰的步骤并遵循逻辑线进行，而标准模型则倾向于一步快速给出答案。推理模型可能会写下简短笔记、检查每一条笔记，然后将它们组合起来以得出最终回复。这种方法有助于解决数学问题、规划行动，并能发现简单的模式匹配可能会错过的错误。标准模型依赖于其在训练期间学到的模式，并经常猜测下一个最可能的词语。这在日常聊天、总结或常见事实查询上表现良好，但在处理复杂谜题或多环节关联的任务时可能会失败。虽然推理需要更多时间和计算资源，但它带来了更高的准确性，并使得智能体更易于调试，因为可以看到它的思考步骤。许多新型AI智能体结合了这两种方式：对于简单部分使用快速模式回忆，而在需要深入思考的目标上切换到逐步推理。</p><h3 id="ReAct-是什么？"><a href="#ReAct-是什么？" class="headerlink" title="ReAct 是什么？"></a>ReAct 是什么？</h3><p><strong>ReAct（Reason + Act）</strong> 是一种范式，它使<a href="https://learnprompting.org/vocabulary/LLM">大型语言模型 (LLM)</a>能够通过自然语言推理和操作来解决复杂任务。它允许<a href="https://learnprompting.org/vocabulary/LLM">LLM</a>执行某些操作，例如检索外部信息，然后基于检索到的数据进行推理。将推理和行动的进展相结合，使语言模型能够解决各种语言推理和决策任务。在推动更大规模的语言模型和微调更小型的语言模型时， <em>Reason+Act</em>（ReAct）范式系统性地优于单纯的推理和行动范式。推理与行动的紧密结合也呈现出与人类一致的任务解决轨迹，从而提高了可解释性、可诊断性和可控制性。</p><h3 id="ReAct-概述"><a href="#ReAct-概述" class="headerlink" title="ReAct 概述"></a>ReAct 概述</h3><p>ReAct 使语言模型能够以交错的方式生成言语推理轨迹和文本动作。虽然动作会引发来自外部环境（下图中的“Env”）的观察反馈，但推理轨迹不会影响外部环境。相反，它们会通过推理上下文并使用有用的信息更新模型来影响模型的内部状态，以支持未来的推理和行动。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/Screen%2520Shot%25202022-11-08%2520at%25208.53.49%2520AM.png" alt="img"></p><h3 id="ReAct-效果"><a href="#ReAct-效果" class="headerlink" title="ReAct 效果"></a>ReAct 效果</h3><p>比较四种提示方法：(a) 标准提示法、(b) 思路链（CoT，仅推理）、(c) 仅行动提示法和 (d) ReAct 提示法，用于解决<a href="https://arxiv.org/abs/1809.09600">HotpotQA</a>问题。图中省略了上下文示例，仅显示任务轨迹。ReAct 能够检索信息以支持推理，同时还能利用推理来确定下一步检索的内容，展现了推理与行动的协同作用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/HotPotQA.png" alt="img"></p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://arxiv.org/pdf/2210.03629">REAC T: SYNERGIZING REASONING AND ACTING IN LANGUAGE MODELS</a>  </li></ul><h2 id="Fine-tuning-vs-Prompt-Engineering"><a href="#Fine-tuning-vs-Prompt-Engineering" class="headerlink" title="Fine-tuning vs Prompt Engineering"></a>Fine-tuning vs Prompt Engineering</h2><p>微调和提示词工程是从语言模型中获得更佳输出的两种方法。微调意味着使用特定领域数据进一步训练现有模型，使其适应特定任务。需要额外的数据、计算能力和时间，但可以创建深度专业化的模型。相比之下，提示词工程保持模型不变，专注于在提示本身中设计更好的指令或示例。当没有可用的自定义数据时，它更快、更便宜、更安全。微调适用于深度领域需求；提示词工程适用于快速控制和原型设计。</p><h2 id="Embeddings-and-Vector-Search"><a href="#Embeddings-and-Vector-Search" class="headerlink" title="Embeddings and Vector Search"></a>Embeddings and Vector Search</h2><p>向量嵌入（Vector Embeddings）是机器学习中的概念之一。它们在许多自然语言处理（NLP）、推荐系统和搜索算法中都处于核心地位。</p><p>机器学习算法与大多数软件算法一样，需要以数字作为输入来进行工作。有时候我们的数据集包含可以直接使用的数值列，或者可以转换为数值的字段（例如序数型、类别型等）。而另一些时候，我们则会遇到像整篇文本这样的抽象信息。对于这类数据，我们会创建向量嵌入——即一组数字列表，以便对这些数据执行各种操作。一个完整的段落，甚至是任何其他对象，都可以被压缩成一个向量表示。即使是原本就是数值类型的数据，也可以转化为向量形式，从而更便于后续操作。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/EmbeddingModel.png" alt="Vector Embeddings are a list of numbers"></p><p> 但向量之所以如此有用，还在于它们具有一些特殊的特性。这种表示方式使得我们可以将人类感知到的语义相似性转化为向量空间中的接近程度。换句话说，当我们把现实世界中的物体和概念——例如图像、音频录音、新闻文章、用户画像、天气模式——表示为向量嵌入时，这些物体和概念之间的语义相似性就可以通过它们在向量空间中作为点的接近程度来量化。因此，向量嵌入表示非常适合用于聚类、推荐和分类等常见的机器学习任务。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/spaceOfSentences.png" alt="Semantic similarity in sentence embeddings."></p><p>例如，在聚类任务中，聚类算法会将相似的点分配到同一个簇中，同时尽可能让不同簇中的点保持不相似。在推荐任务中，当需要为一个未见过的对象做推荐时，推荐系统会寻找与该对象最相似的对象，这种相似性是通过它们在向量嵌入空间中的相似性来衡量的。在分类任务中，我们会根据与该未知对象最相似的那些对象的标签进行多数投票，从而确定其类别。</p><ul><li><strong>相似性（Similarity）</strong>：通过计算两个向量之间的距离，我们可以衡量两个单词（或图像或任何其他嵌入项目）的相似程度。向量越接近，项目越相似。</li><li><strong>类比（Analogy）</strong>：向量嵌入可以捕捉复杂的关系。经典的例子是：”国王”-“男人 “+”女人”≈”王后”。 这是因为 “king”（国王）和 “man”（男人）之间的向量差异大致代表了 “royalty”（王室）的概念，而 “man”（男人）和 “king”（国王）之间的向量差异则使我们接近 “queen”（王后）。</li><li><strong>聚类（Clustering）</strong>：具有相似含义的单词（或其他项目）自然会在嵌入空间中形成聚类。 这一特性对于主题建模或文档分类等任务非常有用。</li><li><strong>维度（Dimensionality）</strong>：虽然我们无法将高维空间可视化，但向量嵌入的多个维度使其能够同时捕捉意义的多个方面。 一个维度可能与大小有关，另一个维度可能与灵性有关，还有一个维度可能与积极性有关，等等。</li></ul><h3 id="Creating-Vector-Embeddings"><a href="#Creating-Vector-Embeddings" class="headerlink" title="Creating Vector Embeddings"></a>Creating Vector Embeddings</h3><p>创建向量嵌入的一种方法是使用领域知识来设计向量的数值，这种方法被称为<strong>特征工程（feature engineering）</strong>。例如，在医学影像中，我们会利用医学专业知识来量化图像中的一组特征，如形状、颜色和区域等，以捕捉其语义信息。然而，进行向量嵌入的特征工程需要特定领域的知识，并且在大规模数据上实施起来成本过高。因此，我们通常不会手动设计向量嵌入，而是训练模型来自动生成对象的向量表示。<strong>深度神经网络</strong>（Deep Neural Networks）是一种常用的工具，用于训练这类生成嵌入的模型。所生成的嵌入通常是<strong>高维</strong>（最高可达两千维）且<strong>稠密</strong>（所有值都不为零）的向量。</p><ul><li><p>对于文本数据，像 Word2Vec、GLoVE 和 BERT 这样的模型可以将词语、句子或段落转化为向量嵌入。  </p><ul><li><p><strong>Word2Vec</strong></p><ul><li><p>使用浅层神经网络学习单词嵌入。 它有两种风格：</p><ul><li><p><strong>跳格（Skip- gram）：</strong>根据目标词预测上下文词。</p></li><li><p><strong>连续词袋 (Continuous Bag of Words, CBOW)：</strong> 根据上下文预测目标词</p><blockquote><p>Word2Vec 在大型文本库中进行训练，学会根据上下文预测单词。通过这一过程，它可以开发出向量表征，捕捉词与词之间的语义关系。</p></blockquote></li></ul></li></ul></li><li><p><strong>GloVe</strong> <strong>(Global Vectors for Word Representation)</strong></p><p>与预测模型 Word2Vec 不同，GloVe 是一种基于计数的模型。它通过对词语的共现矩阵进行降维处理来创建词语嵌入。GloVe 可捕捉本地上下文（如 Word2Vec）和全局语料库统计数据。</p></li><li><p><strong>BERT（来自变换器的双向编码器表示法</strong></p><p>BERT 代表了 NLP 领域的一大进步。它使用转换器架构来生成上下文关联的单词和文档嵌入。这意味着一个单词的嵌入可以根据周围的语境发生变化，从而实现更细致入微的表述。</p><p>这些模型是在海量文本语料库中训练出来的，通常包含数十亿个单词。通过训练过程，它们学会预测单词或上下文，并在此过程中开发出丰富的语言表征，以捕捉语义和句法关系。</p><p>流行的 ChatGPT 聊天界面（由 GPT-4 支持）使用的嵌入与 BERT 等模型产生的嵌入类似，这意味着它可以创建上下文化的单词和文本表示。</p></li></ul></li><li><p>对于图像数据，可以通过<strong>卷积神经网络</strong>（CNNs）来生成嵌入，例如 VGG 和 Inception 等模型。  </p><ul><li><strong>VGG、ResNet、Inception：</strong>这些都是用于图像分类的流行 CNN 架构。虽然这些网络的主要用途是分类，但其倒数第二层也可用作嵌入。这一层通常捕捉图像的高级特征。</li><li><strong>连体网络（Siamese Networks)：</strong>用于生成专门用于比较图像的嵌入。它们在成对图像上进行训练，学习为相似图像生成相似的嵌入，为不同图像生成不同的嵌入。</li></ul></li><li><p>对于音频数据，可以通过对音频频率的可视化表示（例如频谱图 Spectrogram）应用图像嵌入技术，将其转换为向量形式。</p></li></ul><h3 id="Example-Image-Embedding-with-a-Convolutional-Neural-Network"><a href="#Example-Image-Embedding-with-a-Convolutional-Neural-Network" class="headerlink" title="Example: Image Embedding with a Convolutional Neural Network"></a>Example: Image Embedding with a Convolutional Neural Network</h3><p>考虑以下示例：原始图像以灰度像素的形式表示。这相当于一个由 0 到 255 范围内的整数组成的矩阵（或表格），其中值 0 表示黑色，255 表示白色。下图展示了一张灰度图像及其对应的矩阵。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/vector_eg.png" alt="Grayscale image representation"></p><p>左侧子图描绘了灰度像素，中间子图包含了像素的灰度值，最右侧子图定义了矩阵。请注意，矩阵中的值定义了一个向量嵌入，其第一个坐标是矩阵的左上角单元格，然后从左到右排列，直到最后一个坐标对应于矩阵的右下角单元格。这种嵌入方式在保持图像中像素邻域的语义信息方面表现出色。然而，它们对诸如平移、缩放、裁剪和其他图像处理操作等变换非常敏感。因此，这些原始嵌入通常被用作输入，用于学习更鲁棒的嵌入表示。</p><p><strong>卷积神经网络（CNN 或 ConvNet）</strong>是一类常用于视觉数据处理的深度学习架构，可以将图像转换为嵌入。CNN 通过分层的小型局部输入（称为“感受野”）来处理输入数据。每一层中的每个神经元都会处理前一层的一个特定感受野。每层要么对感受野进行卷积操作，要么执行缩小输入尺寸的操作，即所谓的“下采样”。</p><p>下图展示了一个典型的 CNN 结构。注意每层中以小方块形式展示的感受野作为前一层中单个神经元的输入。同时注意到，下采样操作会减小层的大小，而卷积操作则会扩展层的大小。最终的向量嵌入是通过全连接层获得的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/Typical_CNN_architecture.png" alt="Typical CNN architecture"></p><p>训练网络权重（即嵌入模型）需要大量带标签的图像。在训练过程中，权重会被优化，使得具有相同标签的图像在嵌入空间中彼此更接近，而不同标签的图像则尽可能远离。</p><p>一旦我们训练好了 CNN 嵌入模型，就可以将图像转换为向量，并使用<strong>K-近邻索引</strong>（K-Nearest Neighbor Index）进行存储。现在，当遇到一张新的、未见过的图像时，我们可以用 CNN 模型将其转换为向量，然后检索出与其最相似的 k 个向量，从而找到对应的相似图像。</p><p>虽然我们以上面的例子说明了图像和 CNN 的应用，但事实上，<strong>向量嵌入可以为任何类型的数据创建</strong>，并且有多种模型或方法可用于生成这些嵌入。</p><h3 id="Using-Vector-Embeddings"><a href="#Using-Vector-Embeddings" class="headerlink" title="Using Vector Embeddings"></a>Using Vector Embeddings</h3><p>嵌入之所以非常有用，是因为它们可以将一个对象表示为包含其语义信息的稠密向量，这使得嵌入在各种机器学习应用中都具有广泛的适用性。</p><p><strong>相似性搜索</strong>是向量嵌入最流行的应用之一。像 KNN（K-最近邻）和 ANN（近似最近邻）这样的搜索算法需要我们计算向量之间的距离来判断它们的相似性，而向量嵌入正好适合用于这类距离计算。反过来，最近邻搜索又可以应用于诸如去重、推荐、异常检测、反向图像搜索等任务。</p><p>即使我们在某个应用中没有直接使用嵌入向量，许多流行的机器学习模型和方法在其内部也依赖于嵌入。例如，在<strong>编码器-解码器架构</strong>中，编码器生成的嵌入包含了供解码器生成输出结果所需的全部信息。这种架构被广泛应用于机器翻译、图像描述生成等场景中。</p><h3 id="相关资源-1"><a href="#相关资源-1" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://www.pinecone.io/learn/vector-embeddings/">What are Vector Embeddings</a></li></ul><h2 id="Understand-the-Basics-of-RAG"><a href="#Understand-the-Basics-of-RAG" class="headerlink" title="Understand the Basics of RAG"></a>Understand the Basics of RAG</h2><p>RAG 是 Retrieval-Augmented Generation（检索增强生成）的缩写，它是一种通过让语言模型在回答前先进行信息检索，从而提供更准确答案的方法。首先，系统会将用户的提问转化为搜索查询，并扫描知识源（例如一组文档或数据库）。然后，系统会返回最相关的段落，这些段落被称为“检索结果”。接下来，语言模型会阅读这些检索结果，并结合自身的训练知识来生成最终答案。这种搜索与生成相结合的方式，有助于模型保持信息的及时性，减少猜测，并引用真实的事实。由于可以根据需要添加外部信息，RAG 通常不需要大量微调，就能处理基础模型在训练时从未接触过的话题。</p><h3 id="RAG-的工作原理"><a href="#RAG-的工作原理" class="headerlink" title="RAG 的工作原理"></a>RAG 的工作原理</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/rag.png" alt="img"></p><h2 id="Model-Context-Protocol-MCP"><a href="#Model-Context-Protocol-MCP" class="headerlink" title="Model Context Protocol (MCP)"></a>Model Context Protocol (MCP)</h2><h3 id="Function-Calling、AI-Agent、MCP-这三者之间有什么区别？"><a href="#Function-Calling、AI-Agent、MCP-这三者之间有什么区别？" class="headerlink" title="Function Calling、AI Agent、MCP 这三者之间有什么区别？"></a>Function Calling、AI Agent、MCP 这三者之间有什么区别？</h3><h4 id="Function-Calling"><a href="#Function-Calling" class="headerlink" title="Function Calling"></a>Function Calling</h4><ul><li>Function Calling 指的是 AI 模型根据上下文自动执行函数的机制。</li><li>Function Calling 充当了 AI 模型与外部系统之间的桥梁，不同的模型有不同的 Function Calling 实现，代码集成的方式也不一样。由不同的 AI 模型平台来定义和实现。</li></ul><p>如果我们使用 Function Calling，那么需要通过代码给 LLM 提供一组 functions，并且提供清晰的函数描述、函数输入和输出，那么 LLM 就可以根据清晰的结构化数据进行推理，执行函数。</p><p>Function Calling 的缺点在于处理不好多轮对话和复杂需求，适合边界清晰、描述明确的任务。如果需要处理很多的任务，那么 Function Calling 的代码比较难维护。</p><h4 id="Model-Context-Protocol-MCP-1"><a href="#Model-Context-Protocol-MCP-1" class="headerlink" title="Model Context Protocol (MCP)"></a>Model Context Protocol (MCP)</h4><ul><li>MCP 是一个标准协议，如同电子设备的 Type C 协议(可以充电也可以传输数据)，使 AI 模型能够与不同的 API 和数据源无缝交互。</li><li>MCP 旨在替换碎片化的 Agent 代码集成，从而使 AI 系统更可靠，更有效。通过建立通用标准，服务商可以基于协议来推出它们自己服务的 AI 能力，从而支持开发者更快的构建更强大的 AI 应用。开发者也不需要重复造轮子，通过开源项目可以建立强大的 AI Agent 生态。</li><li>MCP 可以在不同的应用/服务之间保持上下文，从而增强整体自主执行任务的能力。</li></ul><p>可以理解为 MCP 是将不同任务进行分层处理，每一层都提供特定的能力、描述和限制。而 MCP Client 端根据不同的任务判断，选择是否需要调用某个能力，然后通过每层的输入和输出，构建一个可以处理复杂、多步对话和统一上下文的 Agent。</p><h4 id="AI-Agent"><a href="#AI-Agent" class="headerlink" title="AI Agent"></a>AI Agent</h4><ul><li>AI Agent 是一个智能系统，它可以自主运行以实现特定目标。传统的 AI 聊天仅提供建议或者需要手动执行任务，AI Agent 则可以分析具体情况，做出决策，并自行采取行动。</li><li>AI Agent 可以利用 MCP 提供的功能描述来理解更多的上下文，并在各种平台/服务自动执行任务。</li></ul><h3 id="MCP-Server-的工作原理"><a href="#MCP-Server-的工作原理" class="headerlink" title="MCP Server 的工作原理"></a>MCP Server 的工作原理</h3><p>MCP 的主要工作是描述 Server 提供了哪些能力(给 LLM 提供)，需要哪些参数(参数具体的功能是什么)，最后返回的结果是什么。<strong>只是一个具有共识的协议</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn@1.3.8/img/mcp.png" alt="image-20250623231124957"></p><h3 id="相关资源-2"><a href="#相关资源-2" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://guangzhengli.com/blog/zh/model-context-protocol">MCP 终极指南</a> </li><li><a href="https://modelcontextprotocol.io/introduction">官方文档</a></li><li><a href="https://arxiv.org/pdf/2503.23278">Model Context Protocol (MCP): Landscape, Security Threats, and Future Research Directions</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 大模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精要主义读后感(一)</title>
      <link href="posts/84c62ab4.html"/>
      <url>posts/84c62ab4.html</url>
      
        <content type="html"><![CDATA[<h1 id="精要主义：在纷繁世界中找回人生的掌控力"><a href="#精要主义：在纷繁世界中找回人生的掌控力" class="headerlink" title="精要主义：在纷繁世界中找回人生的掌控力"></a>精要主义：在纷繁世界中找回人生的掌控力</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在这个信息爆炸、选择过剩的时代，我们似乎从未如此“忙碌”，却又从未如此“空虚”。社交媒体上的焦虑、工作与生活的失衡、目标与行动的脱节，都在提醒我们：“多即是少”的陷阱正在吞噬我们的专注力与幸福感。《精要主义》（Greg McKeown 著）一书如同一剂清醒药，直指现代人的核心困境——如何从“疲于奔命”转向“精准发力”。它的答案简单却深刻：“更少，但更好”（Less but Better）。</p><h2 id="一、精要主义的本质：选择与放弃的智慧"><a href="#一、精要主义的本质：选择与放弃的智慧" class="headerlink" title="一、精要主义的本质：选择与放弃的智慧"></a>一、精要主义的本质：选择与放弃的智慧</h2><p>精要主义不是简单的“断舍离”，而是一种系统性思维，主张通过 <strong>“探索、排除、执行”</strong> 三步骤，筛选出真正重要的事务，并为其投入全部精力。其核心逻辑在于：</p><p><strong>“选择”的力量：</strong> 人生中90%的忙碌源于被动接受外界安排，而精要主义者主动掌握选择权，拒绝被“他人的优先级”绑架。</p><p><strong>“甄别”的智慧：</strong> 大多数事务只是“无意义的多数”，真正能创造价值的仅占20%。正如林语堂所言：“生之智慧，在于摒弃不必要之事”。</p><p><strong>“取舍”的勇气：</strong> 成功常成为失败的催化剂。例如，事业上升后机会增多，若全盘接受反而导致精力分散，最终瓦解最初的专注点。</p><h2 id="二、实践精要主义的三大步骤"><a href="#二、实践精要主义的三大步骤" class="headerlink" title="二、实践精要主义的三大步骤"></a>二、实践精要主义的三大步骤</h2><h3 id="探索：从混沌中筛选核心"><a href="#探索：从混沌中筛选核心" class="headerlink" title="探索：从混沌中筛选核心"></a>探索：从混沌中筛选核心</h3><p><strong>留白思考：</strong> 每天抽出15分钟脱离事务性工作，通过全局视角审视目标。比尔·盖茨每年“思考周”的案例证明，抽离是突破思维惯性的关键。</p><p><strong>90%法则：</strong> 评估每个机会时，若评分低于90分，果断舍弃。避免因“还不错”而陷入平庸。</p><p><strong>重视睡眠与游戏：</strong> 睡眠提升决策质量，游戏激发创造力，二者看似“无用”，实则是精要事务的催化剂。</p><h3 id="排除：优雅地说“不”"><a href="#排除：优雅地说“不”" class="headerlink" title="排除：优雅地说“不”"></a>排除：优雅地说“不”</h3><p><strong>设定边界：</strong> 明确个人与职业的“最低标准”与“极端标准”，例如拒绝不符合长期价值的会议或社交。</p><p><strong>止损思维：</strong> 当发现错误投入时，反问：“如果没有沉没成本，我现在会如何选择？”。</p><p><strong>案例启示：</strong> 高速监控员通过识别关键信息、过滤干扰项，提升工作效率，正是精要主义在职场中的典型应用。</p><h3 id="执行：让重要事务毫不费力"><a href="#执行：让重要事务毫不费力" class="headerlink" title="执行：让重要事务毫不费力"></a>执行：让重要事务毫不费力</h3><p><strong>小步迭代：</strong> 将大目标分解为每日可执行的微习惯，例如每天写作15分钟而非追求“完美文章”。</p><p><strong>建立缓冲：</strong> 预估任务时间时增加50%的缓冲量，减少意外干扰带来的焦虑。</p><p><strong>专注当下：</strong> “此时此刻最重要的事是什么？”这一提问，能瞬间过滤杂念，回归核心。</p><h2 id="三、精要主义的生活哲学"><a href="#三、精要主义的生活哲学" class="headerlink" title="三、精要主义的生活哲学"></a>三、精要主义的生活哲学</h2><p>精要主义不仅是效率工具，更是一种人生哲学：</p><p><strong>对抗“忙碌陷阱”：</strong> 许多人用战术上的勤奋掩盖战略上的懒惰，而精要主义者追求“有意义的成就”而非“虚假的充实感”。</p><p><strong>平衡与自由：</strong> 通过舍弃非核心事务，为健康、家庭和创造力留出空间。例如，拒绝加班文化以守护亲子时光。</p><p><strong>长期主义：</strong> 精要主义者的成功是“复利效应”的结果，日复一日聚焦关键领域，终将突破阈值。</p><h2 id="一场平静的革命"><a href="#一场平静的革命" class="headerlink" title="一场平静的革命"></a>一场平静的革命</h2><p>精要主义并非要求我们“做更少的事”，而是教会我们“用更少换更多”。它是一场对抗信息洪流与选择焦虑的“平静革命”，让我们从“被支配者”转变为“设计者”。正如书中所言：“当你允许自己变得挑剔，一切都将改变。”</p><p>在这个追求“更多”的世界里，或许真正的自由，恰恰来自于勇敢地选择“更少”。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
          <category> 精要主义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构的存储方式</title>
      <link href="posts/f48cea97.html"/>
      <url>posts/f48cea97.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构的存储方式"><a href="#数据结构的存储方式" class="headerlink" title="数据结构的存储方式"></a>数据结构的存储方式</h2><p><strong>数据结构的存储方式只有两种，数组（顺序存储）、链表（链式存储）</strong></p><ul><li>队列、栈:既可以用数组实现也可以用链表实现</li><li>图:邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。<blockquote><p>邻接表和邻接矩阵是图（graph）这种数据结构的两种常见表示方法。它们各自有优缺点，适用于不同的场景。下面分别介绍这两种表示方法。</p><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p><strong>定义</strong>：邻接矩阵是一个二维数组（或矩阵），用来表示图中顶点之间的连接关系。对于一个包含n个顶点的图，它的邻接矩阵是一个n×n的矩阵A，其中A[i][j]的值代表从顶点i到顶点j是否存在边。对于无权图，如果顶点i和顶点j之间有边，则A[i][j] = 1；否则A[i][j] = 0。对于有权图，A[i][j]则存储的是边(i, j)的权重，而如果不存在这样的边，通常会用一个特殊的值（如无穷大或0）来表示。<br><strong>优点</strong>：</p><ul><li>简单直观，容易理解和实现。</li><li>检查两个顶点之间是否存在边的时间复杂度为O(1)。</li><li>对于稠密图（即边数接近最大可能值的图），使用邻接矩阵比较节省空间且高效。</li></ul><p><strong>缺点</strong>：</p><ul><li>对于稀疏图（即边数远小于最大可能值的图），邻接矩阵会浪费大量的空间，因为大多数元素都是0。</li><li>添加或删除顶点时需要重新分配矩阵的空间，这可能会很耗时。</li></ul><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p><strong>定义</strong>：邻接表是一种更加节省空间的图表示方法，特别是对于稀疏图。它由一个长度为n的数组组成，每个元素指向一个链表（或列表），这个链表包含了与该顶点相邻的所有顶点。对于有权图，链表中的每一个元素还可以包括边的权重信息。</p><p><strong>优点</strong>：</p><ul><li>相比于邻接矩阵，对于稀疏图来说，邻接表更节省空间。</li><li>添加或删除边的操作相对简单，时间复杂度为O(1)（假设可以快速定位到相应的顶点）。</li><li>对于遍历图中的所有边，邻接表也更为高效。</li></ul><p><strong>缺点</strong>：</p><ul><li>检查两个顶点之间是否存在边的时间复杂度为O(d)，其中d是出发顶点的度（即与之相连的顶点数量）。在最坏情况下，这可能是O(n)。</li><li>实现起来稍微复杂一些，尤其是在处理有权图时，需要额外的数据结构来存储边的权重。<h3 id="选择哪种表示法"><a href="#选择哪种表示法" class="headerlink" title="选择哪种表示法"></a>选择哪种表示法</h3></li><li>如果图是稠密的，并且你需要频繁检查两个顶点之间是否有边，那么邻接矩阵可能是更好的选择。</li><li>如果图是稀疏的，或者你更关心节省空间以及添加/删除边的效率，那么邻接表可能更适合。</li><li>在某些特定的应用场景下，比如当图的边具有方向性（有向图）或图的结构是动态变化的时候，邻接表通常也是更好的选择。</li></ul></blockquote></li><li>散列表:就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针;线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。</li><li>树:用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单;用链表实现就是很常⻅的那种 「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种 链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL 树、红黑树、区间树、B 树等等，以应对不同的问题。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>数组由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而 且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所 以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过 去，时间复杂度 O(N);而且你如果想在数组中间进行插入和删除，每次必 须搬移后面的所有数据以保持连续，时间复杂度 O(N)。</li><li>链表因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组 的扩容问题;如果知道某一元素的前驱和后驱，操作指针即可删除该元素或 者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根 据一个索引算出对应元素的地址，所以不能随机访问;而且由于每个元素必 须存储指向前后元素位置的指针，会消耗相对更多的储存空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 算法专栏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Online DDL 原理</title>
      <link href="posts/99a0d2d3.html"/>
      <url>posts/99a0d2d3.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>❝</p><p>MySQL原生Online DDL是MySQL数据库提供的一项功能，它允许在不中断数据库服务的情况下执行数据定义语言（DDL）操作。</p><p>❞</p></blockquote><h2 id="一、背景与意义"><a href="#一、背景与意义" class="headerlink" title="一、背景与意义"></a>一、背景与意义</h2><p>在传统的数据库系统中，执行DDL操作时通常需要锁定表，以防止数据不一致。然而，这种锁定会导致表在DDL操作期间不可用，从而影响数据库的可用性。MySQL原生Online DDL解决了这个问题，它允许DDL操作在表仍然可用时执行，大大提高了数据库的可用性，特别是对于需要24/7高可用性的应用来说，这是一个重要的特性。</p><h2 id="二、工作机制"><a href="#二、工作机制" class="headerlink" title="二、工作机制"></a>二、工作机制</h2><p>MySQL原生Online DDL的工作机制涉及多个步骤和内部原理：</p><h3 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h3><ul><li><strong>「检查与评估」</strong>：在执行DDL操作之前，MySQL会进行一系列的检查和评估工作。这包括验证DDL操作的语法正确性、检查用户权限以及评估所需资源等。</li><li><strong>「选择执行策略」</strong>：根据DDL操作的类型和表的结构，MySQL会选择一个合适的执行策略。这通常涉及决定是使用COPY算法、INPLACE算法还是INSTANT算法。</li></ul><h3 id="2-执行DDL操作"><a href="#2-执行DDL操作" class="headerlink" title="2. 执行DDL操作"></a>2. 执行DDL操作</h3><ul><li><strong>「COPY算法」</strong>：<ul><li><strong>「创建临时表」</strong>：首先，MySQL会创建一个与原始表结构相似的新临时表。</li><li><strong>「数据拷贝」</strong>：接着，原始表中的数据会被逐行拷贝到新的临时表中。这个过程可能需要一些时间，具体取决于表的大小和系统的性能。</li><li><strong>「重命名与替换」</strong>：数据拷贝完成后，临时表会被重命名为原始表的名字，从而替换掉原始表。在这个过程中，原始表会被加上写锁，以阻止对数据进行修改，确保数据的一致性。</li></ul></li><li><strong>「INPLACE算法」</strong>：<ul><li><strong>「直接修改」</strong>：与COPY算法不同，INPLACE算法直接在原始表上进行修改，无需创建临时表和拷贝数据。</li><li><strong>「记录DML操作」</strong>：在DDL操作执行期间，如果有DML操作（如INSERT、UPDATE、DELETE）尝试修改表，这些操作会被记录下来。</li><li><strong>「应用DML更改」</strong>：DDL操作完成后，之前记录的DML更改会被应用到表上，确保数据的完整性和一致性。</li></ul></li><li><strong>「INSTANT算法」</strong>：<ul><li><strong>「元数据修改」</strong>：对于某些简单的DDL操作（如修改表的默认字符集），INSTANT算法可以直接修改数据字典中的元数据，而无需对表数据进行任何更改。</li><li><strong>「无锁操作」</strong>：由于只修改元数据，因此这种算法可以在不锁定表的情况下完成，实现了真正的“瞬间”完成DDL操作。</li></ul></li></ul><h3 id="3-完成与清理"><a href="#3-完成与清理" class="headerlink" title="3. 完成与清理"></a>3. 完成与清理</h3><ul><li><strong>「释放资源」</strong>：DDL操作完成后，系统会释放所有在操作过程中分配的资源，如临时表、内存等。</li><li><strong>「更新统计信息」</strong>：MySQL会更新与表相关的统计信息，以便优化器能够更好地制定查询计划。</li><li><strong>「通知与日志记录」</strong>：操作完成后，系统会生成相应的日志记录，以便在必要时进行恢复或审计。同时，也可能通过某种机制（如触发器）通知应用程序DDL操作的完成。</li></ul><p>MySQL原生Online DDL通过不同的算法和策略来实现在线修改数据库结构的目标，从而提高了数据库的可用性和灵活性。这些工作原理确保了即使在执行DDL操作时，数据库仍然能够处理正常的DML操作，减少了停机时间和维护成本。</p><p><img src= "/img/loading.gif" data-lazy-src="http://image.smfcc.cn:7791/i/2024/11/27/67473bc4307c4.png" alt="图片"></p><h2 id="三、实现原理与优化"><a href="#三、实现原理与优化" class="headerlink" title="三、实现原理与优化"></a>三、实现原理与优化</h2><p>在线DDL的核心实现原理涉及几个关键环节，同时也有一些关键的优化策略：</p><ol><li><strong>「构建临时表」</strong>：为了不影响原表的正常读写，系统会创建一个具备新结构的临时表。这一步骤为后续的DDL操作提供了基础。</li><li><strong>「数据迁移与实时同步」</strong>：旧表中的数据会被高效地迁移到临时表中，同时确保数据的实时同步。这种迁移策略旨在保障DDL过程中数据的完整性和一致性，避免数据丢失或损坏。</li><li><strong>「变更追踪与重播」</strong>：利用日志机制，系统会追踪DDL执行期间旧表上的数据变更，并将这些变更实时重播到临时表中。这一优化确保了数据在DDL操作完成后的准确性。</li><li><strong>「无缝切换」</strong>：当DDL操作完成且数据完全同步后，数据库引擎会在合适的时机将临时表提升为新表，从而实现无缝切换。此后，所有的读写操作都将基于新表进行。</li></ol><h2 id="四、使用场景与优势"><a href="#四、使用场景与优势" class="headerlink" title="四、使用场景与优势"></a>四、使用场景与优势</h2><p>MySQL原生Online DDL适用于多种场景，如添加或删除列、修改数据类型、添加或删除索引等。这些操作都可以在不中断服务的情况下完成，大大提高了数据库的灵活性和可用性。此外，由于Online DDL减少了停机时间，因此也降低了维护成本和数据丢失的风险。</p><h2 id="五、使用约束与注意事项"><a href="#五、使用约束与注意事项" class="headerlink" title="五、使用约束与注意事项"></a>五、使用约束与注意事项</h2><p>尽管MySQL 5.7的在线DDL带来了诸多便利，但在实际使用中仍需注意以下几点：</p><ul><li><strong>「操作支持范围」</strong>：并非所有类型的DDL操作都支持在线执行。某些特定操作可能仍需要锁定整张表，因此在执行前需确认操作类型。</li><li><strong>「资源占用」</strong>：DDL操作期间可能会显著增加系统资源的消耗，特别是在数据迁移和同步阶段。因此，在高负载环境下应谨慎规划并执行此类操作。</li><li><strong>「测试与验证」</strong>：为确保数据的完整性和业务的连续性，执行在线DDL之前应进行充分的测试和验证。这包括但不限于数据的备份、恢复以及一致性检查等步骤。</li></ul><h2 id="六、锁在Online-DDL中的作用"><a href="#六、锁在Online-DDL中的作用" class="headerlink" title="六、锁在Online DDL中的作用"></a>六、锁在Online DDL中的作用</h2><p>在Online DDL过程中，锁主要用于确保数据的一致性。不同类型的锁对表的可访问性有不同的影响：</p><ol><li><strong>「共享锁（S锁）」</strong>：允许多个事务读取同一资源，但不允许写入。在Online DDL中，这可能用于允许读取操作继续进行，同时阻止写入操作。</li><li><strong>「排他锁（X锁）」</strong>：阻止其他事务读取或写入资源。在DDL操作中，如果需要修改表的结构或数据，则可能需要使用排他锁。</li></ol><h3 id="ALGORITHM和LOCK选项"><a href="#ALGORITHM和LOCK选项" class="headerlink" title="ALGORITHM和LOCK选项"></a>ALGORITHM和LOCK选项</h3><p>在MySQL中，你可以通过<code>ALGORITHM</code>和<code>LOCK</code>关键字来控制DDL操作的行为。</p><h4 id="ALGORITHM选项"><a href="#ALGORITHM选项" class="headerlink" title="ALGORITHM选项"></a>ALGORITHM选项</h4><ul><li><strong>「INPLACE」</strong>：这个选项指示MySQL直接在原表上进行修改，而不是创建一个新表。这通常可以减少锁的使用和时间，从而提高并发性。但是，并非所有的DDL操作都支持INPLACE算法。</li><li><strong>「COPY」</strong>：这个选项告诉MySQL创建一个新表，将原表的数据复制到新表中，然后在新表上执行DDL操作。完成后，新表会替换原表。这个过程中，原表通常会被锁定，以防止数据不一致。COPY算法通常需要更多的时间和资源。</li><li><strong>「DEFAULT」</strong>：如果不指定ALGORITHM选项，MySQL将选择默认的行为。这通常是尝试使用INPLACE算法，如果不可能，则回退到COPY算法。</li></ul><h4 id="LOCK选项"><a href="#LOCK选项" class="headerlink" title="LOCK选项"></a>LOCK选项</h4><ul><li> <strong>「NONE」</strong>：这个选项指示MySQL在执行DDL操作时不要对表加锁（如果可能的话）。但是，如果DDL操作需要保证数据的一致性，MySQL可能会忽略这个选项并加锁。</li></ul><ul><li><strong>「SHARED」</strong>：允许读取操作继续进行，但阻止写入操作。</li><li><strong>「EXCLUSIVE」</strong>：阻止读取和写入操作。这是最强的锁类型，用于确保DDL操作期间数据的一致性。</li></ul><h3 id="如何使用这些选项"><a href="#如何使用这些选项" class="headerlink" title="如何使用这些选项"></a>如何使用这些选项</h3><p>当你想要执行一个DDL操作时，你可以通过添加<code>ALGORITHM</code>和<code>LOCK</code>选项来控制操作的行为。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD COLUMN col_name col_type, ALGORITHM&#x3D;INPLACE, LOCK&#x3D;NONE;</span><br></pre></td></tr></table></figure><p>这条命令尝试在原地（INPLACE）添加一个新列，并且尽量不使用锁（LOCK=NONE）。但是，需要注意的是，如果MySQL判断无法保证数据的一致性而不使用锁，它可能会忽略这些选项。</p><p>可以通过如下的SQL语句查看是否有事务和锁等信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.innodb_locks;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.innodb_trx;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.innodb_lock_waits;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from information_schema.processlist;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="http://image.smfcc.cn:7791/i/2024/11/27/67473b8aebc90.jpeg" alt="图片"></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>不是所有的DDL操作都支持所有的ALGORITHM和LOCK组合。在执行DDL操作之前，最好查阅MySQL的官方文档以了解具体的支持情况。<img src= "/img/loading.gif" data-lazy-src="http://image.smfcc.cn:7791/i/2024/11/27/67473bab8f606.jpeg" alt="图片"></li><li>即使指定了LOCK=NONE，MySQL也可能在必要时自动加锁以确保数据的一致性。因此，这些选项应被视为指导性的，而不是强制性的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>追源索骥：透过源码看懂Flink核心框架的执行流程</title>
      <link href="posts/80ca231b.html"/>
      <url>posts/80ca231b.html</url>
      
        <content type="html"><![CDATA[<h1 id="追源索骥：透过源码看懂Flink核心框架的执行流程"><a href="#追源索骥：透过源码看懂Flink核心框架的执行流程" class="headerlink" title="追源索骥：透过源码看懂Flink核心框架的执行流程"></a>追源索骥：透过源码看懂Flink核心框架的执行流程</h1><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flink是大数据处理领域最近很火的一个开源的分布式、高性能的流式处理框架，其对数据的处理可以达到毫秒级别。本文以一个来自官网的WordCount例子为引，全面阐述flink的核心架构及执行流程，希望读者可以借此更加深入的理解Flink逻辑。</p><blockquote><p>本文跳过了一些基本概念，如果对相关概念感到迷惑，请参考官网文档。另外在本文写作过程中，Flink正式发布了其1.5 RELEASE版本，在其发布之后完成的内容将按照1.5的实现来组织。</p></blockquote><h2 id="1-从-Hello-World-WordCount开始"><a href="#1-从-Hello-World-WordCount开始" class="headerlink" title="1.从 Hello,World WordCount开始"></a>1.从 <del>Hello,World</del> WordCount开始</h2><p>首先，我们把WordCount的例子再放一遍：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   public class SocketTextStreamWordCount &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">if (args.length !&#x3D; 2)&#123;</span><br><span class="line">System.err.println(&quot;USAGE:\nSocketTextStreamWordCount &lt;hostname&gt; &lt;port&gt;&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">String hostName &#x3D; args[0];</span><br><span class="line">Integer port &#x3D; Integer.parseInt(args[1]);</span><br><span class="line">&#x2F;&#x2F; set up the execution environment</span><br><span class="line">final StreamExecutionEnvironment env &#x3D; StreamExecutionEnvironment</span><br><span class="line">.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get input data</span><br><span class="line">DataStream&lt;String&gt; text &#x3D; env.socketTextStream(hostName, port);</span><br><span class="line"></span><br><span class="line">text.flatMap(new LineSplitter()).setParallelism(1)</span><br><span class="line">&#x2F;&#x2F; group by the tuple field &quot;0&quot; and sum up tuple field &quot;1&quot;</span><br><span class="line">.keyBy(0)</span><br><span class="line">.sum(1).setParallelism(1)</span><br><span class="line">.print();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; execute program</span><br><span class="line">env.execute(&quot;Java WordCount from SocketTextStream Example&quot;);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Implements the string tokenizer that splits sentences into words as a user-defined</span><br><span class="line">    * FlatMapFunction. The function takes a line (String) and splits it into</span><br><span class="line">    * multiple pairs in the form of &quot;(word,1)&quot; (Tuple2&lt;String, Integer&gt;).</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static final class LineSplitter implements FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt; &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public void flatMap(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out) &#123;</span><br><span class="line">   &#x2F;&#x2F; normalize and split the line</span><br><span class="line">   String[] tokens &#x3D; value.toLowerCase().split(&quot;\\W+&quot;);</span><br><span class="line">   &#x2F;&#x2F; emit the pairs</span><br><span class="line">   for (String token : tokens) &#123;</span><br><span class="line">   if (token.length() &gt; 0) &#123;</span><br><span class="line">   out.collect(new Tuple2&lt;String, Integer&gt;(token, 1));</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>首先从命令行中获取socket对端的ip和端口，然后启动一个执行环境，从socket中读取数据，split成单个单词的流，并按单词进行总和的计数，最后打印出来。这个例子相信接触过大数据计算或者函数式编程的人都能看懂，就不过多解释了。</p><h3 id="1-1-flink执行环境"><a href="#1-1-flink执行环境" class="headerlink" title="1.1 flink执行环境"></a>1.1 flink执行环境</h3><p>程序的启动，从这句开始：<code> final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()</code>。<br>这行代码会返回一个可用的执行环境。执行环境是整个flink程序执行的上下文，记录了相关配置（如并行度等），并提供了一系列方法，如读取输入流的方法，以及真正开始运行整个代码的execute方法等。对于分布式流处理程序来说，我们在代码中定义的flatMap,keyBy等等操作，事实上可以理解为一种声明，告诉整个程序我们采用了什么样的算子，而真正开启计算的代码不在此处。由于我们是在本地运行flink程序，因此这行代码会返回一个LocalStreamEnvironment，最后我们要调用它的execute方法来开启真正的任务。我们先接着往下看。</p><h3 id="1-2-算子（Operator）的注册（声明）"><a href="#1-2-算子（Operator）的注册（声明）" class="headerlink" title="1.2 算子（Operator）的注册（声明）"></a>1.2 算子（Operator）的注册（声明）</h3><p>我们以flatMap为例,<code>text.flatMap(new LineSplitter())</code>这一句话跟踪进去是这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; flatMap(FlatMapFunction&lt;T, R&gt; flatMapper) &#123;</span><br><span class="line"></span><br><span class="line">TypeInformation&lt;R&gt; outType &#x3D; TypeExtractor.getFlatMapReturnTypes(clean(flatMapper),</span><br><span class="line">getType(), Utils.getCallLocationName(), true);</span><br><span class="line"></span><br><span class="line">return transform(&quot;Flat Map&quot;, outType, new StreamFlatMap&lt;&gt;(clean(flatMapper)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面完成了两件事，一是用反射拿到了flatMap算子的输出类型，二是生成了一个Operator。flink流式计算的核心概念，就是将数据从输入流一个个传递给Operator进行链式处理，最后交给输出流的过程。对数据的每一次处理在逻辑上成为一个operator，并且为了本地化处理的效率起见，operator之间也可以串成一个chain一起处理（可以参考责任链模式帮助理解）。下面这张图表明了flink是如何看待用户的处理流程的：抽象化为一系列operator，以source开始，以sink结尾，中间的operator做的操作叫做transform，并且可以把几个操作串在一起执行。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/jal2x1y6zqs4jug4ryqnvu3l/image_1cae39t06eoo3ml1be8o0412c69.png" alt="image_1cae39t06eoo3ml1be8o0412c69.png-43.5kB"><br>我们也可以更改flink的设置，要求它不要对某个操作进行chain处理，或者从某个操作开启一个新chain等。<br>上面代码中的最后一行transform方法的作用是返回一个SingleOutputStreamOperator，它继承了Datastream类并且定义了一些辅助方法，方便对流的操作。在返回之前，transform方法还把它注册到了执行环境中（后面生成执行图的时候还会用到它）。其他的操作，包括keyBy，sum和print，都只是不同的算子，在这里出现都是一样的效果，即生成一个operator并注册给执行环境用于生成DAG。</p><h3 id="1-3-程序的执行"><a href="#1-3-程序的执行" class="headerlink" title="1.3 程序的执行"></a>1.3 程序的执行</h3><p>程序执行即<code>env.execute(&quot;Java WordCount from SocketTextStream Example&quot;)</code>这行代码。</p><h4 id="1-3-1-本地模式下的execute方法"><a href="#1-3-1-本地模式下的execute方法" class="headerlink" title="1.3.1 本地模式下的execute方法"></a>1.3.1 本地模式下的execute方法</h4><p>这行代码主要做了以下事情：</p><ul><li>生成StreamGraph。代表程序的拓扑结构，是从用户代码直接生成的图。</li><li>生成JobGraph。这个图是要交给flink去生成task的图。</li><li>生成一系列配置</li><li>将JobGraph和配置交给flink集群去运行。如果不是本地运行的话，还会把jar文件通过网络发给其他节点。</li><li>以本地模式运行的话，可以看到启动过程，如启动性能度量、web模块、JobManager、ResourceManager、taskManager等等</li><li>启动任务。值得一提的是在启动任务之前，先启动了一个用户类加载器，这个类加载器可以用来做一些在运行时动态加载类的工作。</li></ul><h4 id="1-3-2-远程模式（RemoteEnvironment）的execute方法"><a href="#1-3-2-远程模式（RemoteEnvironment）的execute方法" class="headerlink" title="1.3.2 远程模式（RemoteEnvironment）的execute方法"></a>1.3.2 远程模式（RemoteEnvironment）的execute方法</h4><p>远程模式的程序执行更加有趣一点。第一步仍然是获取StreamGraph，然后调用executeRemotely方法进行远程执行。<br>该方法首先创建一个用户代码加载器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ClassLoader usercodeClassLoader &#x3D; JobWithJars.buildUserCodeClassLoader(jarFiles, globalClasspaths,   getClass().getClassLoader());</span><br></pre></td></tr></table></figure><p>然后创建一系列配置，交给Client对象。Client这个词有意思，看见它就知道这里绝对是跟远程集群打交道的客户端。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      ClusterClient client;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">client &#x3D; new StandaloneClusterClient(configuration);</span><br><span class="line">client.setPrintStatusDuringExecution(getConfig().isSysoutLoggingEnabled());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">return client.run(streamGraph, jarFiles, globalClasspaths, usercodeClassLoader).getJobExecutionResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client的run方法首先生成一个JobGraph，然后将其传递给JobClient。关于Client、JobClient、JobManager到底谁管谁，可以看这张图：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/6hhl3e1fumlr0aq78d2m35nt/image_1cae7g15p6k94no1ves121c5pd9.png" alt="image_1cae7g15p6k94no1ves121c5pd9.png-19.7kB"><br>确切的说，JobClient负责以异步的方式和JobManager通信（Actor是scala的异步模块），具体的通信任务由JobClientActor完成。相对应的，JobManager的通信任务也由一个Actor完成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JobListeningContext jobListeningContext &#x3D; submitJob(</span><br><span class="line">actorSystem,config,highAvailabilityServices,jobGraph,timeout,sysoutLogUpdates,classLoader);</span><br><span class="line"></span><br><span class="line">return awaitJobResult(jobListeningContext);</span><br></pre></td></tr></table></figure><p>可以看到，该方法阻塞在awaitJobResult方法上，并最终返回了一个JobListeningContext，透过这个Context可以得到程序运行的状态和结果。</p><h4 id="1-3-3-程序启动过程"><a href="#1-3-3-程序启动过程" class="headerlink" title="1.3.3 程序启动过程"></a>1.3.3 程序启动过程</h4><p>上面提到，整个程序真正意义上开始执行，是这里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env.execute(&quot;Java WordCount from SocketTextStream Example&quot;);</span><br></pre></td></tr></table></figure><p>远程模式和本地模式有一点不同，我们先按本地模式来调试。<br>我们跟进源码，（在本地调试模式下）会启动一个miniCluster，然后开始执行代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; LocalStreamEnvironment.java</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public JobExecutionResult execute(String jobName) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;生成各种图结构</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;启动集群，包括启动JobMaster，进行leader选举等等</span><br><span class="line">miniCluster.start();</span><br><span class="line">configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().getPort());</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;提交任务到JobMaster</span><br><span class="line">return miniCluster.executeJobBlocking(jobGraph);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">transformations.clear();</span><br><span class="line">miniCluster.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里有一部分逻辑是与生成图结构相关的，我们放在第二章里讲；现在我们先接着往里跟：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;MiniCluster.java</span><br><span class="line">public JobExecutionResult executeJobBlocking(JobGraph job) throws JobExecutionException, InterruptedException &#123;</span><br><span class="line">checkNotNull(job, &quot;job is null&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;在这里，最终把job提交给了jobMaster</span><br><span class="line">final CompletableFuture&lt;JobSubmissionResult&gt; submissionFuture &#x3D; submitJob(job);</span><br><span class="line"></span><br><span class="line">final CompletableFuture&lt;JobResult&gt; jobResultFuture &#x3D; submissionFuture.thenCompose(</span><br><span class="line">(JobSubmissionResult ignored) -&gt; requestJobResult(job.getJobID()));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我在注释里写的，这一段代码核心逻辑就是调用那个<code>submitJob</code>方法。那么我们再接着看这个方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public CompletableFuture&lt;JobSubmissionResult&gt; submitJob(JobGraph jobGraph) &#123;</span><br><span class="line">final DispatcherGateway dispatcherGateway;</span><br><span class="line">try &#123;</span><br><span class="line">dispatcherGateway &#x3D; getDispatcherGateway();</span><br><span class="line">&#125; catch (LeaderRetrievalException | InterruptedException e) &#123;</span><br><span class="line">ExceptionUtils.checkInterrupted(e);</span><br><span class="line">return FutureUtils.completedExceptionally(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; we have to allow queued scheduling in Flip-6 mode because we need to request slots</span><br><span class="line">&#x2F;&#x2F; from the ResourceManager</span><br><span class="line">jobGraph.setAllowQueuedScheduling(true);</span><br><span class="line"></span><br><span class="line">final CompletableFuture&lt;Void&gt; jarUploadFuture &#x3D; uploadAndSetJarFiles(dispatcherGateway, jobGraph);</span><br><span class="line"></span><br><span class="line">final CompletableFuture&lt;Acknowledge&gt; acknowledgeCompletableFuture &#x3D; jarUploadFuture.thenCompose(</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在这里执行了真正的submit操作</span><br><span class="line">(Void ack) -&gt; dispatcherGateway.submitJob(jobGraph, rpcTimeout));</span><br><span class="line"></span><br><span class="line">return acknowledgeCompletableFuture.thenApply(</span><br><span class="line">(Acknowledge ignored) -&gt; new JobSubmissionResult(jobGraph.getJobID()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>Dispatcher</code>是一个接收job，然后指派JobMaster去启动任务的类,我们可以看看它的类结构，有两个实现。在本地环境下启动的是<code>MiniDispatcher</code>，在集群上提交任务时，集群上启动的是<code>StandaloneDispatcher</code>。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/y9hjeinc58dqc7wiepv2iim4/image_1cenfj3p9fp110p0a8unn1mrh9.png" alt="image_1cenfj3p9fp110p0a8unn1mrh9.png-27.4kB"></p><p>那么这个Dispatcher又做了什么呢？它启动了一个<code>JobManagerRunner</code>（这里我要吐槽Flink的命名，这个东西应该叫做JobMasterRunner才对，flink里的JobMaster和JobManager不是一个东西），委托JobManagerRunner去启动该Job的<code>JobMaster</code>。我们看一下对应的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;jobManagerRunner.java</span><br><span class="line">    private void verifyJobSchedulingStatusAndStartJobManager(UUID leaderSessionId) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    final CompletableFuture&lt;Acknowledge&gt; startFuture &#x3D; jobMaster.start(new JobMasterId(leaderSessionId), rpcTimeout);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，JobMaster经过了一堆方法嵌套之后，执行到了这里：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void scheduleExecutionGraph() &#123;</span><br><span class="line">checkState(jobStatusListener &#x3D;&#x3D; null);</span><br><span class="line">&#x2F;&#x2F; register self as job status change listener</span><br><span class="line">jobStatusListener &#x3D; new JobManagerJobStatusListener();</span><br><span class="line">executionGraph.registerJobStatusListener(jobStatusListener);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;这里调用了ExecutionGraph的启动方法</span><br><span class="line">executionGraph.scheduleForExecution();</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable t) &#123;</span><br><span class="line">executionGraph.failGlobal(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，flink的框架里有三层图结构，其中ExecutionGraph就是真正被执行的那一层，所以到这里为止，一个任务从提交到真正执行的流程就走完了，我们再回顾一下（顺便提一下远程提交时的流程区别）：</p><ul><li>客户端代码的execute方法执行；</li><li>本地环境下，MiniCluster完成了大部分任务，直接把任务委派给了MiniDispatcher；</li><li>远程环境下，启动了一个<code>RestClusterClient</code>，这个类会以HTTP Rest的方式把用户代码提交到集群上；</li><li>远程环境下，请求发到集群上之后，必然有个handler去处理，在这里是<code>JobSubmitHandler</code>。这个类接手了请求后，委派StandaloneDispatcher启动job，到这里之后，本地提交和远程提交的逻辑往后又统一了；</li><li>Dispatcher接手job之后，会实例化一个<code>JobManagerRunner</code>，然后用这个runner启动job；</li><li>JobManagerRunner接下来把job交给了<code>JobMaster</code>去处理；</li><li>JobMaster使用<code>ExecutionGraph</code>的方法启动了整个执行图；整个任务就启动起来了。</li></ul><p>至此，第一部分就讲完了。</p><h2 id="2-理解flink的图结构"><a href="#2-理解flink的图结构" class="headerlink" title="2.理解flink的图结构"></a>2.理解flink的图结构</h2><p>第一部分讲到，我们的主函数最后一项任务就是生成StreamGraph，然后生成JobGraph，然后以此开始调度任务运行，所以接下来我们从这里入手，继续探索flink。</p><h3 id="2-1-flink的三层图结构"><a href="#2-1-flink的三层图结构" class="headerlink" title="2.1 flink的三层图结构"></a>2.1 flink的三层图结构</h3><p>事实上，flink总共提供了三种图的抽象，我们前面已经提到了StreamGraph和JobGraph，还有一种是ExecutionGraph，是用于调度的基本数据结构。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/nseitc0kyuq0n44s7qcp6ij9/image_1caf1oll019fp1odv1bh9idosr79.png" alt="image_1caf1oll019fp1odv1bh9idosr79.png-486.3kB"><br>上面这张图清晰的给出了flink各个图的工作原理和转换过程。其中最后一个物理执行图并非flink的数据结构，而是程序开始执行后，各个task分布在不同的节点上，所形成的物理上的关系表示。</p><ul><li>从JobGraph的图里可以看到，数据从上一个operator流到下一个operator的过程中，上游作为生产者提供了IntermediateDataSet，而下游作为消费者需要JobEdge。事实上，JobEdge是一个通信管道，连接了上游生产的dataset和下游的JobVertex节点。</li><li>在JobGraph转换到ExecutionGraph的过程中，主要发生了以下转变：</li><li> 加入了并行度的概念，成为真正可调度的图结构</li><li> 生成了与JobVertex对应的ExecutionJobVertex，ExecutionVertex，与IntermediateDataSet对应的IntermediateResult和IntermediateResultPartition等，并行将通过这些类实现</li><li>ExecutionGraph已经可以用于调度任务。我们可以看到，flink根据该图生成了一一对应的Task，每个task对应一个ExecutionGraph的一个Execution。Task用InputGate、InputChannel和ResultPartition对应了上面图中的IntermediateResult和ExecutionEdge。</li></ul><p>那么，flink抽象出这三层图结构，四层执行逻辑的意义是什么呢？<br>StreamGraph是对用户逻辑的映射。JobGraph在此基础上进行了一些优化，比如把一部分操作串成chain以提高效率。ExecutionGraph是为了调度存在的，加入了并行处理的概念。而在此基础上真正执行的是Task及其相关结构。</p><h3 id="2-2-StreamGraph的生成"><a href="#2-2-StreamGraph的生成" class="headerlink" title="2.2 StreamGraph的生成"></a>2.2 StreamGraph的生成</h3><p>在第一节的算子注册部分，我们可以看到，flink把每一个算子transform成一个对流的转换（比如上文中返回的SingleOutputStreamOperator是一个DataStream的子类），并且注册到执行环境中，用于生成StreamGraph。实际生成StreamGraph的入口是<code>StreamGraphGenerator.generate(env, transformations)</code> 其中的transformations是一个list，里面记录的就是我们在transform方法中放进来的算子。</p><h4 id="2-2-1-StreamTransformation类代表了流的转换"><a href="#2-2-1-StreamTransformation类代表了流的转换" class="headerlink" title="2.2.1 StreamTransformation类代表了流的转换"></a>2.2.1 StreamTransformation类代表了流的转换</h4><p>StreamTransformation代表了从一个或多个DataStream生成新DataStream的操作。顺便，DataStream类在内部组合了一个StreamTransformation类，实际的转换操作均通过该类完成。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/69v9syr2p5k5om3c4jox9wh0/image_1caf64b7c1gjnv2eebi1v9e1cvum.png" alt="image_1caf64b7c1gjnv2eebi1v9e1cvum.png-129.4kB"><br>我们可以看到，从source到各种map,union再到sink操作全部被映射成了StreamTransformation。<br>其映射过程如下所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/a8sjspg8agzl3utnncntds9q/image_1caf6ak4rkqsc1u1hci93fe0d13.png" alt="image_1caf6ak4rkqsc1u1hci93fe0d13.png-36.6kB"></p><p>以MapFunction为例：</p><ul><li>首先，用户代码里定义的UDF会被当作其基类对待，然后交给StreamMap这个operator做进一步包装。事实上，每一个Transformation都对应了一个StreamOperator。</li><li>由于map这个操作只接受一个输入，所以再被进一步包装为OneInputTransformation。</li><li>最后，将该transformation注册到执行环境中，当执行上文提到的generate方法时，生成StreamGraph图结构。</li></ul><blockquote><p>另外，并不是每一个 StreamTransformation 都会转换成runtime层中的物理操作。有一些只是逻辑概念，比如union、split/select、partition等。如下图所示的转换树，在运行时会优化成下方的操作图。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/6zmlsivd9cjdm5nhsacuk3o1/image_1caf71h79s0s3fodem1aeb1j3m1g.png" alt="image_1caf71h79s0s3fodem1aeb1j3m1g.png-83.8kB"></p></blockquote><h4 id="2-2-2-StreamGraph生成函数分析"><a href="#2-2-2-StreamGraph生成函数分析" class="headerlink" title="2.2.2 StreamGraph生成函数分析"></a>2.2.2 StreamGraph生成函数分析</h4><p>我们从StreamGraphGenerator.generate()方法往下看：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static StreamGraph generate(StreamExecutionEnvironment env, List&lt;StreamTransformation&lt;?&gt;&gt; transformations) &#123;</span><br><span class="line">return new StreamGraphGenerator(env).generateInternal(transformations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;注意，StreamGraph的生成是从sink开始的</span><br><span class="line">private StreamGraph generateInternal(List&lt;StreamTransformation&lt;?&gt;&gt; transformations) &#123;</span><br><span class="line">for (StreamTransformation&lt;?&gt; transformation: transformations) &#123;</span><br><span class="line">transform(transformation);</span><br><span class="line">&#125;</span><br><span class="line">return streamGraph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个方法的核心逻辑就是判断传入的steamOperator是哪种类型，并执行相应的操作，详情见下面那一大堆if-else</span><br><span class="line">private Collection&lt;Integer&gt; transform(StreamTransformation&lt;?&gt; transform) &#123;</span><br><span class="line"></span><br><span class="line">if (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">return alreadyTransformed.get(transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LOG.debug(&quot;Transforming &quot; + transform);</span><br><span class="line"></span><br><span class="line">if (transform.getMaxParallelism() &lt;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if the max parallelism hasn&#39;t been set, then first use the job wide max parallelism</span><br><span class="line">&#x2F;&#x2F; from theExecutionConfig.</span><br><span class="line">int globalMaxParallelismFromConfig &#x3D; env.getConfig().getMaxParallelism();</span><br><span class="line">if (globalMaxParallelismFromConfig &gt; 0) &#123;</span><br><span class="line">transform.setMaxParallelism(globalMaxParallelismFromConfig);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; call at least once to trigger exceptions about MissingTypeInfo</span><br><span class="line">transform.getOutputType();</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; transformedIds;</span><br><span class="line">&#x2F;&#x2F;这里对操作符的类型进行判断，并以此调用相应的处理逻辑.简而言之，处理的核心无非是递归的将该节点和节点的上游节点加入图</span><br><span class="line">if (transform instanceof OneInputTransformation&lt;?, ?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformOneInputTransform((OneInputTransformation&lt;?, ?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof TwoInputTransformation&lt;?, ?, ?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformTwoInputTransform((TwoInputTransformation&lt;?, ?, ?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof SourceTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformSource((SourceTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof SinkTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformSink((SinkTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof UnionTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformUnion((UnionTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof SplitTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformSplit((SplitTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof SelectTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformSelect((SelectTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof FeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformFeedback((FeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof CoFeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformCoFeedback((CoFeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof PartitionTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformPartition((PartitionTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else if (transform instanceof SideOutputTransformation&lt;?&gt;) &#123;</span><br><span class="line">transformedIds &#x3D; transformSideOutput((SideOutputTransformation&lt;?&gt;) transform);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Unknown transformation: &quot; + transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;注意这里和函数开始时的方法相对应，在有向图中要注意避免循环的产生</span><br><span class="line">&#x2F;&#x2F; need this check because the iterate transformation adds itself before</span><br><span class="line">&#x2F;&#x2F; transforming the feedback edges</span><br><span class="line">if (!alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">alreadyTransformed.put(transform, transformedIds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (transform.getBufferTimeout() &gt; 0) &#123;</span><br><span class="line">streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout());</span><br><span class="line">&#125;</span><br><span class="line">if (transform.getUid() !&#x3D; null) &#123;</span><br><span class="line">streamGraph.setTransformationUID(transform.getId(), transform.getUid());</span><br><span class="line">&#125;</span><br><span class="line">if (transform.getUserProvidedNodeHash() !&#x3D; null) &#123;</span><br><span class="line">streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (transform.getMinResources() !&#x3D; null &amp;&amp; transform.getPreferredResources() !&#x3D; null) &#123;</span><br><span class="line">streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return transformedIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为map，filter等常用操作都是OneInputStreamOperator,我们就来看看<code>transformOneInputTransform((OneInputTransformation&lt;?, ?&gt;) transform)</code>方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;IN, OUT&gt; Collection&lt;Integer&gt; transformOneInputTransform(OneInputTransformation&lt;IN, OUT&gt; transform) &#123;</span><br><span class="line"></span><br><span class="line">Collection&lt;Integer&gt; inputIds &#x3D; transform(transform.getInput());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在递归处理节点过程中，某个节点可能已经被其他子节点先处理过了，需要跳过</span><br><span class="line">if (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">return alreadyTransformed.get(transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里是获取slotSharingGroup。这个group用来定义当前我们在处理的这个操作符可以跟什么操作符chain到一个slot里进行操作</span><br><span class="line">        &#x2F;&#x2F;因为有时候我们可能不满意flink替我们做的chain聚合</span><br><span class="line">        &#x2F;&#x2F;一个slot就是一个执行task的基本容器</span><br><span class="line">String slotSharingGroup &#x3D; determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;把该operator加入图</span><br><span class="line">streamGraph.addOperator(transform.getId(),</span><br><span class="line">slotSharingGroup,</span><br><span class="line">transform.getOperator(),</span><br><span class="line">transform.getInputType(),</span><br><span class="line">transform.getOutputType(),</span><br><span class="line">transform.getName());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;对于keyedStream，我们还要记录它的keySelector方法</span><br><span class="line">        &#x2F;&#x2F;flink并不真正为每个keyedStream保存一个key，而是每次需要用到key的时候都使用keySelector方法进行计算</span><br><span class="line">        &#x2F;&#x2F;因此，我们自定义的keySelector方法需要保证幂等性</span><br><span class="line">        &#x2F;&#x2F;到后面介绍keyGroup的时候我们还会再次提到这一点</span><br><span class="line">if (transform.getStateKeySelector() !&#x3D; null) &#123;</span><br><span class="line">TypeSerializer&lt;?&gt; keySerializer &#x3D; transform.getStateKeyType().createSerializer(env.getConfig());</span><br><span class="line">streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">streamGraph.setParallelism(transform.getId(), transform.getParallelism());</span><br><span class="line">streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism());</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;为当前节点和它的依赖节点建立边</span><br><span class="line">        &#x2F;&#x2F;这里可以看到之前提到的select union partition等逻辑节点被合并入edge的过程</span><br><span class="line">for (Integer inputId: inputIds) &#123;</span><br><span class="line">streamGraph.addEdge(inputId, transform.getId(), 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return Collections.singleton(transform.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addEdge(Integer upStreamVertexID, Integer downStreamVertexID, int typeNumber) &#123;</span><br><span class="line">addEdgeInternal(upStreamVertexID,</span><br><span class="line">downStreamVertexID,</span><br><span class="line">typeNumber,</span><br><span class="line">null,</span><br><span class="line">new ArrayList&lt;String&gt;(),</span><br><span class="line">null);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F;addEdge的实现，会合并一些逻辑节点</span><br><span class="line">private void addEdgeInternal(Integer upStreamVertexID,</span><br><span class="line">Integer downStreamVertexID,</span><br><span class="line">int typeNumber,</span><br><span class="line">StreamPartitioner&lt;?&gt; partitioner,</span><br><span class="line">List&lt;String&gt; outputNames,</span><br><span class="line">OutputTag outputTag) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果输入边是侧输出节点，则把side的输入边作为本节点的输入边，并递归调用</span><br><span class="line">if (virtualSideOutputNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line">int virtualId &#x3D; upStreamVertexID;</span><br><span class="line">upStreamVertexID &#x3D; virtualSideOutputNodes.get(virtualId).f0;</span><br><span class="line">if (outputTag &#x3D;&#x3D; null) &#123;</span><br><span class="line">outputTag &#x3D; virtualSideOutputNodes.get(virtualId).f1;</span><br><span class="line">&#125;</span><br><span class="line">addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, null, outputTag);</span><br><span class="line">&#x2F;&#x2F;如果输入边是select，则把select的输入边作为本节点的输入边</span><br><span class="line">&#125; else if (virtualSelectNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line">int virtualId &#x3D; upStreamVertexID;</span><br><span class="line">upStreamVertexID &#x3D; virtualSelectNodes.get(virtualId).f0;</span><br><span class="line">if (outputNames.isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F; selections that happen downstream override earlier selections</span><br><span class="line">outputNames &#x3D; virtualSelectNodes.get(virtualId).f1;</span><br><span class="line">&#125;</span><br><span class="line">addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames, outputTag);</span><br><span class="line">&#x2F;&#x2F;如果是partition节点</span><br><span class="line">&#125; else if (virtualPartitionNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line">int virtualId &#x3D; upStreamVertexID;</span><br><span class="line">upStreamVertexID &#x3D; virtualPartitionNodes.get(virtualId).f0;</span><br><span class="line">if (partitioner &#x3D;&#x3D; null) &#123;</span><br><span class="line">partitioner &#x3D; virtualPartitionNodes.get(virtualId).f1;</span><br><span class="line">&#125;</span><br><span class="line">addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames, outputTag);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;正常的edge处理逻辑</span><br><span class="line">StreamNode upstreamNode &#x3D; getStreamNode(upStreamVertexID);</span><br><span class="line">StreamNode downstreamNode &#x3D; getStreamNode(downStreamVertexID);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; If no partitioner was specified and the parallelism of upstream and downstream</span><br><span class="line">&#x2F;&#x2F; operator matches use forward partitioning, use rebalance otherwise.</span><br><span class="line">if (partitioner &#x3D;&#x3D; null &amp;&amp; upstreamNode.getParallelism() &#x3D;&#x3D; downstreamNode.getParallelism()) &#123;</span><br><span class="line">partitioner &#x3D; new ForwardPartitioner&lt;Object&gt;();</span><br><span class="line">&#125; else if (partitioner &#x3D;&#x3D; null) &#123;</span><br><span class="line">partitioner &#x3D; new RebalancePartitioner&lt;Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (partitioner instanceof ForwardPartitioner) &#123;</span><br><span class="line">if (upstreamNode.getParallelism() !&#x3D; downstreamNode.getParallelism()) &#123;</span><br><span class="line">throw new UnsupportedOperationException(&quot;Forward partitioning does not allow &quot; +</span><br><span class="line">&quot;change of parallelism. Upstream operation: &quot; + upstreamNode + &quot; parallelism: &quot; + upstreamNode.getParallelism() +</span><br><span class="line">&quot;, downstream operation: &quot; + downstreamNode + &quot; parallelism: &quot; + downstreamNode.getParallelism() +</span><br><span class="line">&quot; You must use another partitioning strategy, such as broadcast, rebalance, shuffle or global.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StreamEdge edge &#x3D; new StreamEdge(upstreamNode, downstreamNode, typeNumber, outputNames, partitioner, outputTag);</span><br><span class="line"></span><br><span class="line">getStreamNode(edge.getSourceId()).addOutEdge(edge);</span><br><span class="line">getStreamNode(edge.getTargetId()).addInEdge(edge);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-WordCount函数的StreamGraph"><a href="#2-2-3-WordCount函数的StreamGraph" class="headerlink" title="2.2.3 WordCount函数的StreamGraph"></a>2.2.3 WordCount函数的StreamGraph</h4><p>flink提供了一个StreamGraph可视化显示工具，<a href="http://flink.apache.org/visualizer/">在这里</a><br>我们可以把我们的程序的执行计划打印出来<code>System.out.println(env.getExecutionPlan());</code> 复制到这个网站上，点击生成，如图所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/sfckex3xgu33m3srk2bc5hgk/image_1cafgsliu1n2n1uj21p971b0h6m71t.png" alt="image_1cafgsliu1n2n1uj21p971b0h6m71t.png-25.7kB"><br>可以看到，我们源程序被转化成了4个operator。<br>另外，在operator之间的连线上也显示出了flink添加的一些逻辑流程。由于我设定了每个操作符的并行度都是1，所以在每个操作符之间都是直接FORWARD，不存在shuffle的过程。</p><h3 id="2-3-JobGraph的生成"><a href="#2-3-JobGraph的生成" class="headerlink" title="2.3 JobGraph的生成"></a>2.3 JobGraph的生成</h3><p>flink会根据上一步生成的StreamGraph生成JobGraph，然后将JobGraph发送到server端进行ExecutionGraph的解析。</p><h4 id="2-3-1-JobGraph生成源码"><a href="#2-3-1-JobGraph生成源码" class="headerlink" title="2.3.1 JobGraph生成源码"></a>2.3.1 JobGraph生成源码</h4><p>与StreamGraph类似，JobGraph的入口方法是<code>StreamingJobGraphGenerator.createJobGraph()</code>。我们直接来看源码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private JobGraph createJobGraph() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置启动模式为所有节点均在一开始就启动</span><br><span class="line">jobGraph.setScheduleMode(ScheduleMode.EAGER);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为每个节点生成hash id</span><br><span class="line">Map&lt;Integer, byte[]&gt; hashes &#x3D; defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 为了保持兼容性创建的hash</span><br><span class="line">List&lt;Map&lt;Integer, byte[]&gt;&gt; legacyHashes &#x3D; new ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">for (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, List&lt;Tuple2&lt;byte[], byte[]&gt;&gt;&gt; chainedOperatorHashes &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F;生成jobvertex，串成chain等</span><br><span class="line">        &#x2F;&#x2F;这里的逻辑大致可以理解为，挨个遍历节点，如果该节点是一个chain的头节点，就生成一个JobVertex，如果不是头节点，就要把自身配置并入头节点，然后把头节点和自己的出边相连；对于不能chain的节点，当作只有头节点处理即可</span><br><span class="line">setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line">        &#x2F;&#x2F;设置输入边edge</span><br><span class="line">setPhysicalEdges();</span><br><span class="line">        &#x2F;&#x2F;设置slot共享group</span><br><span class="line">setSlotSharing();</span><br><span class="line">        &#x2F;&#x2F;配置检查点</span><br><span class="line">configureCheckpointing();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果有之前的缓存文件的配置的话，重新读入</span><br><span class="line">for (Tuple2&lt;String, DistributedCache.DistributedCacheEntry&gt; e : streamGraph.getEnvironment().getCachedFiles()) &#123;</span><br><span class="line">DistributedCache.writeFileInfoToConfig(e.f0, e.f1, jobGraph.getJobConfiguration());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传递执行环境配置</span><br><span class="line">try &#123;</span><br><span class="line">jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line">throw new IllegalConfigurationException(&quot;Could not serialize the ExecutionConfig.&quot; +</span><br><span class="line">&quot;This indicates that non-serializable types (like custom serializers) were registered&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-operator-chain的逻辑"><a href="#2-3-2-operator-chain的逻辑" class="headerlink" title="2.3.2 operator chain的逻辑"></a>2.3.2 operator chain的逻辑</h4><blockquote><p>为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。每个task在一个线程中执行。将operators链接成task是非常有效的优化：它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/jcjalvv130ex52vkglkt56r2/image_1cafj7s6bittk5tt0bequlig2a.png" alt="image_1cafj7s6bittk5tt0bequlig2a.png-158.7kB"><br>上图中将KeyAggregation和Sink两个operator进行了合并，因为这两个合并后并不会改变整体的拓扑结构。但是，并不是任意两个 operator 就能 chain 一起的,其条件还是很苛刻的：</p><blockquote><ul><li>上下游的并行度一致</li><li>下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）</li><li>上下游节点都在同一个 slot group 中（下面会解释 slot group）</li><li>下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）</li><li>上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）</li><li>两个节点间数据分区方式是 forward（参考理解数据流的分区）</li><li>用户没有禁用 chain</li></ul></blockquote><p>flink的chain逻辑是一种很常见的设计，比如spring的interceptor也是类似的实现方式。通过把操作符串成一个大操作符，flink避免了把数据序列化后通过网络发送给其他节点的开销，能够大大增强效率。</p><h4 id="2-3-3-JobGraph的提交"><a href="#2-3-3-JobGraph的提交" class="headerlink" title="2.3.3 JobGraph的提交"></a>2.3.3 JobGraph的提交</h4><p>前面已经提到，JobGraph的提交依赖于JobClient和JobManager之间的异步通信，如图所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/dj015uuqpnb4ct7810qfilhe/image_1cafn516r1p68kt31g7r196rcsv2n.png" alt="image_1cafn516r1p68kt31g7r196rcsv2n.png-40.1kB"><br>在submitJobAndWait方法中，其首先会创建一个JobClientActor的ActorRef,然后向其发起一个SubmitJobAndWait消息，该消息将JobGraph的实例提交给JobClientActor。发起模式是ask，它表示需要一个应答消息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future &#x3D; Patterns.ask(jobClientActor, new JobClientMessages.SubmitJobAndWait(jobGraph), new Timeout(AkkaUtils.INF_TIMEOUT()));</span><br><span class="line">answer &#x3D; Await.result(future, AkkaUtils.INF_TIMEOUT());</span><br></pre></td></tr></table></figure><p>该SubmitJobAndWait消息被JobClientActor接收后，最终通过调用tryToSubmitJob方法触发真正的提交动作。当JobManager的actor接收到来自client端的请求后，会执行一个submitJob方法，主要做以下事情：</p><blockquote><ul><li>向BlobLibraryCacheManager注册该Job；</li><li>构建ExecutionGraph对象；</li><li>对JobGraph中的每个顶点进行初始化；</li><li>将DAG拓扑中从source开始排序，排序后的顶点集合附加到Exec&gt; - utionGraph对象；</li><li>获取检查点相关的配置，并将其设置到ExecutionGraph对象；</li><li>向ExecutionGraph注册相关的listener；</li><li>执行恢复操作或者将JobGraph信息写入SubmittedJobGraphStore以在后续用于恢复目的；</li><li>响应给客户端JobSubmitSuccess消息；</li><li>对ExecutionGraph对象进行调度执行；</li></ul></blockquote><p>最后，JobManger会返回消息给JobClient，通知该任务是否提交成功。</p><h3 id="2-4-ExecutionGraph的生成"><a href="#2-4-ExecutionGraph的生成" class="headerlink" title="2.4 ExecutionGraph的生成"></a>2.4 ExecutionGraph的生成</h3><p>与StreamGraph和JobGraph不同，ExecutionGraph并不是在我们的客户端程序生成，而是在服务端（JobManager处）生成的，顺便flink只维护一个JobManager。其入口代码是<code>ExecutionGraphBuilder.buildGraph（...）</code><br>该方法长200多行，其中一大半是checkpoiont的相关逻辑，我们暂且略过，直接看核心方法<code>executionGraph.attachJobGraph(sortedTopology)</code><br>因为ExecutionGraph事实上只是改动了JobGraph的每个节点，而没有对整个拓扑结构进行变动，所以代码里只是挨个遍历jobVertex并进行处理：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (JobVertex jobVertex : topologiallySorted) &#123;</span><br><span class="line"></span><br><span class="line">if (jobVertex.isInputVertex() &amp;&amp; !jobVertex.isStoppable()) &#123;</span><br><span class="line">this.isStoppable &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在这里生成ExecutionGraph的每个节点</span><br><span class="line">&#x2F;&#x2F;首先是进行了一堆赋值，将任务信息交给要生成的图节点，以及设定并行度等等</span><br><span class="line">&#x2F;&#x2F;然后是创建本节点的IntermediateResult，根据本节点的下游节点的个数确定创建几份</span><br><span class="line">&#x2F;&#x2F;最后是根据设定好的并行度创建用于执行task的ExecutionVertex</span><br><span class="line">&#x2F;&#x2F;如果job有设定inputsplit的话，这里还要指定inputsplits</span><br><span class="line">ExecutionJobVertex ejv &#x3D; new ExecutionJobVertex(</span><br><span class="line">this,</span><br><span class="line">jobVertex,</span><br><span class="line">1,</span><br><span class="line">rpcCallTimeout,</span><br><span class="line">globalModVersion,</span><br><span class="line">createTimestamp);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;这里要处理所有的JobEdge</span><br><span class="line">            &#x2F;&#x2F;对每个edge，获取对应的intermediateResult，并记录到本节点的输入上</span><br><span class="line">            &#x2F;&#x2F;最后，把每个ExecutorVertex和对应的IntermediateResult关联起来</span><br><span class="line">ejv.connectToPredecessors(this.intermediateResults);</span><br><span class="line"></span><br><span class="line">ExecutionJobVertex previousTask &#x3D; this.tasks.putIfAbsent(jobVertex.getID(), ejv);</span><br><span class="line">if (previousTask !&#x3D; null) &#123;</span><br><span class="line">throw new JobException(String.format(&quot;Encountered two job vertices with ID %s : previous&#x3D;[%s] &#x2F; new&#x3D;[%s]&quot;,</span><br><span class="line">jobVertex.getID(), ejv, previousTask));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (IntermediateResult res : ejv.getProducedDataSets()) &#123;</span><br><span class="line">IntermediateResult previousDataSet &#x3D; this.intermediateResults.putIfAbsent(res.getId(), res);</span><br><span class="line">if (previousDataSet !&#x3D; null) &#123;</span><br><span class="line">throw new JobException(String.format(&quot;Encountered two intermediate data set with ID %s : previous&#x3D;[%s] &#x2F; new&#x3D;[%s]&quot;,</span><br><span class="line">res.getId(), res, previousDataSet));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.verticesInCreationOrder.add(ejv);</span><br><span class="line">this.numVerticesTotal +&#x3D; ejv.getParallelism();</span><br><span class="line">newExecJobVertices.add(ejv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，ExecutorGraph就创建完成了。</p><h2 id="3-任务的调度与执行"><a href="#3-任务的调度与执行" class="headerlink" title="3. 任务的调度与执行"></a>3. 任务的调度与执行</h2><p>关于flink的任务执行架构，官网的这两张图就是最好的说明：</p><p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/qiv2wip1rok62ljo0tef3qf0/image_1cafnu1pl1d8c15m219b8vkb2334.png" alt="image_1cafnu1pl1d8c15m219b8vkb2334.png-112.9kB"><br>Flink 集群启动后，首先会启动一个 JobManger 和多个的 TaskManager。用户的代码会由JobClient 提交给 JobManager，JobManager 再把来自不同用户的任务发给 不同的TaskManager 去执行，每个TaskManager管理着多个task，task是执行计算的最小结构， TaskManager 将心跳和统计信息汇报给 JobManager。TaskManager 之间以流的形式进行数据的传输。上述除了task外的三者均为独立的 JVM 进程。<br>要注意的是，TaskManager和job并非一一对应的关系。flink调度的最小单元是task而非TaskManager，也就是说，来自不同job的不同task可能运行于同一个TaskManager的不同线程上。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/b7cmjn41b1zp5sco34kgvusn/image_1cclle7ui2j41nf611gs1is18m19.png" alt="image_1cclle7ui2j41nf611gs1is18m19.png-127.5kB"><br>一个flink任务所有可能的状态如上图所示。图上画的很明白，就不再赘述了。</p><h3 id="3-1-计算资源的调度"><a href="#3-1-计算资源的调度" class="headerlink" title="3.1 计算资源的调度"></a>3.1 计算资源的调度</h3><p>Task slot是一个TaskManager内资源分配的最小载体，代表了一个固定大小的资源子集，每个TaskManager会将其所占有的资源平分给它的slot。<br>通过调整 task slot 的数量，用户可以定义task之间是如何相互隔离的。每个 TaskManager 有一个slot，也就意味着每个task运行在独立的 JVM 中。每个 TaskManager 有多个slot的话，也就是说多个task运行在同一个JVM中。<br>而在同一个JVM进程中的task，可以共享TCP连接（基于多路复用）和心跳消息，可以减少数据的网络传输，也能共享一些数据结构，一定程度上减少了每个task的消耗。<br>每个slot可以接受单个task，也可以接受多个连续task组成的pipeline，如下图所示，FlatMap函数占用一个taskslot，而key Agg函数和sink函数共用一个taskslot：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/6ypu9v09z0mit936uk0mcddi/image_1cafpf21c1jh3s5ap1fisu4v23h.png" alt="image_1cafpf21c1jh3s5ap1fisu4v23h.png-44.7kB"><br>为了达到共用slot的目的，除了可以以chain的方式pipeline算子，我们还可以允许SlotSharingGroup，如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/tgamd7vw9qcdttvihlmvhie9/image_1cafpko68b3r1lk0dpsnmbj3c3u.png" alt="image_1cafpko68b3r1lk0dpsnmbj3c3u.png-61.2kB"><br>我们可以把不能被chain成一条的两个操作如flatmap和key&amp;sink放在一个TaskSlot里执行，这样做可以获得以下好处：</p><ul><li>共用slot使得我们不再需要计算每个任务需要的总task数目，直接取最高算子的并行度即可</li><li>对计算资源的利用率更高。例如，通常的轻量级操作map和重量级操作Aggregate不再分别需要一个线程，而是可以在同一个线程内执行，而且对于slot有限的场景，我们可以增大每个task的并行度了。<br>接下来我们还是用官网的图来说明flink是如何重用slot的：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/l0n9ny2y198x0daucmyo0zb4/image_1cafqroarkjkuje1hfi18gor654b.png" alt="image_1cafqroarkjkuje1hfi18gor654b.png-137kB"></li></ul><ol><li>TaskManager1分配一个SharedSlot0</li><li>把source task放入一个SimpleSlot0，再把该slot放入SharedSlot0</li><li>把flatmap task放入一个SimpleSlot1，再把该slot放入SharedSlot0</li><li>因为我们的flatmap task并行度是2，因此不能再放入SharedSlot0，所以向TaskMange21申请了一个新的SharedSlot0</li><li>把第二个flatmap task放进一个新的SimpleSlot，并放进TaskManager2的SharedSlot0</li><li>开始处理key&amp;sink task，因为其并行度也是2，所以先把第一个task放进TaskManager1的SharedSlot</li><li>把第二个key&amp;sink放进TaskManager2的SharedSlot</li></ol><h3 id="3-2-JobManager执行job"><a href="#3-2-JobManager执行job" class="headerlink" title="3.2 JobManager执行job"></a>3.2 JobManager执行job</h3><p>JobManager负责接收 flink 的作业，调度 task，收集 job 的状态、管理 TaskManagers。被实现为一个 akka actor。</p><h4 id="3-2-1-JobManager的组件"><a href="#3-2-1-JobManager的组件" class="headerlink" title="3.2.1 JobManager的组件"></a>3.2.1 JobManager的组件</h4><ul><li>BlobServer 是一个用来管理二进制大文件的服务，比如保存用户上传的jar文件，该服务会将其写到磁盘上。还有一些相关的类，如BlobCache，用于TaskManager向JobManager下载用户的jar文件</li><li>InstanceManager 用来管理当前存活的TaskManager的组件，记录了TaskManager的心跳信息等</li><li>CompletedCheckpointStore 用于保存已完成的checkpoint相关信息，持久化到内存中或者zookeeper上</li><li>MemoryArchivist 保存了已经提交到flink的作业的相关信息，如JobGraph等</li></ul><h4 id="3-2-2-JobManager的启动过程"><a href="#3-2-2-JobManager的启动过程" class="headerlink" title="3.2.2 JobManager的启动过程"></a>3.2.2 JobManager的启动过程</h4><p>先列出JobManager启动的核心代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def runJobManager(</span><br><span class="line">      configuration: Configuration,</span><br><span class="line">      executionMode: JobManagerMode,</span><br><span class="line">      listeningAddress: String,</span><br><span class="line">      listeningPort: Int)</span><br><span class="line">    : Unit &#x3D; &#123;</span><br><span class="line"></span><br><span class="line">    val numberProcessors &#x3D; Hardware.getNumberCPUCores()</span><br><span class="line"></span><br><span class="line">    val futureExecutor &#x3D; Executors.newScheduledThreadPool(</span><br><span class="line">      numberProcessors,</span><br><span class="line">      new ExecutorThreadFactory(&quot;jobmanager-future&quot;))</span><br><span class="line"></span><br><span class="line">    val ioExecutor &#x3D; Executors.newFixedThreadPool(</span><br><span class="line">      numberProcessors,</span><br><span class="line">      new ExecutorThreadFactory(&quot;jobmanager-io&quot;))</span><br><span class="line"></span><br><span class="line">    val timeout &#x3D; AkkaUtils.getTimeout(configuration)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; we have to first start the JobManager ActorSystem because this determines the port if 0</span><br><span class="line">    &#x2F;&#x2F; was chosen before. The method startActorSystem will update the configuration correspondingly.</span><br><span class="line">    val jobManagerSystem &#x3D; startActorSystem(</span><br><span class="line">      configuration,</span><br><span class="line">      listeningAddress,</span><br><span class="line">      listeningPort)</span><br><span class="line"></span><br><span class="line">    val highAvailabilityServices &#x3D; HighAvailabilityServicesUtils.createHighAvailabilityServices(</span><br><span class="line">      configuration,</span><br><span class="line">      ioExecutor,</span><br><span class="line">      AddressResolution.NO_ADDRESS_RESOLUTION)</span><br><span class="line"></span><br><span class="line">    val metricRegistry &#x3D; new MetricRegistryImpl(</span><br><span class="line">      MetricRegistryConfiguration.fromConfiguration(configuration))</span><br><span class="line"></span><br><span class="line">    metricRegistry.startQueryService(jobManagerSystem, null)</span><br><span class="line"></span><br><span class="line">    val (_, _, webMonitorOption, _) &#x3D; try &#123;</span><br><span class="line">      startJobManagerActors(</span><br><span class="line">        jobManagerSystem,</span><br><span class="line">        configuration,</span><br><span class="line">        executionMode,</span><br><span class="line">        listeningAddress,</span><br><span class="line">        futureExecutor,</span><br><span class="line">        ioExecutor,</span><br><span class="line">        highAvailabilityServices,</span><br><span class="line">        metricRegistry,</span><br><span class="line">        classOf[JobManager],</span><br><span class="line">        classOf[MemoryArchivist],</span><br><span class="line">        Option(classOf[StandaloneResourceManager])</span><br><span class="line">      )</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case t: Throwable &#x3D;&gt;</span><br><span class="line">        futureExecutor.shutdownNow()</span><br><span class="line">        ioExecutor.shutdownNow()</span><br><span class="line"></span><br><span class="line">        throw t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; block until everything is shut down</span><br><span class="line">    jobManagerSystem.awaitTermination()</span><br><span class="line">    </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置Akka并生成ActorSystem，启动JobManager</li><li>启动HA和metric相关服务</li><li>在<code>startJobManagerActors()</code>方法中启动JobManagerActors，以及webserver，TaskManagerActor，ResourceManager等等</li><li>阻塞等待终止</li><li>集群通过LeaderService等选出JobManager的leader</li></ul><h4 id="3-2-3-JobManager启动Task"><a href="#3-2-3-JobManager启动Task" class="headerlink" title="3.2.3 JobManager启动Task"></a>3.2.3 JobManager启动Task</h4><p>JobManager 是一个Actor，通过各种消息来完成核心逻辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override def handleMessage: Receive &#x3D; &#123;</span><br><span class="line">  case GrantLeadership(newLeaderSessionID) &#x3D;&gt;</span><br><span class="line">    log.info(s&quot;JobManager $getAddress was granted leadership with leader session ID &quot; +</span><br><span class="line">      s&quot;$newLeaderSessionID.&quot;)</span><br><span class="line">    leaderSessionID &#x3D; newLeaderSessionID</span><br><span class="line">    </span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><p>有几个比较重要的消息：</p><ul><li>GrantLeadership 获得leader授权，将自身被分发到的 session id 写到 zookeeper，并恢复所有的 jobs</li><li>RevokeLeadership 剥夺leader授权，打断清空所有的 job 信息，但是保留作业缓存，注销所有的 TaskManagers</li><li>RegisterTaskManagers 注册 TaskManager，如果之前已经注册过，则只给对应的 Instance 发送消息，否则启动注册逻辑：在 InstanceManager 中注册该 Instance 的信息，并停止 Instance BlobLibraryCacheManager 的端口【供下载 lib 包用】，同时使用 watch 监听 task manager 的存活</li><li>SubmitJob 提交 jobGraph<br>最后一项SubmintJob就是我们要关注的，从客户端收到JobGraph，转换为ExecutionGraph并执行的过程。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private def submitJob(jobGraph: JobGraph, jobInfo: JobInfo, isRecovery: Boolean &#x3D; false): Unit &#x3D; &#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    executionGraph &#x3D; ExecutionGraphBuilder.buildGraph(</span><br><span class="line">          executionGraph,</span><br><span class="line">          jobGraph,</span><br><span class="line">          flinkConfiguration,</span><br><span class="line">          futureExecutor,</span><br><span class="line">          ioExecutor,</span><br><span class="line">          scheduler,</span><br><span class="line">          userCodeLoader,</span><br><span class="line">          checkpointRecoveryFactory,</span><br><span class="line">          Time.of(timeout.length, timeout.unit),</span><br><span class="line">          restartStrategy,</span><br><span class="line">          jobMetrics,</span><br><span class="line">          numSlots,</span><br><span class="line">          blobServer,</span><br><span class="line">          log.logger)</span><br><span class="line">          </span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    if (leaderElectionService.hasLeadership) &#123;</span><br><span class="line">            log.info(s&quot;Scheduling job $jobId ($jobName).&quot;)</span><br><span class="line">            </span><br><span class="line">            executionGraph.scheduleForExecution()</span><br><span class="line">            </span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            self ! decorateMessage(RemoveJob(jobId, removeJobFromStateBackend &#x3D; false))</span><br><span class="line"></span><br><span class="line">            log.warn(s&quot;Submitted job $jobId, but not leader. The other leader needs to recover &quot; +</span><br><span class="line">              &quot;this. I am not scheduling the job for execution.&quot;)</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>首先做一些准备工作，然后获取一个ExecutionGraph，判断是否是恢复的job，然后将job保存下来，并且通知客户端本地已经提交成功了，最后如果确认本JobManager是leader，则执行<code>executionGraph.scheduleForExecution()</code>方法，这个方法经过一系列调用，把每个ExecutionVertex传递给了Excution类的deploy方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void deploy() throws JobException &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; good, we are allowed to deploy</span><br><span class="line">if (!slot.setExecutedVertex(this)) &#123;</span><br><span class="line">throw new JobException(&quot;Could not assign the ExecutionVertex to the slot &quot; + slot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; race double check, did we fail&#x2F;cancel and do we need to release the slot?</span><br><span class="line">if (this.state !&#x3D; DEPLOYING) &#123;</span><br><span class="line">slot.releaseSlot();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (LOG.isInfoEnabled()) &#123;</span><br><span class="line">LOG.info(String.format(&quot;Deploying %s (attempt #%d) to %s&quot;, vertex.getTaskNameWithSubtaskIndex(),</span><br><span class="line">attemptNumber, getAssignedResourceLocation().getHostname()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final TaskDeploymentDescriptor deployment &#x3D; vertex.createDeploymentDescriptor(</span><br><span class="line">attemptId,</span><br><span class="line">slot,</span><br><span class="line">taskState,</span><br><span class="line">attemptNumber);</span><br><span class="line"></span><br><span class="line">final TaskManagerGateway taskManagerGateway &#x3D; slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">final CompletableFuture&lt;Acknowledge&gt; submitResultFuture &#x3D; taskManagerGateway.submitTask(deployment, timeout);</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable t) &#123;</span><br><span class="line">markFailed(t);</span><br><span class="line">ExceptionUtils.rethrow(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们首先生成了一个TaskDeploymentDescriptor，然后交给了<code>taskManagerGateway.submitTask()</code>方法执行。接下来的部分，就属于TaskManager的范畴了。<h3 id="3-3-TaskManager执行task"><a href="#3-3-TaskManager执行task" class="headerlink" title="3.3 TaskManager执行task"></a>3.3 TaskManager执行task</h3><h4 id="3-3-1-TaskManager的基本组件"><a href="#3-3-1-TaskManager的基本组件" class="headerlink" title="3.3.1 TaskManager的基本组件"></a>3.3.1 TaskManager的基本组件</h4>TaskManager是flink中资源管理的基本组件，是所有执行任务的基本容器，提供了内存管理、IO管理、通信管理等一系列功能，本节对各个模块进行简要介绍。</li></ul><ol><li>MemoryManager flink并没有把所有内存的管理都委托给JVM，因为JVM普遍存在着存储对象密度低、大内存时GC对系统影响大等问题。所以flink自己抽象了一套内存管理机制，将所有对象序列化后放在自己的MemorySegment上进行管理。MemoryManger涉及内容较多，将在后续章节进行继续剖析。</li><li>IOManager flink通过IOManager管理磁盘IO的过程，提供了同步和异步两种写模式，又进一步区分了block、buffer和bulk三种读写方式。<br>IOManager提供了两种方式枚举磁盘文件，一种是直接遍历文件夹下所有文件，另一种是计数器方式，对每个文件名以递增顺序访问。<br>在底层，flink将文件IO抽象为FileIOChannle，封装了底层实现。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/d3j6qnbjywjzknu6pb3pou6i/image_1cag7idg4vfj1l871n0l1k0e1f7u4o.png" alt="image_1cag7idg4vfj1l871n0l1k0e1f7u4o.png-194.1kB"><br>可以看到，flink在底层实际上都是以异步的方式进行读写。</li><li>NetworkEnvironment 是TaskManager的网络 IO 组件，包含了追踪中间结果和数据交换的数据结构。它的构造器会统一将配置的内存先分配出来，抽象成 NetworkBufferPool 统一管理内存的申请和释放。意思是说，在输入和输出数据时，不管是保留在本地内存，等待chain在一起的下个操作符进行处理，还是通过网络把本操作符的计算结果发送出去，都被抽象成了NetworkBufferPool。后续我们还将对这个组件进行详细分析。</li></ol><h4 id="3-3-2-TaskManager执行Task"><a href="#3-3-2-TaskManager执行Task" class="headerlink" title="3.3.2 TaskManager执行Task"></a>3.3.2 TaskManager执行Task</h4><p>对于TM来说，执行task就是把收到的<code>TaskDeploymentDescriptor</code>对象转换成一个task并执行的过程。TaskDeploymentDescriptor这个类保存了task执行所必须的所有内容，例如序列化的算子，输入的InputGate和输出的ResultPartition的定义，该task要作为几个subtask执行等等。<br>按照正常逻辑思维，很容易想到TM的submitTask方法的行为：首先是确认资源，如寻找JobManager和Blob，而后建立连接，解序列化算子，收集task相关信息，接下来就是创建一个新的<code>Task</code>对象，这个task对象就是真正执行任务的关键所在。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val task &#x3D; new Task(</span><br><span class="line">        jobInformation,</span><br><span class="line">        taskInformation,</span><br><span class="line">        tdd.getExecutionAttemptId,</span><br><span class="line">        tdd.getAllocationId,</span><br><span class="line">        tdd.getSubtaskIndex,</span><br><span class="line">        tdd.getAttemptNumber,</span><br><span class="line">        tdd.getProducedPartitions,</span><br><span class="line">        tdd.getInputGates,</span><br><span class="line">        tdd.getTargetSlotNumber,</span><br><span class="line">        tdd.getTaskStateHandles,</span><br><span class="line">        memoryManager,</span><br><span class="line">        ioManager,</span><br><span class="line">        network,</span><br><span class="line">        bcVarManager,</span><br><span class="line">        taskManagerConnection,</span><br><span class="line">        inputSplitProvider,</span><br><span class="line">        checkpointResponder,</span><br><span class="line">        blobCache,</span><br><span class="line">        libCache,</span><br><span class="line">        fileCache,</span><br><span class="line">        config,</span><br><span class="line">        taskMetricGroup,</span><br><span class="line">        resultPartitionConsumableNotifier,</span><br><span class="line">        partitionStateChecker,</span><br><span class="line">        context.dispatcher)</span><br></pre></td></tr></table></figure><p>如果读者是从头开始看这篇blog，里面有很多对象应该已经比较明确其作用了（除了那个brVarManager，这个是管理广播变量的，广播变量是一类会被分发到每个任务中的共享变量）。接下来的主要任务，就是把这个task启动起来,然后报告说已经启动task了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; all good, we kick off the task, which performs its own initialization</span><br><span class="line">task.startTaskThread()</span><br><span class="line"></span><br><span class="line">sender ! decorateMessage(Acknowledge.get())</span><br></pre></td></tr></table></figure><h4 id="3-3-2-1-生成Task对象"><a href="#3-3-2-1-生成Task对象" class="headerlink" title="3.3.2.1 生成Task对象"></a>3.3.2.1 生成Task对象</h4><p>在执行new Task()方法时，第一步是把构造函数里的这些变量赋值给当前task的fields。<br>接下来是初始化ResultPartition和InputGate。这两个类描述了task的输出数据和输入数据。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (ResultPartitionDeploymentDescriptor desc: resultPartitionDeploymentDescriptors) &#123;</span><br><span class="line">ResultPartitionID partitionId &#x3D; new ResultPartitionID(desc.getPartitionId(), executionId);</span><br><span class="line"></span><br><span class="line">this.producedPartitions[counter] &#x3D; new ResultPartition(</span><br><span class="line">    taskNameWithSubtaskAndId,</span><br><span class="line">this,</span><br><span class="line">jobId,</span><br><span class="line">partitionId,</span><br><span class="line">desc.getPartitionType(),</span><br><span class="line">desc.getNumberOfSubpartitions(),</span><br><span class="line">desc.getMaxParallelism(),</span><br><span class="line">networkEnvironment.getResultPartitionManager(),</span><br><span class="line">resultPartitionConsumableNotifier,</span><br><span class="line">ioManager,</span><br><span class="line">desc.sendScheduleOrUpdateConsumersMessage());</span><br><span class="line">&#x2F;&#x2F;为每个partition初始化对应的writer </span><br><span class="line">writers[counter] &#x3D; new ResultPartitionWriter(producedPartitions[counter]);</span><br><span class="line"></span><br><span class="line">++counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Consumed intermediate result partitions</span><br><span class="line">this.inputGates &#x3D; new SingleInputGate[inputGateDeploymentDescriptors.size()];</span><br><span class="line">this.inputGatesById &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for (InputGateDeploymentDescriptor inputGateDeploymentDescriptor: inputGateDeploymentDescriptors) &#123;</span><br><span class="line">SingleInputGate gate &#x3D; SingleInputGate.create(</span><br><span class="line">taskNameWithSubtaskAndId,</span><br><span class="line">jobId,</span><br><span class="line">executionId,</span><br><span class="line">inputGateDeploymentDescriptor,</span><br><span class="line">networkEnvironment,</span><br><span class="line">this,</span><br><span class="line">metricGroup.getIOMetricGroup());</span><br><span class="line"></span><br><span class="line">inputGates[counter] &#x3D; gate;</span><br><span class="line">inputGatesById.put(gate.getConsumedResultId(), gate);</span><br><span class="line"></span><br><span class="line">++counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，创建一个Thread对象，并把自己放进该对象，这样在执行时，自己就有了自身的线程的引用。</p><h4 id="3-3-2-2-运行Task对象"><a href="#3-3-2-2-运行Task对象" class="headerlink" title="3.3.2.2 运行Task对象"></a>3.3.2.2 运行Task对象</h4><p> Task对象本身就是一个Runable，因此在其run方法里定义了运行逻辑。<br> 第一步是切换Task的状态：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      while (true) &#123;</span><br><span class="line">ExecutionState current &#x3D; this.executionState;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;如果当前的执行状态为CREATED，则将其设置为DEPLOYING状态</span><br><span class="line">if (current &#x3D;&#x3D; ExecutionState.CREATED) &#123;</span><br><span class="line">if (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</span><br><span class="line">&#x2F;&#x2F; success, we can start our work</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果当前执行状态为FAILED，则发出通知并退出run方法</span><br><span class="line">else if (current &#x3D;&#x3D; ExecutionState.FAILED) &#123;</span><br><span class="line">&#x2F;&#x2F; we were immediately failed. tell the TaskManager that we reached our final state</span><br><span class="line">notifyFinalState();</span><br><span class="line">if (metrics !&#x3D; null) &#123;</span><br><span class="line">metrics.close();</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果当前执行状态为CANCELING，则将其修改为CANCELED状态，并退出run</span><br><span class="line">else if (current &#x3D;&#x3D; ExecutionState.CANCELING) &#123;</span><br><span class="line">if (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</span><br><span class="line">&#x2F;&#x2F; we were immediately canceled. tell the TaskManager that we reached our final state</span><br><span class="line">notifyFinalState();</span><br><span class="line">if (metrics !&#x3D; null) &#123;</span><br><span class="line">metrics.close();</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;否则说明发生了异常</span><br><span class="line">else &#123;</span><br><span class="line">if (metrics !&#x3D; null) &#123;</span><br><span class="line">metrics.close();</span><br><span class="line">&#125;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid state for beginning of operation of task &quot; + this + &#39;.&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里有个值得关注的点，就是flink里大量使用了这种while(true)的写法来修改和检测状态，emmm…<br>接下来，就是导入用户类加载器并加载用户代码。<br>然后，是向网络管理器注册当前任务（flink的各个算子在运行时进行数据交换需要依赖网络管理器），分配一些缓存以保存数据<br>然后，读入指定的缓存文件。<br>然后，再把task创建时传入的那一大堆变量用于创建一个执行环境Envrionment。<br>再然后，对于那些并不是第一次执行的task（比如失败后重启的）要恢复其状态。<br>接下来最重要的是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invokable.invoke();</span><br></pre></td></tr></table></figure><p>方法。为什么这么说呢，因为这个方法就是用户代码所真正被执行的入口。比如我们写的什么new MapFunction()的逻辑，最终就是在这里被执行的。这里说一下这个invokable，这是一个抽象类，提供了可以被TaskManager执行的对象的基本抽象。<br>这个invokable是在解析JobGraph的时候生成相关信息的，并在此处形成真正可执行的对象</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; now load the task&#39;s invokable code</span><br><span class="line">&#x2F;&#x2F;通过反射生成对象</span><br><span class="line">invokable &#x3D; loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/9bemw0us5cocnej8lq4x64rk/image_1cbkaa8r9182i18ct1kfu8g829m9.png" alt="image_1cbkaa8r9182i18ct1kfu8g829m9.png-29.9kB"><br>上图显示了flink提供的可被执行的Task类型。从名字上就可以看出各个task的作用，在此不再赘述。<br>接下来就是invoke方法了，因为我们的wordcount例子用了流式api，在此我们以StreamTask的invoke方法为例进行说明。</p><h4 id="3-3-2-3-StreamTask的执行逻辑"><a href="#3-3-2-3-StreamTask的执行逻辑" class="headerlink" title="3.3.2.3 StreamTask的执行逻辑"></a>3.3.2.3 StreamTask的执行逻辑</h4><p>先上部分核心代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void invoke() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">boolean disposed &#x3D; false;</span><br><span class="line">    try &#123;</span><br><span class="line">&#x2F;&#x2F; -------- Initialize ---------</span><br><span class="line">&#x2F;&#x2F;先做一些赋值操作</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if the clock is not already set, then assign a default TimeServiceProvider</span><br><span class="line">&#x2F;&#x2F;处理timer</span><br><span class="line">if (timerService &#x3D;&#x3D; null) &#123;</span><br><span class="line">ThreadFactory timerThreadFactory &#x3D;</span><br><span class="line">new DispatcherThreadFactory(TRIGGER_THREAD_GROUP, &quot;Time Trigger for &quot; + getName());</span><br><span class="line"></span><br><span class="line">timerService &#x3D; new SystemProcessingTimeService(this, getCheckpointLock(), timerThreadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;把之前JobGraph串起来的chain的信息形成实现</span><br><span class="line">operatorChain &#x3D; new OperatorChain&lt;&gt;(this);</span><br><span class="line">headOperator &#x3D; operatorChain.getHeadOperator();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; task specific initialization</span><br><span class="line">&#x2F;&#x2F;这个init操作的起名非常诡异，因为这里主要是处理算子采用了自定义的checkpoint检查机制的情况，但是起了一个非常大众脸的名字</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; save the work of reloading state, etc, if the task is already canceled</span><br><span class="line">if (canceled) &#123;</span><br><span class="line">throw new CancelTaskException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -------- Invoke --------</span><br><span class="line">LOG.debug(&quot;Invoking &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; we need to make sure that any triggers scheduled in open() cannot be</span><br><span class="line">&#x2F;&#x2F; executed before all operators are opened</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; both the following operations are protected by the lock</span><br><span class="line">&#x2F;&#x2F; so that we avoid race conditions in the case that initializeState()</span><br><span class="line">&#x2F;&#x2F; registers a timer, that fires before the open() is called.</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化操作符状态，主要是一些state啥的</span><br><span class="line">initializeState();</span><br><span class="line">&#x2F;&#x2F;对于富操作符，执行其open操作</span><br><span class="line">openAllOperators();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; final check to exit early before starting to run</span><br><span class="line">f (canceled) &#123;</span><br><span class="line">    throw new CancelTaskException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; let the task do its work</span><br><span class="line">&#x2F;&#x2F;真正开始执行的代码</span><br><span class="line">isRunning &#x3D; true;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure><p>StreamTask.invoke()方法里，第一个值得一说的是<code>TimerService</code>。Flink在2015年决定向StreamTask类加入timer service的时候解释到：</p><blockquote><p>This integrates the timer as a service in StreamTask that StreamOperators can use by calling a method on the StreamingRuntimeContext. This also ensures that the timer callbacks can not be called concurrently with other methods on the StreamOperator. This behaviour is ensured by an ITCase.</p></blockquote><p>第二个要注意的是chain操作。前面提到了，flink会出于优化的角度，把一些算子chain成一个整体的算子作为一个task来执行。比如wordcount例子中，Source和FlatMap算子就被chain在了一起。在进行chain操作的时候，会设定头节点，并且指定输出的RecordWriter。</p><p>接下来不出所料仍然是初始化，只不过初始化的对象变成了各个operator。如果是有checkpoint的，那就从state信息里恢复，不然就作为全新的算子处理。从源码中可以看到，flink针对keyed算子和普通算子做了不同的处理。keyed算子在初始化时需要计算出一个group区间，这个区间的值在整个生命周期里都不会再变化，后面key就会根据hash的不同结果，分配到特定的group中去计算。顺便提一句，flink的keyed算子保存的是对每个数据的key的计算方法，而非真实的key，用户需要自己保证对每一行数据提供的keySelector的幂等性。至于为什么要用KeyGroup的设计，这就牵扯到扩容的范畴了，将在后面的章节进行讲述。<br>对于<code>openAllOperators()</code>方法，就是对各种RichOperator执行其open方法，通常可用于在执行计算之前加载资源。<br>最后，run方法千呼万唤始出来，该方法经过一系列跳转，最终调用chain上的第一个算子的run方法。在wordcount的例子中，它最终调用了SocketTextStreamFunction的run，建立socket连接并读入文本。</p><h3 id="3-4-StreamTask与StreamOperator"><a href="#3-4-StreamTask与StreamOperator" class="headerlink" title="3.4 StreamTask与StreamOperator"></a>3.4 StreamTask与StreamOperator</h3><p>前面提到，Task对象在执行过程中，把执行的任务交给了StreamTask这个类去执行。在我们的wordcount例子中，实际初始化的是OneInputStreamTask的对象（参考上面的类图）。那么这个对象是如何执行用户的代码的呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void run() throws Exception &#123;</span><br><span class="line">&#x2F;&#x2F; cache processor reference on the stack, to make the code more JIT friendly</span><br><span class="line">final StreamInputProcessor&lt;IN&gt; inputProcessor &#x3D; this.inputProcessor;</span><br><span class="line"></span><br><span class="line">while (running &amp;&amp; inputProcessor.processInput()) &#123;</span><br><span class="line">&#x2F;&#x2F; all the work happens in the &quot;processInput&quot; method</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它做的，就是把任务直接交给了InputProcessor去执行processInput方法。这是一个<code>StreamInputProcessor</code>的实例，该processor的任务就是处理输入的数据，包括用户数据、watermark和checkpoint数据等。我们先来看看这个processor是如何产生的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void init() throws Exception &#123;</span><br><span class="line">StreamConfig configuration &#x3D; getConfiguration();</span><br><span class="line"></span><br><span class="line">TypeSerializer&lt;IN&gt; inSerializer &#x3D; configuration.getTypeSerializerIn1(getUserCodeClassLoader());</span><br><span class="line">int numberOfInputs &#x3D; configuration.getNumberOfInputs();</span><br><span class="line"></span><br><span class="line">if (numberOfInputs &gt; 0) &#123;</span><br><span class="line">InputGate[] inputGates &#x3D; getEnvironment().getAllInputGates();</span><br><span class="line"></span><br><span class="line">inputProcessor &#x3D; new StreamInputProcessor&lt;&gt;(</span><br><span class="line">inputGates,</span><br><span class="line">inSerializer,</span><br><span class="line">this,</span><br><span class="line">configuration.getCheckpointMode(),</span><br><span class="line">getCheckpointLock(),</span><br><span class="line">getEnvironment().getIOManager(),</span><br><span class="line">getEnvironment().getTaskManagerInfo().getConfiguration(),</span><br><span class="line">getStreamStatusMaintainer(),</span><br><span class="line">this.headOperator);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; make sure that stream tasks report their I&#x2F;O statistics</span><br><span class="line">inputProcessor.setMetricGroup(getEnvironment().getMetricGroup().getIOMetricGroup());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是OneInputStreamTask的init方法，从configs里面获取StreamOperator信息，生成自己的inputProcessor。那么inputProcessor是如何处理数据的呢？我们接着跟进源码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean processInput() throws Exception &#123;</span><br><span class="line">if (isFinished) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if (numRecordsIn &#x3D;&#x3D; null) &#123;</span><br><span class="line">numRecordsIn &#x3D; ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）</span><br><span class="line">while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F;注意 1在下面</span><br><span class="line">    &#x2F;&#x2F;2.接下来，会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作</span><br><span class="line">if (currentRecordDeserializer !&#x3D; null) &#123;</span><br><span class="line">DeserializationResult result &#x3D; currentRecordDeserializer.getNextRecord(deserializationDelegate);</span><br><span class="line"></span><br><span class="line">if (result.isBufferConsumed()) &#123;</span><br><span class="line">currentRecordDeserializer.getCurrentBuffer().recycle();</span><br><span class="line">currentRecordDeserializer &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (result.isFullRecord()) &#123;</span><br><span class="line">StreamElement recordOrMark &#x3D; deserializationDelegate.getInstance();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F;如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在），</span><br><span class="line">if (recordOrMark.isWatermark()) &#123;</span><br><span class="line">&#x2F;&#x2F; handle watermark</span><br><span class="line">statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);</span><br><span class="line">continue;</span><br><span class="line">&#125; else if (recordOrMark.isStreamStatus()) &#123;</span><br><span class="line">&#x2F;&#x2F;如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。</span><br><span class="line">&#x2F;&#x2F; handle stream status</span><br><span class="line">statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);</span><br><span class="line">continue;</span><br><span class="line">&#125; else if (recordOrMark.isLatencyMarker()) &#123;</span><br><span class="line">&#x2F;&#x2F;LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间</span><br><span class="line">&#x2F;&#x2F; handle latency marker</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">streamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());</span><br><span class="line">&#125;</span><br><span class="line">continue;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F;这里就是真正的，用户的代码即将被执行的地方。从章节1到这里足足用了三万字，有点万里长征的感觉</span><br><span class="line">&#x2F;&#x2F; now we can do the actual processing</span><br><span class="line">StreamRecord&lt;IN&gt; record &#x3D; recordOrMark.asRecord();</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">numRecordsIn.inc();</span><br><span class="line">streamOperator.setKeyContextElement1(record);</span><br><span class="line">streamOperator.processElement(record);</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;1.程序首先获取下一个buffer</span><br><span class="line">            &#x2F;&#x2F;这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器</span><br><span class="line">final BufferOrEvent bufferOrEvent &#x3D; barrierHandler.getNextNonBlocked();</span><br><span class="line">if (bufferOrEvent !&#x3D; null) &#123;</span><br><span class="line">if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">currentChannel &#x3D; bufferOrEvent.getChannelIndex();</span><br><span class="line">currentRecordDeserializer &#x3D; recordDeserializers[currentChannel];</span><br><span class="line">currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; Event received</span><br><span class="line">final AbstractEvent event &#x3D; bufferOrEvent.getEvent();</span><br><span class="line">if (event.getClass() !&#x3D; EndOfPartitionEvent.class) &#123;</span><br><span class="line">throw new IOException(&quot;Unexpected event: &quot; + event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">isFinished &#x3D; true;</span><br><span class="line">if (!barrierHandler.isEmpty()) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Trailing data in checkpoint barrier handler.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，以上部分就是一个flink程序启动后，到执行用户代码之前，flink框架所做的准备工作。回顾一下：</p><ul><li>启动一个环境</li><li>生成StreamGraph</li><li>注册和选举JobManager</li><li>在各节点生成TaskManager，并根据JobGraph生成对应的Task</li><li>启动各个task，准备执行代码</li></ul><p>接下来，我们挑几个Operator看看flink是如何抽象这些算子的。</p><h2 id="4-StreamOperator的抽象与实现"><a href="#4-StreamOperator的抽象与实现" class="headerlink" title="4. StreamOperator的抽象与实现"></a>4. StreamOperator的抽象与实现</h2><h3 id="4-1-数据源的逻辑——StreamSource与时间模型"><a href="#4-1-数据源的逻辑——StreamSource与时间模型" class="headerlink" title="4.1 数据源的逻辑——StreamSource与时间模型"></a>4.1 数据源的逻辑——StreamSource与时间模型</h3><p>StreamSource抽象了一个数据源，并且指定了一些如何处理数据的模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamSource&lt;OUT, SRC extends SourceFunction&lt;OUT&gt;&gt;</span><br><span class="line">extends AbstractUdfStreamOperator&lt;OUT, SRC&gt; implements StreamOperator&lt;OUT&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">public void run(final Object lockingObject, final StreamStatusMaintainer streamStatusMaintainer) throws Exception &#123;</span><br><span class="line">run(lockingObject, streamStatusMaintainer, output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void run(final Object lockingObject,</span><br><span class="line">final StreamStatusMaintainer streamStatusMaintainer,</span><br><span class="line">final Output&lt;StreamRecord&lt;OUT&gt;&gt; collector) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">final TimeCharacteristic timeCharacteristic &#x3D; getOperatorConfig().getTimeCharacteristic();</span><br><span class="line"></span><br><span class="line">LatencyMarksEmitter latencyEmitter &#x3D; null;</span><br><span class="line">if (getExecutionConfig().isLatencyTrackingEnabled()) &#123;</span><br><span class="line">latencyEmitter &#x3D; new LatencyMarksEmitter&lt;&gt;(</span><br><span class="line">getProcessingTimeService(),</span><br><span class="line">collector,</span><br><span class="line">getExecutionConfig().getLatencyTrackingInterval(),</span><br><span class="line">getOperatorConfig().getVertexID(),</span><br><span class="line">getRuntimeContext().getIndexOfThisSubtask());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final long watermarkInterval &#x3D; getRuntimeContext().getExecutionConfig().getAutoWatermarkInterval();</span><br><span class="line"></span><br><span class="line">this.ctx &#x3D; StreamSourceContexts.getSourceContext(</span><br><span class="line">timeCharacteristic,</span><br><span class="line">getProcessingTimeService(),</span><br><span class="line">lockingObject,</span><br><span class="line">streamStatusMaintainer,</span><br><span class="line">collector,</span><br><span class="line">watermarkInterval,</span><br><span class="line">-1);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">userFunction.run(ctx);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if we get here, then the user function either exited after being done (finite source)</span><br><span class="line">&#x2F;&#x2F; or the function was canceled or stopped. For the finite source case, we should emit</span><br><span class="line">&#x2F;&#x2F; a final watermark that indicates that we reached the end of event-time</span><br><span class="line">if (!isCanceledOrStopped()) &#123;</span><br><span class="line">ctx.emitWatermark(Watermark.MAX_WATERMARK);</span><br><span class="line">&#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">&#x2F;&#x2F; make sure that the context is closed in any case</span><br><span class="line">ctx.close();</span><br><span class="line">if (latencyEmitter !&#x3D; null) &#123;</span><br><span class="line">latencyEmitter.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">private static class LatencyMarksEmitter&lt;OUT&gt; &#123;</span><br><span class="line">private final ScheduledFuture&lt;?&gt; latencyMarkTimer;</span><br><span class="line"></span><br><span class="line">public LatencyMarksEmitter(</span><br><span class="line">final ProcessingTimeService processingTimeService,</span><br><span class="line">final Output&lt;StreamRecord&lt;OUT&gt;&gt; output,</span><br><span class="line">long latencyTrackingInterval,</span><br><span class="line">final int vertexID,</span><br><span class="line">final int subtaskIndex) &#123;</span><br><span class="line"></span><br><span class="line">latencyMarkTimer &#x3D; processingTimeService.scheduleAtFixedRate(</span><br><span class="line">new ProcessingTimeCallback() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onProcessingTime(long timestamp) throws Exception &#123;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; ProcessingTimeService callbacks are executed under the checkpointing lock</span><br><span class="line">output.emitLatencyMarker(new LatencyMarker(timestamp, vertexID, subtaskIndex));</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">&#x2F;&#x2F; we catch the Throwables here so that we don&#39;t trigger the processing</span><br><span class="line">&#x2F;&#x2F; timer services async exception handler</span><br><span class="line">LOG.warn(&quot;Error while emitting latency marker.&quot;, t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">0L,</span><br><span class="line">latencyTrackingInterval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void close() &#123;</span><br><span class="line">latencyMarkTimer.cancel(true);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在StreamSource生成上下文之后，接下来就是把上下文交给SourceFunction去执行:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userFunction.run(ctx);</span><br></pre></td></tr></table></figure><p>SourceFunction是对Function的一个抽象，就好像MapFunction，KeyByFunction一样，用户选择实现这些函数，然后flink框架就能利用这些函数进行计算，完成用户逻辑。<br>我们的wordcount程序使用了flink提供的一个<code>SocketTextStreamFunction</code>。我们可以看一下它的实现逻辑，对source如何运行有一个基本的认识：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run(SourceContext&lt;String&gt; ctx) throws Exception &#123;</span><br><span class="line">final StringBuilder buffer &#x3D; new StringBuilder();</span><br><span class="line">long attempt &#x3D; 0;</span><br><span class="line"></span><br><span class="line">while (isRunning) &#123;</span><br><span class="line"></span><br><span class="line">try (Socket socket &#x3D; new Socket()) &#123;</span><br><span class="line">currentSocket &#x3D; socket;</span><br><span class="line"></span><br><span class="line">LOG.info(&quot;Connecting to server socket &quot; + hostname + &#39;:&#39; + port);</span><br><span class="line">socket.connect(new InetSocketAddress(hostname, port), CONNECTION_TIMEOUT_TIME);</span><br><span class="line">BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">char[] cbuf &#x3D; new char[8192];</span><br><span class="line">int bytesRead;</span><br><span class="line">&#x2F;&#x2F;核心逻辑就是一直读inputSocket,然后交给collect方法</span><br><span class="line">while (isRunning &amp;&amp; (bytesRead &#x3D; reader.read(cbuf)) !&#x3D; -1) &#123;</span><br><span class="line">buffer.append(cbuf, 0, bytesRead);</span><br><span class="line">int delimPos;</span><br><span class="line">while (buffer.length() &gt;&#x3D; delimiter.length() &amp;&amp; (delimPos &#x3D; buffer.indexOf(delimiter)) !&#x3D; -1) &#123;</span><br><span class="line">String record &#x3D; buffer.substring(0, delimPos);</span><br><span class="line">&#x2F;&#x2F; truncate trailing carriage return</span><br><span class="line">if (delimiter.equals(&quot;\n&quot;) &amp;&amp; record.endsWith(&quot;\r&quot;)) &#123;</span><br><span class="line">record &#x3D; record.substring(0, record.length() - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;读到数据后，把数据交给collect方法，collect方法负责把数据交到合适的位置（如发布为br变量，或者交给下个operator，或者通过网络发出去）</span><br><span class="line">ctx.collect(record);</span><br><span class="line">buffer.delete(0, delimPos + delimiter.length());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if we dropped out of this loop due to an EOF, sleep and retry</span><br><span class="line">if (isRunning) &#123;</span><br><span class="line">attempt++;</span><br><span class="line">if (maxNumRetries &#x3D;&#x3D; -1 || attempt &lt; maxNumRetries) &#123;</span><br><span class="line">LOG.warn(&quot;Lost connection to server socket. Retrying in &quot; + delayBetweenRetries + &quot; msecs...&quot;);</span><br><span class="line">Thread.sleep(delayBetweenRetries);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; this should probably be here, but some examples expect simple exists of the stream source</span><br><span class="line">&#x2F;&#x2F; throw new EOFException(&quot;Reached end of stream and reconnects are not enabled.&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; collect trailing data</span><br><span class="line">if (buffer.length() &gt; 0) &#123;</span><br><span class="line">ctx.collect(buffer.toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码里，只有collect方法有些复杂度，后面我们在讲到flink的对象机制时会结合来讲，此处知道collect方法会收集结果，然后发送给接收者即可。在我们的wordcount里，这个算子的接收者就是被chain在一起的flatmap算子，不记得这个示例程序的话，可以返回第一章去看一下。</p><h3 id="4-2-从数据输入到数据处理——OneInputStreamOperator-amp-AbstractUdfStreamOperator"><a href="#4-2-从数据输入到数据处理——OneInputStreamOperator-amp-AbstractUdfStreamOperator" class="headerlink" title="4.2 从数据输入到数据处理——OneInputStreamOperator &amp; AbstractUdfStreamOperator"></a>4.2 从数据输入到数据处理——OneInputStreamOperator &amp; AbstractUdfStreamOperator</h3><p>StreamSource是用来开启整个流的算子，而承接输入数据并进行处理的算子就是OneInputStreamOperator、TwoInputStreamOperator等。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/9itne7dj58lkkb4mtrt9c8q5/image_1cdc1tbgs136k1ppf17at14fumjf2d.png" alt="image_1cdc1tbgs136k1ppf17at14fumjf2d.png-126.7kB"><br>整个StreamOperator的继承关系如上图所示（图很大，建议点开放大看）。<br>OneInputStreamOperator这个接口的逻辑很简单：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface OneInputStreamOperator&lt;IN, OUT&gt; extends StreamOperator&lt;OUT&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Processes one element that arrived at this operator.</span><br><span class="line"> * This method is guaranteed to not be called concurrently with other methods of the operator.</span><br><span class="line"> *&#x2F;</span><br><span class="line">void processElement(StreamRecord&lt;IN&gt; element) throws Exception;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Processes a &#123;@link Watermark&#125;.</span><br><span class="line"> * This method is guaranteed to not be called concurrently with other methods of the operator.</span><br><span class="line"> *</span><br><span class="line"> * @see org.apache.flink.streaming.api.watermark.Watermark</span><br><span class="line"> *&#x2F;</span><br><span class="line">void processWatermark(Watermark mark) throws Exception;</span><br><span class="line"></span><br><span class="line">void processLatencyMarker(LatencyMarker latencyMarker) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而实现了这个接口的StreamFlatMap算子也很简单，没什么可说的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StreamFlatMap&lt;IN, OUT&gt;</span><br><span class="line">extends AbstractUdfStreamOperator&lt;OUT, FlatMapFunction&lt;IN, OUT&gt;&gt;</span><br><span class="line">implements OneInputStreamOperator&lt;IN, OUT&gt; &#123;</span><br><span class="line"></span><br><span class="line">private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line">private transient TimestampedCollector&lt;OUT&gt; collector;</span><br><span class="line"></span><br><span class="line">public StreamFlatMap(FlatMapFunction&lt;IN, OUT&gt; flatMapper) &#123;</span><br><span class="line">super(flatMapper);</span><br><span class="line">chainingStrategy &#x3D; ChainingStrategy.ALWAYS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void open() throws Exception &#123;</span><br><span class="line">super.open();</span><br><span class="line">collector &#x3D; new TimestampedCollector&lt;&gt;(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">collector.setTimestamp(element);</span><br><span class="line">userFunction.flatMap(element.getValue(), collector);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从类图里可以看到，flink为我们封装了一个算子的基类<code>AbstractUdfStreamOperator</code>，提供了一些通用功能，比如把context赋给算子，保存快照等等，其中最为大家了解的应该是这两个：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void open() throws Exception &#123;</span><br><span class="line">super.open();</span><br><span class="line">FunctionUtils.openFunction(userFunction, new Configuration());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() throws Exception &#123;</span><br><span class="line">super.close();</span><br><span class="line">functionsClosed &#x3D; true;</span><br><span class="line">FunctionUtils.closeFunction(userFunction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个就是flink提供的<code>Rich***Function</code>系列算子的open和close方法被执行的地方。</p><h3 id="4-3-StreamSink"><a href="#4-3-StreamSink" class="headerlink" title="4.3 StreamSink"></a>4.3 StreamSink</h3><p>StreamSink着实没什么可说的，逻辑很简单，值得一提的只有两个方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</span><br><span class="line">sinkContext.element &#x3D; element;</span><br><span class="line">userFunction.invoke(element.getValue(), sinkContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void reportOrForwardLatencyMarker(LatencyMarker maker) &#123;</span><br><span class="line">&#x2F;&#x2F; all operators are tracking latencies</span><br><span class="line">this.latencyGauge.reportLatency(maker, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sinks don&#39;t forward latency markers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>processElement</code> 是继承自StreamOperator的方法。<code>reportOrForwardLatencyMarker</code>是用来计算延迟的，前面提到StreamSource会产生LateMarker，用于记录数据计算时间，就是在这里完成了计算。</p><p>算子这部分逻辑相对简单清晰，就讲这么多吧。</p><h2 id="5-为执行保驾护航——Fault-Tolerant与保证Exactly-Once语义"><a href="#5-为执行保驾护航——Fault-Tolerant与保证Exactly-Once语义" class="headerlink" title="5. 为执行保驾护航——Fault Tolerant与保证Exactly-Once语义"></a>5. 为执行保驾护航——Fault Tolerant与保证Exactly-Once语义</h2><h3 id="5-1-Fault-Tolerant演进之路"><a href="#5-1-Fault-Tolerant演进之路" class="headerlink" title="5.1 Fault Tolerant演进之路"></a>5.1 Fault Tolerant演进之路</h3><p>对于7×24小时不间断运行的流程序来说，要保证fault tolerant是很难的，这不像是离线任务，如果失败了只需要清空已有结果，重新跑一次就可以了。对于流任务，如果要保证能够重新处理已处理过的数据，就要把数据保存下来；而这就面临着几个问题：比如一是保存多久的数据？二是重复计算的数据应该怎么处理，怎么保证幂等性？<br>对于一个流系统，我们有以下希望：</p><ol><li>最好能做到exactly-once</li><li>处理延迟越低越好</li><li>吞吐量越高越好</li><li>计算模型应当足够简单易用，又具有足够的表达力</li><li>从错误恢复的开销越低越好</li><li>足够的流控制能力（背压能力）</li></ol><h4 id="5-1-1-Storm的Record-acknowledgement模式"><a href="#5-1-1-Storm的Record-acknowledgement模式" class="headerlink" title="5.1.1 Storm的Record acknowledgement模式"></a>5.1.1 Storm的Record acknowledgement模式</h4><p>storm的fault tolerant是这样工作的：每一个被storm的operator处理的数据都会向其上一个operator发送一份应答消息，通知其已被下游处理。storm的源operator保存了所有已发送的消息的每一个下游算子的应答消息，当它收到来自sink的应答时，它就知道该消息已经被完整处理，可以移除了。<br>如果没有收到应答，storm就会重发该消息。显而易见，这是一种at least once的逻辑。另外，这种方式面临着严重的幂等性问题，例如对一个count算子，如果count的下游算子出错，source重发该消息，那么防止该消息被count两遍的逻辑需要程序员自己去实现。最后，这样一种处理方式非常低效，吞吐量很低。</p><h4 id="5-1-2-Spark-streaming的micro-batch模式"><a href="#5-1-2-Spark-streaming的micro-batch模式" class="headerlink" title="5.1.2 Spark streaming的micro batch模式"></a>5.1.2 Spark streaming的micro batch模式</h4><p>前面提到，storm的实现方式就注定了与高吞吐量无缘。那么，为了提高吞吐量，把一批数据聚集在一起处理就是很自然的选择。Spark Streaming的实现就是基于这样的思路：<br>我们可以在完全的连续计算与完全的分批计算中间取折中，通过控制每批计算数据的大小来控制延迟与吞吐量的制约，如果想要低延迟，就用小一点的batch，如果想要大吞吐量，就不得不忍受更高的延迟（更久的等待数据到来的时间和更多的计算），如下图所示。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/1uwp211uaxpb6nqbztfkh3u1/image_1ceop58ha180p1h3ren58jk15gb9.png" alt="image_1ceop58ha180p1h3ren58jk15gb9.png-105.7kB"><br>以这样的方式，可以在每个batch中做到exactly-once，但是这种方式也有其弊端：<br>首先，batch的方式使得一些需要跨batch的操作变得非常困难，例如session window；用户不得不自己想办法去实现相关逻辑。<br>其次，batch模式很难做好背压。当一个batch因为种种原因处理慢了，那么下一个batch要么不得不容纳更多的新来数据，要么不得不堆积更多的batch，整个任务可能会被拖垮，这是一个非常致命的问题。<br>最后，batch的方式基本意味着其延迟是有比较高的下限的，实时性上不好。</p><h4 id="5-1-3-Google-Cloud-Dataflow的事务式模型"><a href="#5-1-3-Google-Cloud-Dataflow的事务式模型" class="headerlink" title="5.1.3 Google Cloud Dataflow的事务式模型"></a>5.1.3 Google Cloud Dataflow的事务式模型</h4><p>我们在传统数据库，如mysql中使用binlog来完成事务，这样的思路也可以被用在实现exactly-once模型中。例如，我们可以log下每个数据元素每一次被处理时的结果和当时所处的操作符的状态。这样，当我们需要fault tolerant时，我们只需要读一下log就可以了。这种模式规避了storm和spark所面临的问题，并且能够很好的实现exactly-once，唯一的弊端是：如何尽可能的减少log的成本？Flink给了我们答案。</p><h4 id="5-1-4-Flink的分布式快照机制"><a href="#5-1-4-Flink的分布式快照机制" class="headerlink" title="5.1.4 Flink的分布式快照机制"></a>5.1.4 Flink的分布式快照机制</h4><p> 实现exactly-once的关键是什么？是能够准确的知道和快速记录下来当前的operator的状态、当前正在处理的元素（以及正处在不同算子之间传递的元素）。如果上面这些可以做到，那么fault tolerant无非就是从持久化存储中读取上次记录的这些元信息，并且恢复到程序中。那么Flink是如何实现的呢？</p><p>Flink的分布式快照的核心是其轻量级异步分布式快照机制。为了实现这一机制，flink引入了一个概念，叫做Barrier。Barrier是一种标记，它被source产生并且插入到流数据中，被发送到下游节点。当下游节点处理到该barrier标志时，这就意味着在该barrier插入到流数据时，已经进入系统的数据在当前节点已经被处理完毕。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/r0h3z9im5o9ijqlvvl7vjgrt/image_1ceos05badva20hb5glen1voqm.png" alt="image_1ceos05badva20hb5glen1voqm.png-15.3kB"></p><p>如图所示，每当一个barrier流过一个算子节点时，就说明了在该算子上，可以触发一次检查点，用以保存当前节点的状态和已经处理过的数据，这就是一份快照。（在这里可以联想一下micro-batch，把barrier想象成分割每个batch的逻辑，会好理解一点）这样的方式下，记录快照就像和前面提到的micro-batch一样容易。</p><p>与此同时，该算子会向下游发送该barrier。因为数据在算子之间是按顺序发送的，所以当下游节点收到该barrier时，也就意味着同样的一批数据在下游节点上也处理完毕，可以进行一次checkpoint，保存基于该节点的一份快照，快照完成后，会通知JobMananger自己完成了这个快照。这就是分布式快照的基本含义。</p><p>再看这张图：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/fp1rtm1pjv12lo6nld7bns5j/image_1ceot7q13apu1a04170af7j1jao34.png" alt="image_1ceot7q13apu1a04170af7j1jao34.png-66.6kB"><br>有时，有的算子的上游节点和下游节点都不止一个，应该怎么处理呢？如果有不止一个下游节点，就向每个下游发送barrier。同理，如果有不止一个上游节点，那么就要等到所有上游节点的同一批次的barrier到达之后，才能触发checkpoint。因为每个节点运算速度不同，所以有的上游节点可能已经在发下个barrier周期的数据了，有的上游节点还没发送本次的barrier，这时候，当前算子就要缓存一下提前到来的数据，等比较慢的上游节点发送barrier之后，才能处理下一批数据。</p><p>当整个程序的最后一个算子sink都收到了这个barrier，也就意味着这个barrier和上个barrier之间所夹杂的这批元素已经全部落袋为安。这时，最后一个算子通知JobManager整个流程已经完成，而JobManager随后发出通知，要求所有算子删除本次快照内容，以完成清理。这整个部分，就是Flink的<strong>两阶段提交的checkpoint过程</strong>，如下面四幅图所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/achr7r6gcstodi7m9gc270r5/image_1ceot517e14g31u2u1mnt12o91dkb1g.png" alt="image_1ceot517e14g31u2u1mnt12o91dkb1g.png-175.5kB"></p><p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/sibwkuskxs20xjcqkn872xg5/image_1ceot5kqbnik1f2i1dss1q5c1a1t.png" alt="image_1ceot5kqbnik1f2i1dss1q5c1a1t.png-221.3kB"></p><p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/0ly9zl3w3twknw7ftalv722a/image_1ceot64dppjtojkq3n1jl5j0h2a.png" alt="image_1ceot64dppjtojkq3n1jl5j0h2a.png-297.8kB"></p><p><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/b5wrovrsrghkxuumgf6rgabc/image_1ceot6kes56sidn1f2u1voo19kf2n.png" alt="image_1ceot6kes56sidn1f2u1voo19kf2n.png-255.5kB"></p><p>总之，通过这种方式，flink实现了我们前面提到的六项对流处理框架的要求：exactly-once、低延迟、高吞吐、易用的模型、方便的恢复机制。</p><p>最后，贴一个美团做的flink与storm的性能对比：<a href="https://tech.meituan.com/Flink_Benchmark.html">flink与storm的性能对比</a></p><h3 id="5-2-checkpoint的生命周期"><a href="#5-2-checkpoint的生命周期" class="headerlink" title="5.2 checkpoint的生命周期"></a>5.2 checkpoint的生命周期</h3><p>接下来，我们结合源码来看看flink的checkpoint到底是如何实现其生命周期的：</p><blockquote><p>由于flink提供的SocketSource并不支持checkpoint，所以这里我以<code>FlinkKafkaConsumer010</code>作为sourceFunction。</p></blockquote><h4 id="5-2-1-触发checkpoint"><a href="#5-2-1-触发checkpoint" class="headerlink" title="5.2.1 触发checkpoint"></a>5.2.1 触发checkpoint</h4><p>要完成一次checkpoint，第一步必然是发起checkpoint请求。那么，这个请求是哪里发出的，怎么发出的，又由谁控制呢？<br>还记得如果我们要设置checkpoint的话，需要指定checkpoint间隔吧？既然是一个指定间隔触发的功能，那应该会有类似于Scheduler的东西存在，flink里，这个负责触发checkpoint的类是<code>CheckpointCoordinator</code>。</p><p>flink在提交job时，会启动这个类的<code>startCheckpointScheduler</code>方法，如下所示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void startCheckpointScheduler() &#123;</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">if (shutdown) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Checkpoint coordinator is shut down&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; make sure all prior timers are cancelled</span><br><span class="line">stopCheckpointScheduler();</span><br><span class="line"></span><br><span class="line">periodicScheduling &#x3D; true;</span><br><span class="line">currentPeriodicTrigger &#x3D; timer.scheduleAtFixedRate(</span><br><span class="line">new ScheduledTrigger(), </span><br><span class="line">baseInterval, baseInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final class ScheduledTrigger implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">triggerCheckpoint(System.currentTimeMillis(), true);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e) &#123;</span><br><span class="line">LOG.error(&quot;Exception while triggering checkpoint.&quot;, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动之后，就会以设定好的频率调用<code>triggerCheckPoint()</code>方法。这个方法太长，我大概说一下都做了什么：</p><ul><li>检查符合触发checkpoint的条件，例如如果禁止了周期性的checkpoint，尚未达到触发checkpoint的最小间隔等等，就直接return</li><li>检查是否所有需要checkpoint和需要响应checkpoint的ACK（ack涉及到checkpoint的两阶段提交，后面会讲）的task都处于running状态，否则return</li><li>如果都符合，那么执行<code>checkpointID = checkpointIdCounter.getAndIncrement();</code>以生成一个新的id，然后生成一个<code>PendingCheckpoint</code>。PendingCheckpoint是一个启动了的checkpoint，但是还没有被确认。等到所有的task都确认了本次checkpoint，那么这个checkpoint对象将转化为一个<code>CompletedCheckpoint</code>。</li><li>定义一个超时callback，如果checkpoint执行了很久还没完成，就把它取消</li><li>触发MasterHooks，用户可以定义一些额外的操作，用以增强checkpoint的功能（如准备和清理外部资源）</li><li>接下来是核心逻辑：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; send the messages to the tasks that trigger their checkpoint</span><br><span class="line">for (Execution execution: executions) &#123;</span><br><span class="line">execution.triggerCheckpoint(checkpointID, timestamp, checkpointOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是调用了Execution的triggerCheckpoint方法，一个execution就是一个executionVertex的实际执行者。我们看一下这个方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void triggerCheckpoint(long checkpointId, long timestamp, CheckpointOptions checkpointOptions) &#123;</span><br><span class="line">final LogicalSlot slot &#x3D; assignedResource;</span><br><span class="line"></span><br><span class="line">if (slot !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F;TaskManagerGateway是用来跟taskManager进行通信的组件</span><br><span class="line">final TaskManagerGateway taskManagerGateway &#x3D; slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">LOG.debug(&quot;The execution has no slot assigned. This indicates that the execution is &quot; +</span><br><span class="line">&quot;no longer running.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下跟就进入了<code>Task</code>类的范畴，我们将在下一小节进行解读。本小节主要讲了<code>CheckpointCoordinator</code>类是如何触发一次checkpoint，从其名字也可以看出来其功能：检查点协调器。</p><h4 id="5-2-2-Task层面checkpoint的准备工作"><a href="#5-2-2-Task层面checkpoint的准备工作" class="headerlink" title="5.2.2 Task层面checkpoint的准备工作"></a>5.2.2 Task层面checkpoint的准备工作</h4><p>先说Task类中的部分，该类创建了一个<code>CheckpointMetaData</code>的对象，并且生成了一个Runable匿名类用于执行checkpoint，然后以异步的方式触发了该Runable：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void triggerCheckpointBarrier(</span><br><span class="line">final long checkpointID,</span><br><span class="line">long checkpointTimestamp,</span><br><span class="line">final CheckpointOptions checkpointOptions) &#123;</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line"></span><br><span class="line">Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#x2F;&#x2F; set safety net from the task&#39;s context for checkpointing thread</span><br><span class="line">LOG.debug(&quot;Creating FileSystem stream leak safety net for &#123;&#125;&quot;, Thread.currentThread().getName());</span><br><span class="line">FileSystemSafetyNet.setSafetyNetCloseableRegistryForThread(safetyNetCloseableRegistry);</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">boolean success &#x3D; invokable.triggerCheckpoint(checkpointMetaData, checkpointOptions);</span><br><span class="line">if (!success) &#123;</span><br><span class="line">checkpointResponder.declineCheckpoint(</span><br><span class="line">getJobID(), getExecutionId(), checkpointID,</span><br><span class="line">new CheckpointDeclineTaskNotReadyException(taskName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">                   ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">executeAsyncCallRunnable(runnable, String.format(&quot;Checkpoint Trigger for %s (%s).&quot;, taskNameWithSubtask, executionId));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码里的invokable事实上就是我们的StreamTask了。Task类实际上是将checkpoint委托给了更具体的类去执行，而StreamTask也将委托给更具体的类，直到业务代码。<br>StreamTask是这样实现的：</p><ul><li>如果task还在运行，那就可以进行checkpoint。方法是先向下游所有出口广播一个Barrier，然后触发本task的State保存。</li><li>如果task结束了，那我们就要通知下游取消本次checkpoint，方法是发送一个CancelCheckpointMarker，这是类似于Barrier的另一种消息。</li><li>注意，从这里开始，整个执行链路上开始出现Barrier，可以和前面讲Fault Tolerant原理的地方结合看一下。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean performCheckpoint(</span><br><span class="line">CheckpointMetaData checkpointMetaData,</span><br><span class="line">CheckpointOptions checkpointOptions,</span><br><span class="line">CheckpointMetrics checkpointMetrics) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">if (isRunning) &#123;</span><br><span class="line"></span><br><span class="line">operatorChain.broadcastCheckpointBarrier(</span><br><span class="line">checkpointMetaData.getCheckpointId(),</span><br><span class="line">checkpointMetaData.getTimestamp(),</span><br><span class="line">checkpointOptions);</span><br><span class="line"></span><br><span class="line">checkpointState(checkpointMetaData, checkpointOptions, checkpointMetrics);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">               </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>完成<code>broadcastCheckpointBarrier</code>方法后，在<code>checkpointState()</code>方法中，StreamTask还做了很多别的工作：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void executeCheckpointing() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;这里，就是调用StreamOperator进行snapshotState的入口方法</span><br><span class="line">for (StreamOperator&lt;?&gt; op : allOperators) &#123;</span><br><span class="line">checkpointStreamOperator(op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; we are transferring ownership over snapshotInProgressList for cleanup to the thread, active on submit</span><br><span class="line">AsyncCheckpointRunnable asyncCheckpointRunnable &#x3D; new AsyncCheckpointRunnable(</span><br><span class="line">owner,</span><br><span class="line">operatorSnapshotsInProgress,</span><br><span class="line">checkpointMetaData,</span><br><span class="line">checkpointMetrics,</span><br><span class="line">startAsyncPartNano);</span><br><span class="line"></span><br><span class="line">owner.cancelables.registerCloseable(asyncCheckpointRunnable);</span><br><span class="line">&#x2F;&#x2F;这里注册了一个Runnable，在执行完checkpoint之后向JobManager发出CompletedCheckPoint消息，这也是fault tolerant两阶段提交的一部分</span><br><span class="line">owner.asyncOperationsThreadPool.submit(asyncCheckpointRunnable);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>说到checkpoint，我们印象里最直观的感受肯定是我们的一些做聚合的操作符的状态保存，比如sum的和以及count的值等等。这些内容就是StreamOperator部分将要触发保存的内容。可以看到，除了我们直观的这些操作符的状态保存外，flink的checkpoint做了大量的其他工作。</li></ul><p>接下来，我们就把目光转向操作符的checkpoint机制。</p><h4 id="5-2-3-操作符的状态保存及barrier传递"><a href="#5-2-3-操作符的状态保存及barrier传递" class="headerlink" title="5.2.3 操作符的状态保存及barrier传递"></a>5.2.3 操作符的状态保存及barrier传递</h4><p>第四章时，我们已经了解了StreamOperator的类关系，这里，我们就直接接着上一节的<code>checkpointStreamOperator(op)</code>方法往下讲。<br>顺便，前面也提到了，在进行checkpoint之前，operator初始化时，会执行一个<code>initializeState</code>方法，在该方法中，如果task是从失败中恢复的话，其保存的state也会被restore进来。</p><p>传递barrier是在进行本operator的statesnapshot之前完成的，我们先来看看其逻辑，其实和传递一条数据是类似的，就是生成一个<code>CheckpointBarrier</code>对象，然后向每个streamOutput写进去：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   public void broadcastCheckpointBarrier(long id, long timestamp, CheckpointOptions checkpointOptions) throws IOException &#123;</span><br><span class="line">try &#123;</span><br><span class="line">CheckpointBarrier barrier &#x3D; new CheckpointBarrier(id, timestamp, checkpointOptions);</span><br><span class="line">for (RecordWriterOutput&lt;?&gt; streamOutput : streamOutputs) &#123;</span><br><span class="line">streamOutput.broadcastEvent(barrier);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e) &#123;</span><br><span class="line">throw new IOException(&quot;Interrupted while broadcasting checkpoint barrier&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下游的operator接收到本barrier，就会触发其自身的checkpoint。</p><p>StreamTask在执行完broadcastCheckpointBarrier之后，<br>我们当前的wordcount程序里有两个operator chain，分别是：</p><ul><li>kafka source -&gt; flatmap</li><li>keyed aggregation -&gt; sink</li></ul><p>我们就按这个顺序来捋一下checkpoint的过程。</p><p>1.kafka source的checkpoint过程</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void snapshotState(FunctionSnapshotContext context) throws Exception &#123;</span><br><span class="line">if (!running) &#123;</span><br><span class="line">LOG.debug(&quot;snapshotState() called on closed source&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">unionOffsetStates.clear();</span><br><span class="line"></span><br><span class="line">final AbstractFetcher&lt;?, ?&gt; fetcher &#x3D; this.kafkaFetcher;</span><br><span class="line">if (fetcher &#x3D;&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; the fetcher has not yet been initialized, which means we need to return the</span><br><span class="line">&#x2F;&#x2F; originally restored offsets or the assigned partitions</span><br><span class="line">for (Map.Entry&lt;KafkaTopicPartition, Long&gt; subscribedPartition : subscribedPartitionsToStartOffsets.entrySet()) &#123;</span><br><span class="line">unionOffsetStates.add(Tuple2.of(subscribedPartition.getKey(), subscribedPartition.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (offsetCommitMode &#x3D;&#x3D; OffsetCommitMode.ON_CHECKPOINTS) &#123;</span><br><span class="line">&#x2F;&#x2F; the map cannot be asynchronously updated, because only one checkpoint call can happen</span><br><span class="line">&#x2F;&#x2F; on this function at a time: either snapshotState() or notifyCheckpointComplete()</span><br><span class="line">pendingOffsetsToCommit.put(context.getCheckpointId(), restoredState);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">HashMap&lt;KafkaTopicPartition, Long&gt; currentOffsets &#x3D; fetcher.snapshotCurrentState();</span><br><span class="line"></span><br><span class="line">if (offsetCommitMode &#x3D;&#x3D; OffsetCommitMode.ON_CHECKPOINTS) &#123;</span><br><span class="line">&#x2F;&#x2F; the map cannot be asynchronously updated, because only one checkpoint call can happen</span><br><span class="line">&#x2F;&#x2F; on this function at a time: either snapshotState() or notifyCheckpointComplete()</span><br><span class="line">pendingOffsetsToCommit.put(context.getCheckpointId(), currentOffsets);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;KafkaTopicPartition, Long&gt; kafkaTopicPartitionLongEntry : currentOffsets.entrySet()) &#123;</span><br><span class="line">unionOffsetStates.add(</span><br><span class="line">Tuple2.of(kafkaTopicPartitionLongEntry.getKey(), kafkaTopicPartitionLongEntry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (offsetCommitMode &#x3D;&#x3D; OffsetCommitMode.ON_CHECKPOINTS) &#123;</span><br><span class="line">&#x2F;&#x2F; truncate the map of pending offsets to commit, to prevent infinite growth</span><br><span class="line">while (pendingOffsetsToCommit.size() &gt; MAX_NUM_PENDING_CHECKPOINTS) &#123;</span><br><span class="line">pendingOffsetsToCommit.remove(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kafka的snapshot逻辑就是记录一下当前消费的offsets，然后做成tuple（partitiion，offset）放进一个<code>StateBackend</code>里。StateBackend是flink抽象出来的一个用于保存状态的接口。</p><p>2.<strong>FlatMap算子的checkpoint过程</strong><br>没什么可说的，就是调用了snapshotState()方法而已。</p><p>3.<strong>本operator chain的state保存过程</strong><br>细心的同学应该注意到了，各个算子的snapshot方法只把自己的状态保存到了StateBackend里，没有写入的持久化操作。这部分操作被放到了<code>AbstractStreamOperator</code>中，由flink统一负责持久化。其实不需要看源码我们也能想出来，持久化无非就是把这些数据用一个流写到磁盘或者别的地方，接下来我们来看看是不是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         &#x2F;&#x2F;还是AbstractStreamOperator.java的snapshotState方法</span><br><span class="line">if (null !&#x3D; operatorStateBackend) &#123;</span><br><span class="line">snapshotInProgress.setOperatorStateManagedFuture(</span><br><span class="line">operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个operatorStateBackend是怎么保存状态的呢？</p><ul><li>首先把各个算子的state做了一份深拷贝；</li><li>然后以异步的方式执行了一个内部类的runnable，该内部类的run方法实现了一个模版方法，首先打开stream，然后写入数据，然后再关闭stream。</li></ul><p>我们来看看这个写入数据的方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            public SnapshotResult&lt;OperatorStateHandle&gt; performOperation() throws Exception &#123;</span><br><span class="line">long asyncStartTime &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">CheckpointStreamFactory.CheckpointStateOutputStream localOut &#x3D; this.out;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; get the registered operator state infos ...</span><br><span class="line">List&lt;RegisteredOperatorBackendStateMetaInfo.Snapshot&lt;?&gt;&gt; operatorMetaInfoSnapshots &#x3D;</span><br><span class="line">new ArrayList&lt;&gt;(registeredOperatorStatesDeepCopies.size());</span><br><span class="line"></span><br><span class="line">for (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry : registeredOperatorStatesDeepCopies.entrySet()) &#123;</span><br><span class="line">operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ... write them all in the checkpoint stream ...</span><br><span class="line">DataOutputView dov &#x3D; new DataOutputViewStreamWrapper(localOut);</span><br><span class="line"></span><br><span class="line">OperatorBackendSerializationProxy backendSerializationProxy &#x3D;</span><br><span class="line">new OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots);</span><br><span class="line"></span><br><span class="line">backendSerializationProxy.write(dov);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释写的很清楚，我就不多说了。</p><p>4.<strong>后继operatorChain的checkpoint过程</strong><br>前面说到，在flink的流中，barrier流过时会触发checkpoint。在上面第1步中，上游节点已经发出了Barrier，所以在我们的keyed aggregation -&gt; sink 这个operatorchain中，我们将首先捕获这个barrier。</p><p>捕获barrier的过程其实就是处理input数据的过程，对应着<code>StreamInputProcessor.processInput()</code>方法，该方法我们在第四章已经讲过，这里我们简单回顾一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         &#x2F;&#x2F;每个元素都会触发这一段逻辑，如果下一个数据是buffer，则从外围的while循环里进入处理用户数据的逻辑；这个方法里默默的处理了barrier的逻辑</span><br><span class="line">         final BufferOrEvent bufferOrEvent &#x3D; barrierHandler.getNextNonBlocked();</span><br><span class="line">if (bufferOrEvent !&#x3D; null) &#123;</span><br><span class="line">if (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">currentChannel &#x3D; bufferOrEvent.getChannelIndex();</span><br><span class="line">currentRecordDeserializer &#x3D; recordDeserializers[currentChannel];</span><br><span class="line">currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; Event received</span><br><span class="line">final AbstractEvent event &#x3D; bufferOrEvent.getEvent();</span><br><span class="line">if (event.getClass() !&#x3D; EndOfPartitionEvent.class) &#123;</span><br><span class="line">throw new IOException(&quot;Unexpected event: &quot; + event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理barrier的过程在这段代码里没有体现，因为被包含在了<code>getNextNonBlocked()</code>方法中，我们看下这个方法的核心逻辑：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         &#x2F;&#x2F;BarrierBuffer.getNextNonBlocked方法</span><br><span class="line">else if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; CheckpointBarrier.class) &#123;</span><br><span class="line">if (!endOfStream) &#123;</span><br><span class="line">&#x2F;&#x2F; process barriers only if there is a chance of the checkpoint completing</span><br><span class="line">processBarrier((CheckpointBarrier) bufferOrEvent.getEvent(), bufferOrEvent.getChannelIndex());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (bufferOrEvent.getEvent().getClass() &#x3D;&#x3D; CancelCheckpointMarker.class) &#123;</span><br><span class="line">processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先提一嘴，大家还记得之前的部分也提到过CheckpointMarker吧，这里正好也对上了。</p><p>处理barrier也是个麻烦事，大家回想一下5.1节提到的屏障的原理图，一个opertor必须收到从每个inputchannel发过来的同一序号的barrier之后才能发起本节点的checkpoint，如果有的channel的数据处理的快了，那该barrier后的数据还需要缓存起来，如果有的inputchannel被关闭了，那它就不会再发送barrier过来了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws Exception &#123;</span><br><span class="line">final long barrierId &#x3D; receivedBarrier.getId();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fast path for single channel cases</span><br><span class="line">if (totalNumberOfInputChannels &#x3D;&#x3D; 1) &#123;</span><br><span class="line">if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">&#x2F;&#x2F; new checkpoint</span><br><span class="line">currentCheckpointId &#x3D; barrierId;</span><br><span class="line">notifyCheckpoint(receivedBarrier);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -- general code path for multiple input channels --</span><br><span class="line"></span><br><span class="line">if (numBarriersReceived &gt; 0) &#123;</span><br><span class="line">&#x2F;&#x2F; this is only true if some alignment is already progress and was not canceled</span><br><span class="line"></span><br><span class="line">if (barrierId &#x3D;&#x3D; currentCheckpointId) &#123;</span><br><span class="line">&#x2F;&#x2F; regular case</span><br><span class="line">onBarrier(channelIndex);</span><br><span class="line">&#125;</span><br><span class="line">else if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">&#x2F;&#x2F; we did not complete the current checkpoint, another started before</span><br><span class="line">LOG.warn(&quot;Received checkpoint barrier for checkpoint &#123;&#125; before completing current checkpoint &#123;&#125;. &quot; +</span><br><span class="line">&quot;Skipping current checkpoint.&quot;, barrierId, currentCheckpointId);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; let the task know we are not completing this</span><br><span class="line">notifyAbort(currentCheckpointId, new CheckpointDeclineSubsumedException(barrierId));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; abort the current checkpoint</span><br><span class="line">releaseBlocksAndResetBarriers();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; begin a the new checkpoint</span><br><span class="line">beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; ignore trailing barrier from an earlier checkpoint (obsolete now)</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">&#x2F;&#x2F; first barrier of a new checkpoint</span><br><span class="line">beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">&#x2F;&#x2F; either the current checkpoint was canceled (numBarriers &#x3D;&#x3D; 0) or</span><br><span class="line">&#x2F;&#x2F; this barrier is from an old subsumed checkpoint</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; check if we have all barriers - since canceled checkpoints always have zero barriers</span><br><span class="line">&#x2F;&#x2F; this can only happen on a non canceled checkpoint</span><br><span class="line">if (numBarriersReceived + numClosedChannels &#x3D;&#x3D; totalNumberOfInputChannels) &#123;</span><br><span class="line">&#x2F;&#x2F; actually trigger checkpoint</span><br><span class="line">if (LOG.isDebugEnabled()) &#123;</span><br><span class="line">LOG.debug(&quot;Received all barriers, triggering checkpoint &#123;&#125; at &#123;&#125;&quot;,</span><br><span class="line">receivedBarrier.getId(), receivedBarrier.getTimestamp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">releaseBlocksAndResetBarriers();</span><br><span class="line">notifyCheckpoint(receivedBarrier);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，当收到全部的barrier之后，就会触发<code>notifyCheckpoint()</code>，该方法又会调用StreamTask的<code>triggerCheckpoint</code>，和之前的operator是一样的。</p><p>如果还有后续的operator的话，就是完全相同的循环，不再赘述。</p><p>5.<strong>报告完成checkpoint事件</strong><br>当一个operator保存完checkpoint数据后，就会启动一个异步对象<code>AsyncCheckpointRunnable</code>，用以报告该检查点已完成，其具体逻辑在reportCompletedSnapshotStates中。这个方法把任务又最终委托给了<code>RpcCheckpointResponder</code>这个类：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkpointResponder.acknowledgeCheckpoint(</span><br><span class="line">jobId,</span><br><span class="line">executionAttemptID,</span><br><span class="line">checkpointId,</span><br><span class="line">checkpointMetrics,</span><br><span class="line">acknowledgedState);</span><br></pre></td></tr></table></figure><p>从这个类也可以看出来，它的逻辑是通过rpc的方式远程调JobManager的相关方法完成报告事件，底层也是通过akka实现的。<br>那么，谁响应了这个rpc调用呢？是该任务的JobMaster。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;JobMaster.java</span><br><span class="line">public void acknowledgeCheckpoint(</span><br><span class="line">final JobID jobID,</span><br><span class="line">final ExecutionAttemptID executionAttemptID,</span><br><span class="line">final long checkpointId,</span><br><span class="line">final CheckpointMetrics checkpointMetrics,</span><br><span class="line">final TaskStateSnapshot checkpointState) &#123;</span><br><span class="line"></span><br><span class="line">final CheckpointCoordinator checkpointCoordinator &#x3D; executionGraph.getCheckpointCoordinator();</span><br><span class="line">final AcknowledgeCheckpoint ackMessage &#x3D; new AcknowledgeCheckpoint(</span><br><span class="line">jobID,</span><br><span class="line">executionAttemptID,</span><br><span class="line">checkpointId,</span><br><span class="line">checkpointMetrics,</span><br><span class="line">checkpointState);</span><br><span class="line"></span><br><span class="line">if (checkpointCoordinator !&#x3D; null) &#123;</span><br><span class="line">getRpcService().execute(() -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">checkpointCoordinator.receiveAcknowledgeMessage(ackMessage);</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">log.warn(&quot;Error while processing checkpoint acknowledgement message&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">log.error(&quot;Received AcknowledgeCheckpoint message for job &#123;&#125; with no CheckpointCoordinator&quot;,</span><br><span class="line">jobGraph.getJobID());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JobMaster反手<del>就是一巴掌</del>就把任务又rpc给了<code>CheckpointCoordinator.receiveAcknowledgeMessage()</code>方法。</p><p>之前提到，coordinator在触发checkpoint时，生成了一个<code>PendingCheckpoint</code>，保存了所有operator的id。</p><p>当PendingCheckpoint收到一个operator的完成checkpoint的消息时，它就把这个operator从未完成checkpoint的节点集合移动到已完成的集合。当所有的operator都报告完成了checkpoint时，CheckpointCoordinator会触发<code>completePendingCheckpoint()</code>方法，该方法做了以下事情：</p><ul><li>把pendinCgCheckpoint转换为CompletedCheckpoint</li><li>把CompletedCheckpoint加入已完成的检查点集合，并从未完成检查点集合删除该检查点</li><li>再度向各个operator发出rpc，通知该检查点已完成</li></ul><p>本文里，收到这个远程调用的就是那两个operator chain，我们来看看其逻辑:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void notifyCheckpointComplete(long checkpointId) throws Exception &#123;</span><br><span class="line">synchronized (lock) &#123;</span><br><span class="line">if (isRunning) &#123;</span><br><span class="line">LOG.debug(&quot;Notification of complete checkpoint for task &#123;&#125;&quot;, getName());</span><br><span class="line"></span><br><span class="line">for (StreamOperator&lt;?&gt; operator : operatorChain.getAllOperators()) &#123;</span><br><span class="line">if (operator !&#x3D; null) &#123;</span><br><span class="line">operator.notifyCheckpointComplete(checkpointId);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">LOG.debug(&quot;Ignoring notification of complete checkpoint for not-running task &#123;&#125;&quot;, getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再接下来无非就是层层通知对应的算子做出响应罢了。</p><p>至此，flink的两阶段提交的checkpoint逻辑全部完成。</p><h3 id="5-3-承载checkpoint数据的抽象：State-amp-StateBackend"><a href="#5-3-承载checkpoint数据的抽象：State-amp-StateBackend" class="headerlink" title="5.3 承载checkpoint数据的抽象：State &amp; StateBackend"></a>5.3 承载checkpoint数据的抽象：State &amp; StateBackend</h3><p>State是快照数据的载体，StateBackend是快照如何被保存的抽象。</p><p>State分为 KeyedState和OperatorState，从名字就可以看出来分别对应着keyedStream和其他的oeprator。从State由谁管理上，也可以区分为raw state和Managed state。Flink管理的就是Managed state，用户自己管理的就是raw state。Managed State又分为ValueState、ListState、ReducingState、AggregatingState、FoldingState、MapState这么几种，看名字知用途。</p><p>StateBackend目前提供了三个backend，MemoryStateBackend，FsStateBackend，RocksDBStateBackend，都是看名字知用途系列。</p><p>State接口、StateBackend接口及其实现都比较简单，代码就不贴了， 尤其State本质上就是一层容器封装。</p><p>贴个别人写的状态管理的文章吧：<a href="https://yq.aliyun.com/articles/225623?spm=a2c4e.11153940.blogcont225624.12.7c797f6bZo3tiM">详解Flink中的状态管理</a></p><h2 id="6-数据流转——Flink的数据抽象及数据交换过程"><a href="#6-数据流转——Flink的数据抽象及数据交换过程" class="headerlink" title="6.数据流转——Flink的数据抽象及数据交换过程"></a>6.数据流转——Flink的数据抽象及数据交换过程</h2><p>本章打算讲一下flink底层是如何定义和在操作符之间传递数据的。</p><h3 id="6-1-flink的数据抽象"><a href="#6-1-flink的数据抽象" class="headerlink" title="6.1 flink的数据抽象"></a>6.1 flink的数据抽象</h3><h4 id="6-1-1-MemorySegment"><a href="#6-1-1-MemorySegment" class="headerlink" title="6.1.1 MemorySegment"></a>6.1.1 MemorySegment</h4><p>Flink作为一个高效的流框架，为了避免JVM的固有缺陷（java对象存储密度低，FGC影响吞吐和响应等），必然走上自主管理内存的道路。</p><p>这个<code>MemorySegment</code>就是Flink的内存抽象。默认情况下，一个MemorySegment可以被看做是一个32kb大的内存块的抽象。这块内存既可以是JVM里的一个byte[]，也可以是堆外内存（DirectByteBuffer）。</p><p>如果说byte[]数组和direct memory是最底层的存储，那么memorysegment就是在其上覆盖的一层统一抽象。它定义了一系列抽象方法，用于控制和底层内存的交互，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class MemorySegment &#123;</span><br><span class="line"></span><br><span class="line">    public abstract byte get(int index);</span><br><span class="line">    </span><br><span class="line">    public abstract void put(int index, byte b);</span><br><span class="line">    </span><br><span class="line">    public int size() ;</span><br><span class="line">    </span><br><span class="line">    public abstract ByteBuffer wrap(int offset, int length);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，它在提供了诸多直接操作内存的方法外，还提供了一个<code>wrap()</code>方法，将自己包装成一个ByteBuffer，我们待会儿讲这个ByteBuffer。</p><p>Flink为MemorySegment提供了两个实现类：<code>HeapMemorySegment</code>和<code>HybridMemorySegment</code>。他们的区别在于前者只能分配堆内存，而后者能用来分配堆内和堆外内存。事实上，Flink框架里，只使用了后者。这是为什么呢？</p><p>如果HybridMemorySegment只能用于分配堆外内存的话，似乎更合常理。但是在JVM的世界中，如果一个方法是一个虚方法，那么每次调用时，JVM都要花时间去确定调用的到底是哪个子类实现的该虚方法（方法重写机制，不明白的去看JVM的invokeVirtual指令），也就意味着每次都要去翻方法表；而如果该方法虽然是个虚方法，但实际上整个JVM里只有一个实现（就是说只加载了一个子类进来），那么JVM会很聪明的把它去虚化处理，这样就不用每次调用方法时去找方法表了，能够大大提升性能。但是只分配堆内或者堆外内存不能满足我们的需要，所以就出现了HybridMemorySegment同时可以分配两种内存的设计。</p><p>我们可以看看HybridMemorySegment的构造代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HybridMemorySegment(ByteBuffer buffer, Object owner) &#123;</span><br><span class="line">super(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);</span><br><span class="line">this.offHeapBuffer &#x3D; buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HybridMemorySegment(byte[] buffer, Object owner) &#123;</span><br><span class="line">super(buffer, owner);</span><br><span class="line">this.offHeapBuffer &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，第一个构造函数的<code>checkBufferAndGetAddress()</code>方法能够得到direct buffer的内存地址，因此可以操作堆外内存。</p><h4 id="6-1-2-ByteBuffer与NetworkBufferPool"><a href="#6-1-2-ByteBuffer与NetworkBufferPool" class="headerlink" title="6.1.2 ByteBuffer与NetworkBufferPool"></a>6.1.2 ByteBuffer与NetworkBufferPool</h4><p>在<code>MemorySegment</code>这个抽象之上，Flink在数据从operator内的数据对象在向TaskManager上转移，预备被发给下个节点的过程中，使用的抽象或者说内存对象是<code>Buffer</code>。</p><p><strong>注意</strong>，这个Buffer是个flink接口，不是java.nio提供的那个Buffer抽象类。Flink在这一层面同时使用了这两个同名概念，用来存储对象，直接看代码时到处都是各种xxxBuffer很容易混淆：</p><ul><li>java提供的那个Buffer抽象类在这一层主要用于构建<code>HeapByteBuffer</code>，这个主要是当数据从jvm里的一个对象被序列化成字节数组时用的；</li><li>Flink的这个Buffer接口主要是一种flink层面用于传输数据和事件的统一抽象，其实现类是<code>NetworkBuffer</code>，是对<code>MemorySegment</code>的包装。Flink在各个TaskManager之间传递数据时，使用的是这一层的抽象。</li></ul><p>因为Buffer的底层是MemorySegment，这可能不是JVM所管理的，所以为了知道什么时候一个Buffer用完了可以回收，Flink引入了引用计数的概念，当确认这个buffer没有人引用，就可以回收这一片MemorySegment用于别的地方了（JVM的垃圾回收为啥不用引用计数？读者思考一下）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf &#123;</span><br><span class="line"></span><br><span class="line">    private volatile int refCnt &#x3D; 1;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便管理<code>NetworkBuffer</code>，Flink提供了<code>BufferPoolFactory</code>，并且提供了唯一实现<code>NetworkBufferPool</code>，这是个工厂模式的应用。</p><p>NetworkBufferPool在每个TaskManager上只有一个，负责所有子task的内存管理。其实例化时就会尝试获取所有可由它管理的内存（对于堆内存来说，直接获取所有内存并放入老年代，并令用户对象只在新生代存活，可以极大程度的减少Full GC），我们看看其构造方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize) &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">this.availableMemorySegments &#x3D; new ArrayBlockingQueue&lt;&gt;(numberOfSegmentsToAllocate);</span><br><span class="line">&#125;</span><br><span class="line">catch (OutOfMemoryError err) &#123;</span><br><span class="line">throw new OutOfMemoryError(&quot;Could not allocate buffer queue of length &quot;</span><br><span class="line">+ numberOfSegmentsToAllocate + &quot; - &quot; + err.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; numberOfSegmentsToAllocate; i++) &#123;</span><br><span class="line">ByteBuffer memory &#x3D; ByteBuffer.allocateDirect(segmentSize);</span><br><span class="line">availableMemorySegments.add(MemorySegmentFactory.wrapPooledOffHeapMemory(memory, null));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">long allocatedMb &#x3D; (sizeInLong * availableMemorySegments.size()) &gt;&gt; 20;</span><br><span class="line"></span><br><span class="line">LOG.info(&quot;Allocated &#123;&#125; MB for network buffer pool (number of memory segments: &#123;&#125;, bytes per segment: &#123;&#125;).&quot;,</span><br><span class="line">allocatedMb, availableMemorySegments.size(), segmentSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于NetworkBufferPool只是个工厂，实际的内存池是<code>LocalBufferPool</code>。每个TaskManager都只有一个NetworkBufferPool工厂，但是上面运行的每个task都要有一个和其他task隔离的LocalBufferPool池，这从逻辑上很好理解。另外，NetworkBufferPool会计算自己所拥有的所有内存分片数，在分配新的内存池时对每个内存池应该占有的内存分片数重分配，步骤是：</p><ul><li>首先，从整个工厂管理的内存片中拿出所有的内存池所需要的最少Buffer数目总和</li><li>如果正好分配完，就结束</li><li>其次，把所有的剩下的没分配的内存片，按照每个LocalBufferPool内存池的剩余想要容量大小进行按比例分配</li><li>剩余想要容量大小是这么个东西：如果该内存池至少需要3个buffer，最大需要10个buffer，那么它的剩余想要容量就是7</li></ul><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   private void redistributeBuffers() throws IOException &#123;</span><br><span class="line">assert Thread.holdsLock(factoryLock);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All buffers, which are not among the required ones</span><br><span class="line">final int numAvailableMemorySegment &#x3D; totalNumberOfMemorySegments - numTotalRequiredBuffers;</span><br><span class="line"></span><br><span class="line">if (numAvailableMemorySegment &#x3D;&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F; in this case, we need to redistribute buffers so that every pool gets its minimum</span><br><span class="line">for (LocalBufferPool bufferPool : allBufferPools) &#123;</span><br><span class="line">bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long totalCapacity &#x3D; 0; &#x2F;&#x2F; long to avoid int overflow</span><br><span class="line"></span><br><span class="line">for (LocalBufferPool bufferPool : allBufferPools) &#123;</span><br><span class="line">int excessMax &#x3D; bufferPool.getMaxNumberOfMemorySegments() -</span><br><span class="line">bufferPool.getNumberOfRequiredMemorySegments();</span><br><span class="line">totalCapacity +&#x3D; Math.min(numAvailableMemorySegment, excessMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; no capacity to receive additional buffers?</span><br><span class="line">if (totalCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">return; &#x2F;&#x2F; necessary to avoid div by zero when nothing to re-distribute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final int memorySegmentsToDistribute &#x3D; MathUtils.checkedDownCast(</span><br><span class="line">Math.min(numAvailableMemorySegment, totalCapacity));</span><br><span class="line"></span><br><span class="line">long totalPartsUsed &#x3D; 0; &#x2F;&#x2F; of totalCapacity</span><br><span class="line">int numDistributedMemorySegment &#x3D; 0;</span><br><span class="line">for (LocalBufferPool bufferPool : allBufferPools) &#123;</span><br><span class="line">int excessMax &#x3D; bufferPool.getMaxNumberOfMemorySegments() -</span><br><span class="line">bufferPool.getNumberOfRequiredMemorySegments();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; shortcut</span><br><span class="line">if (excessMax &#x3D;&#x3D; 0) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">totalPartsUsed +&#x3D; Math.min(numAvailableMemorySegment, excessMax);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">final int mySize &#x3D; MathUtils.checkedDownCast(</span><br><span class="line">memorySegmentsToDistribute * totalPartsUsed &#x2F; totalCapacity - numDistributedMemorySegment);</span><br><span class="line"></span><br><span class="line">numDistributedMemorySegment +&#x3D; mySize;</span><br><span class="line">bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert (totalPartsUsed &#x3D;&#x3D; totalCapacity);</span><br><span class="line">assert (numDistributedMemorySegment &#x3D;&#x3D; memorySegmentsToDistribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来说说这个<code>LocalBufferPool</code>内存池。<br>LocalBufferPool的逻辑想想无非是<del>增删改查</del>，值得说的是其fields：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** 该内存池需要的最少内存片数目*&#x2F;</span><br><span class="line">private final int numberOfRequiredMemorySegments;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 当前已经获得的内存片中，还没有写入数据的空白内存片</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final ArrayDeque&lt;MemorySegment&gt; availableMemorySegments &#x3D; new ArrayDeque&lt;MemorySegment&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 注册的所有监控buffer可用性的监听器</span><br><span class="line"> *&#x2F;</span><br><span class="line">private final ArrayDeque&lt;BufferListener&gt; registeredListeners &#x3D; new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;** 能给内存池分配的最大分片数*&#x2F;</span><br><span class="line">private final int maxNumberOfMemorySegments;</span><br><span class="line"></span><br><span class="line">&#x2F;** 当前内存池大小 *&#x2F;</span><br><span class="line">private int currentPoolSize;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 所有经由NetworkBufferPool分配的，被本内存池引用到的（非直接获得的）分片数</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int numberOfRequestedMemorySegments;</span><br></pre></td></tr></table></figure><p>承接NetworkBufferPool的重分配方法，我们来看看LocalBufferPool的<code>setNumBuffers()</code>方法，代码很短，逻辑也相当简单，就不展开说了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setNumBuffers(int numBuffers) throws IOException &#123;</span><br><span class="line">synchronized (availableMemorySegments) &#123;</span><br><span class="line">checkArgument(numBuffers &gt;&#x3D; numberOfRequiredMemorySegments,</span><br><span class="line">&quot;Buffer pool needs at least %s buffers, but tried to set to %s&quot;,</span><br><span class="line">numberOfRequiredMemorySegments, numBuffers);</span><br><span class="line"></span><br><span class="line">if (numBuffers &gt; maxNumberOfMemorySegments) &#123;</span><br><span class="line">currentPoolSize &#x3D; maxNumberOfMemorySegments;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">currentPoolSize &#x3D; numBuffers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnExcessMemorySegments();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; If there is a registered owner and we have still requested more buffers than our</span><br><span class="line">&#x2F;&#x2F; size, trigger a recycle via the owner.</span><br><span class="line">if (owner !&#x3D; null &amp;&amp; numberOfRequestedMemorySegments &gt; currentPoolSize) &#123;</span><br><span class="line">owner.releaseMemory(numberOfRequestedMemorySegments - numBuffers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-3-RecordWriter与Record"><a href="#6-1-3-RecordWriter与Record" class="headerlink" title="6.1.3 RecordWriter与Record"></a>6.1.3 RecordWriter与Record</h4><p>我们接着往高层抽象走，刚刚提到了最底层内存抽象是MemorySegment，用于数据传输的是Buffer，那么，承上启下对接从Java对象转为Buffer的中间对象是什么呢？是<code>StreamRecord</code>。</p><p>从<code>StreamRecord&lt;T&gt;</code>这个类名字就可以看出来，这个类就是个wrap，里面保存了原始的Java对象。另外，StreamRecord还保存了一个timestamp。</p><p>那么这个对象是怎么变成LocalBufferPool内存池里的一个大号字节数组的呢？借助了<code>StreamWriter</code>这个类。</p><p>我们直接来看把数据序列化交出去的方法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void sendToTarget(T record, int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line">RecordSerializer&lt;T&gt; serializer &#x3D; serializers[targetChannel];</span><br><span class="line"></span><br><span class="line">SerializationResult result &#x3D; serializer.addRecord(record);</span><br><span class="line"></span><br><span class="line">while (result.isFullBuffer()) &#123;</span><br><span class="line">if (tryFinishCurrentBufferBuilder(targetChannel, serializer)) &#123;</span><br><span class="line">&#x2F;&#x2F; If this was a full record, we are done. Not breaking</span><br><span class="line">&#x2F;&#x2F; out of the loop at this point will lead to another</span><br><span class="line">&#x2F;&#x2F; buffer request before breaking out (that would not be</span><br><span class="line">&#x2F;&#x2F; a problem per se, but it can lead to stalls in the</span><br><span class="line">&#x2F;&#x2F; pipeline).</span><br><span class="line">if (result.isFullRecord()) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BufferBuilder bufferBuilder &#x3D; requestNewBufferBuilder(targetChannel);</span><br><span class="line"></span><br><span class="line">result &#x3D; serializer.continueWritingWithNextBufferBuilder(bufferBuilder);</span><br><span class="line">&#125;</span><br><span class="line">checkState(!serializer.hasSerializedData(), &quot;All data should be written at once&quot;);</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">if (flushAlways) &#123;</span><br><span class="line">targetPartition.flush(targetChannel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说最后一行，如果配置为flushAlways，那么会立刻把元素发送出去，但是这样吞吐量会下降；Flink的默认设置其实也不是一个元素一个元素的发送，是单独起了一个线程，每隔固定时间flush一次所有channel，较真起来也算是mini batch了。</p><p>再说序列化那一句:<code>SerializationResult result = serializer.addRecord(record);</code>。在这行代码中，Flink把对象调用该对象所属的序列化器序列化为字节数组。</p><h3 id="6-2-数据流转过程"><a href="#6-2-数据流转过程" class="headerlink" title="6.2 数据流转过程"></a>6.2 数据流转过程</h3><p>上一节讲了各层数据的抽象，这一节讲讲数据在各个task之间exchange的过程。</p><h4 id="6-2-1-整体过程"><a href="#6-2-1-整体过程" class="headerlink" title="6.2.1 整体过程"></a>6.2.1 整体过程</h4><p>看这张图：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/e5m0ggy1t6z8tjgfn52cr31r/image_1cetavukjja42ce1261v5k57i9.png" alt="image_1cetavukjja42ce1261v5k57i9.png-821.8kB"></p><ol><li>第一步必然是准备一个ResultPartition；</li><li>通知JobMaster；</li><li>JobMaster通知下游节点；如果下游节点尚未部署，则部署之；</li><li>下游节点向上游请求数据</li><li>开始传输数据</li></ol><h4 id="6-2-2-数据跨task传递"><a href="#6-2-2-数据跨task传递" class="headerlink" title="6.2.2 数据跨task传递"></a>6.2.2 数据跨task传递</h4><p>本节讲一下算子之间具体的数据传输过程。也先上一张图：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/d9pmni04fg8i11xotv4xqxh7/image_1cfmpba9v15anggtvsba2o1277m.png" alt="image_1cfmpba9v15anggtvsba2o1277m.png-357.5kB"><br>数据在task之间传递有如下几步：</p><ol><li>数据在本operator处理完后，交给<code>RecordWriter</code>。每条记录都要选择一个下游节点，所以要经过<code>ChannelSelector</code>。</li><li>每个channel都有一个serializer（我认为这应该是为了避免多线程写的麻烦），把这条Record序列化为ByteBuffer</li><li>接下来数据被写入ResultPartition下的各个subPartition里，此时该数据已经存入DirectBuffer（MemorySegment）</li><li>单独的线程控制数据的flush速度，一旦触发flush，则通过Netty的nio通道向对端写入</li><li>对端的netty client接收到数据，decode出来，把数据拷贝到buffer里，然后通知<code>InputChannel</code></li><li>有可用的数据时，下游算子从阻塞醒来，从InputChannel取出buffer，再解序列化成record，交给算子执行用户代码</li></ol><p>数据在不同机器的算子之间传递的步骤就是以上这些。</p><p>了解了步骤之后，再来看一下部分关键代码：<br>首先是把数据交给recordwriter。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;RecordWriterOutput.java</span><br><span class="line">@Override</span><br><span class="line">public void collect(StreamRecord&lt;OUT&gt; record) &#123;</span><br><span class="line">if (this.outputTag !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; we are only responsible for emitting to the main input</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">       &#x2F;&#x2F;这里可以看到把记录交给了recordwriter</span><br><span class="line">pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后recordwriter把数据发送到对应的通道。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;RecordWriter.java</span><br><span class="line">public void emit(T record) throws IOException, InterruptedException &#123;</span><br><span class="line">    &#x2F;&#x2F;channelselector登场了</span><br><span class="line">for (int targetChannel : channelSelector.selectChannels(record, numChannels)) &#123;</span><br><span class="line">sendToTarget(record, targetChannel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void sendToTarget(T record, int targetChannel) throws IOException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;选择序列化器并序列化数据</span><br><span class="line">RecordSerializer&lt;T&gt; serializer &#x3D; serializers[targetChannel];</span><br><span class="line"></span><br><span class="line">SerializationResult result &#x3D; serializer.addRecord(record);</span><br><span class="line"></span><br><span class="line">while (result.isFullBuffer()) &#123;</span><br><span class="line">if (tryFinishCurrentBufferBuilder(targetChannel, serializer)) &#123;</span><br><span class="line">&#x2F;&#x2F; If this was a full record, we are done. Not breaking</span><br><span class="line">&#x2F;&#x2F; out of the loop at this point will lead to another</span><br><span class="line">&#x2F;&#x2F; buffer request before breaking out (that would not be</span><br><span class="line">&#x2F;&#x2F; a problem per se, but it can lead to stalls in the</span><br><span class="line">&#x2F;&#x2F; pipeline).</span><br><span class="line">if (result.isFullRecord()) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BufferBuilder bufferBuilder &#x3D; requestNewBufferBuilder(targetChannel);</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F;写入channel</span><br><span class="line">result &#x3D; serializer.continueWritingWithNextBufferBuilder(bufferBuilder);</span><br><span class="line">&#125;</span><br><span class="line">checkState(!serializer.hasSerializedData(), &quot;All data should be written at once&quot;);</span><br><span class="line"></span><br><span class="line">if (flushAlways) &#123;</span><br><span class="line">targetPartition.flush(targetChannel);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是把数据推给底层设施（netty）的过程：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;ResultPartition.java</span><br><span class="line">@Override</span><br><span class="line">public void flushAll() &#123;</span><br><span class="line">for (ResultSubpartition subpartition : subpartitions) &#123;</span><br><span class="line">subpartition.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;PartitionRequestQueue.java</span><br><span class="line">void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) &#123;</span><br><span class="line">&#x2F;&#x2F;这里交给了netty server线程去推</span><br><span class="line">ctx.executor().execute(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">ctx.pipeline().fireUserEventTriggered(reader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty相关的部分：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;AbstractChannelHandlerContext.java</span><br><span class="line">public ChannelHandlerContext fireUserEventTriggered(final Object event) &#123;</span><br><span class="line">    if (event &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;event&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final AbstractChannelHandlerContext next &#x3D; this.findContextInbound();</span><br><span class="line">        EventExecutor executor &#x3D; next.executor();</span><br><span class="line">        if (executor.inEventLoop()) &#123;</span><br><span class="line">            next.invokeUserEventTriggered(event);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            executor.execute(new OneTimeTask() &#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    next.invokeUserEventTriggered(event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后真实的写入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;PartittionRequesetQueue.java</span><br><span class="line">private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception &#123;</span><br><span class="line">if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Queue an available reader for consumption. If the queue is empty,</span><br><span class="line">&#x2F;&#x2F; we try trigger the actual write. Otherwise this will be handled by</span><br><span class="line">&#x2F;&#x2F; the writeAndFlushNextMessageIfPossible calls.</span><br><span class="line">boolean triggerWrite &#x3D; availableReaders.isEmpty();</span><br><span class="line">registerAvailableReader(reader);</span><br><span class="line"></span><br><span class="line">if (triggerWrite) &#123;</span><br><span class="line">writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">next &#x3D; reader.getNextBuffer();</span><br><span class="line">if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">if (!reader.isReleased()) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">markAsReleased(reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">Throwable cause &#x3D; reader.getFailureCause();</span><br><span class="line">if (cause !&#x3D; null) &#123;</span><br><span class="line">ErrorResponse msg &#x3D; new ErrorResponse(</span><br><span class="line">new ProducerFailedException(cause),</span><br><span class="line">reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">ctx.writeAndFlush(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; This channel was now removed from the available reader queue.</span><br><span class="line">&#x2F;&#x2F; We re-add it into the queue if it is still available</span><br><span class="line">if (next.moreAvailable()) &#123;</span><br><span class="line">registerAvailableReader(reader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BufferResponse msg &#x3D; new BufferResponse(</span><br><span class="line">next.buffer(),</span><br><span class="line">reader.getSequenceNumber(),</span><br><span class="line">reader.getReceiverId(),</span><br><span class="line">next.buffersInBacklog());</span><br><span class="line"></span><br><span class="line">if (isEndOfPartitionEvent(next.buffer())) &#123;</span><br><span class="line">reader.notifySubpartitionConsumed();</span><br><span class="line">reader.releaseAllResources();</span><br><span class="line"></span><br><span class="line">markAsReleased(reader.getReceiverId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Write and flush and wait until this is done before</span><br><span class="line">&#x2F;&#x2F; trying to continue with the next buffer.</span><br><span class="line">channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码里第二个方法中调用的<code>writeAndFlush(msg)</code>就是真正往netty的nio通道里写入的地方了。在这里，写入的是一个RemoteInputChannel，对应的就是下游节点的InputGate的channels。</p><p>有写就有读，nio通道的另一端需要读入buffer，代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;CreditBasedPartitionRequestClientHandler.java</span><br><span class="line">private void decodeMsg(Object msg) throws Throwable &#123;</span><br><span class="line">final Class&lt;?&gt; msgClazz &#x3D; msg.getClass();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ---- Buffer --------------------------------------------------------</span><br><span class="line">if (msgClazz &#x3D;&#x3D; NettyMessage.BufferResponse.class) &#123;</span><br><span class="line">NettyMessage.BufferResponse bufferOrEvent &#x3D; (NettyMessage.BufferResponse) msg;</span><br><span class="line"></span><br><span class="line">RemoteInputChannel inputChannel &#x3D; inputChannels.get(bufferOrEvent.receiverId);</span><br><span class="line">if (inputChannel &#x3D;&#x3D; null) &#123;</span><br><span class="line">bufferOrEvent.releaseBuffer();</span><br><span class="line"></span><br><span class="line">cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decodeBufferOrEvent(inputChannel, bufferOrEvent);</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插一句，Flink其实做阻塞和获取数据的方式非常自然，利用了生产者和消费者模型，当获取不到数据时，消费者自然阻塞；当数据被加入队列，消费者被notify。Flink的背压机制也是借此实现。</p><p>然后在这里又反序列化成<code>StreamRecord</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   &#x2F;&#x2F;StreamElementSerializer.java</span><br><span class="line">public StreamElement deserialize(DataInputView source) throws IOException &#123;</span><br><span class="line">int tag &#x3D; source.readByte();</span><br><span class="line">if (tag &#x3D;&#x3D; TAG_REC_WITH_TIMESTAMP) &#123;</span><br><span class="line">long timestamp &#x3D; source.readLong();</span><br><span class="line">return new StreamRecord&lt;T&gt;(typeSerializer.deserialize(source), timestamp);</span><br><span class="line">&#125;</span><br><span class="line">else if (tag &#x3D;&#x3D; TAG_REC_WITHOUT_TIMESTAMP) &#123;</span><br><span class="line">return new StreamRecord&lt;T&gt;(typeSerializer.deserialize(source));</span><br><span class="line">&#125;</span><br><span class="line">else if (tag &#x3D;&#x3D; TAG_WATERMARK) &#123;</span><br><span class="line">return new Watermark(source.readLong());</span><br><span class="line">&#125;</span><br><span class="line">else if (tag &#x3D;&#x3D; TAG_STREAM_STATUS) &#123;</span><br><span class="line">return new StreamStatus(source.readInt());</span><br><span class="line">&#125;</span><br><span class="line">else if (tag &#x3D;&#x3D; TAG_LATENCY_MARKER) &#123;</span><br><span class="line">return new LatencyMarker(source.readLong(), new OperatorID(source.readLong(), source.readLong()), source.readInt());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">throw new IOException(&quot;Corrupt stream, found tag: &quot; + tag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再次在<code>StreamInputProcessor.processInput()</code>循环中得到处理。</p><p>至此，数据在跨jvm的节点之间的流转过程就讲完了。</p><h3 id="6-3-Credit漫谈"><a href="#6-3-Credit漫谈" class="headerlink" title="6.3 Credit漫谈"></a>6.3 Credit漫谈</h3><p>在看上一部分的代码时，有一个小细节不知道读者有没有注意到，我们的数据发送端的代码叫做<code>PartittionRequesetQueue.java</code>，而我们的接收端却起了一个完全不相干的名字：<code>CreditBasedPartitionRequestClientHandler.java</code>。为什么前面加了CreditBased的前缀呢？</p><h4 id="6-3-1-背压问题"><a href="#6-3-1-背压问题" class="headerlink" title="6.3.1 背压问题"></a>6.3.1 背压问题</h4><p>在流模型中，我们期待数据是像水流一样平滑的流过我们的引擎，但现实生活不会这么美好。数据的上游可能因为各种原因数据量暴增，远远超出了下游的瞬时处理能力（回忆一下98年大洪水），导致系统崩溃。<br>那么框架应该怎么应对呢？和人类处理自然灾害的方式类似，我们修建了三峡大坝，当洪水来临时把大量的水囤积在大坝里；对于Flink来说，就是在数据的接收端和发送端放置了缓存池，用以缓冲数据，并且设置闸门阻止数据向下流。</p><p>那么Flink又是如何处理背压的呢？答案也是靠这些缓冲池。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/1r40q9nbeuxh4j0omiic5tob/image_1cfksrl5cd4m1lbqqqgvc811349.png" alt="image_1cfksrl5cd4m1lbqqqgvc811349.png-43.1kB"><br>这张图说明了Flink在生产和消费数据时的大致情况。<code>ResultPartition</code>和<code>InputGate</code>在输出和输入数据时，都要向<code>NetworkBufferPool</code>申请一块<code>MemorySegment</code>作为缓存池。<br>接下来的情况和生产者消费者很类似。当数据发送太多，下游处理不过来了，那么首先InputChannel会被填满，然后是InputChannel能申请到的内存达到最大，于是下游停止读取数据，上游负责发送数据的nettyServer会得到响应，停止从ResultSubPartition读取缓存，那么ResultPartition很快也将存满数据不能被消费，从而生产数据的逻辑被阻塞在获取新buffer上，非常自然地形成背压的效果。</p><p>Flink自己做了个试验用以说明这个机制的效果：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/xxqpmehf1w4un8leyc9itr9y/image_1cfkta54rkdd1od4aau1e3n7nhm.png" alt="image_1cfkta54rkdd1od4aau1e3n7nhm.png-240.6kB"><br>我们首先设置生产者的发送速度为60%，然后下游的算子以同样的速度处理数据。然后我们将下游算子的处理速度降低到30%，可以看到上游的生产者的数据产生曲线几乎与消费者同步下滑。而后当我们解除限速，整个流的速度立刻提高到了100%。</p><h4 id="6-3-2-使用Credit实现ATM网络流控"><a href="#6-3-2-使用Credit实现ATM网络流控" class="headerlink" title="6.3.2 使用Credit实现ATM网络流控"></a>6.3.2 使用Credit实现ATM网络流控</h4><p>上文已经提到，对于流量控制，一个朴素的思路就是在<del>长江上建三峡</del>链路上建立一个拦截的dam，如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/1wc3o2qo6ozsyxqebnn2xw0j/image_1cfku114lf7hpqf3lmcl0116c13.png" alt="image_1cfku114lf7hpqf3lmcl0116c13.png-22.7kB"><br>基于Credit的流控就是这样一种建立在信用（消费数据的能力)上的，面向每个虚链路（而非端到端的）流模型，如下图所示：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/on4kd4bzvoozbo6yk6n2but6/image_1cfku4g4g174d7gb5ecbfcib71g.png" alt="image_1cfku4g4g174d7gb5ecbfcib71g.png-22.5kB"><br>首先，下游会向上游发送一条credit message，用以通知其目前的信用（可联想信用卡的可用额度），然后上游会根据这个信用消息来决定向下游发送多少数据。当上游把数据发送给下游时，它就从下游的信用卡上划走相应的额度（credit balance）：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/i8t1qvlib162x1i6lm0qruju/image_1cfkug5sm1v4l15pbgj4jntc7q1t.png" alt="image_1cfkug5sm1v4l15pbgj4jntc7q1t.png-12.9kB"><br>下游总共获得的credit数目是Buf_Alloc，已经消费的数据是Fwd_Cnt，上游发送出来的数据是Tx_Cnt，那么剩下的那部分就是Crd_Bal:<br>Crd_Bal = Buf_Alloc - ( Tx_Cnt - Fwd_Cnt )<br>上面这个式子应该很好理解。</p><p>可以看到，Credit Based Flow Control的关键是buffer分配。这种分配可以在数据的发送端完成，也可以在接收端完成。对于下游可能有多个上游节点的情况（比如Flink），使用接收端的credit分配更加合理：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/o09mav0lfnk7iqar98iphr7o/image_1cfkvpmlh1gl31ef41cvh1c903a19.png" alt="image_1cfkvpmlh1gl31ef41cvh1c903a19.png-13.1kB"><br>上图中，接收者可以观察到每个上游连接的带宽情况，而上游的节点Snd1却不可能轻易知道发往同一个下游节点的其他Snd2的带宽情况，从而如果在上游控制流量将会很困难，而在下游控制流量将会很方便。</p><p>因此，这就是为何Flink在接收端有一个基于Credit的Client，而不是在发送端有一个CreditServer的原因。</p><p>最后，再讲一下Credit的面向虚链路的流设计和端到端的流设计的区别：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/1mm2eqnuop9rcccap915qrzx/image_1cfl05d2f1ub879c1lc5qsq14n9m.png" alt="image_1cfl05d2f1ub879c1lc5qsq14n9m.png-13.4kB"><br>如上图所示，a是面向连接的流设计，b是端到端的流设计。其中，a的设计使得当下游节点3因某些情况必须缓存数据暂缓处理时，每个上游节点（1和2）都可以利用其缓存保存数据；而端到端的设计b里，只有节点3的缓存才可以用于保存数据（读者可以从如何实现上想想为什么）。</p><p>对流控制感兴趣的读者，可以看这篇文章：<a href="https://www.nap.edu/read/5769/chapter/1">Traffic Management For High-Speed Networks</a>。</p><h2 id="7-其他核心概念"><a href="#7-其他核心概念" class="headerlink" title="7.其他核心概念"></a>7.其他核心概念</h2><p>截至第六章，和执行过程相关的部分就全部讲完，告一段落了。第七章主要讲一点杂七杂八的内容，有时间就不定期更新。</p><h3 id="7-1-EventTime时间模型"><a href="#7-1-EventTime时间模型" class="headerlink" title="7.1 EventTime时间模型"></a>7.1 EventTime时间模型</h3><p>flink有三种时间模型：ProcessingTime，EventTime和IngestionTime。<br>关于时间模型看这张图：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/kcp52h1se5xzocfqcigcv9oh/image_1cdbotdcmoe11q961st5lbn1j4n9.png" alt="image_1cdbotdcmoe11q961st5lbn1j4n9.png-38.4kB"><br>从这张图里可以很清楚的看到三种Time模型的区别。</p><ul><li>EventTime是数据被生产出来的时间，可以是比如传感器发出信号的时间等（此时数据还没有被传输给flink）。</li><li>IngestionTime是数据进入flink的时间，也就是从Source进入flink流的时间（此时数据刚刚被传给flink）</li><li>ProcessingTime是针对当前算子的系统时间，是指该数据已经进入某个operator时，operator所在系统的当前时间</li></ul><p>例如，我在写这段话的时间是2018年5月13日03点47分，但是我引用的这张EventTime的图片，是2015年画出来的，那么这张图的EventTime是2015年，而ProcessingTime是现在。<br>Flink官网对于时间戳的解释非常详细：<a href="https://ci.apache.org/projects/flink/flink-docs-master/dev/event_time.html">点我</a><br>Flink对于EventTime模型的实现，依赖的是一种叫做<code>watermark</code>的对象。watermark是携带有时间戳的一个对象，会按照程序的要求被插入到数据流中，用以标志某个事件在该时间发生了。<br>我再做一点简短的说明，还是以官网的图为例：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/f4k8110qo8arjey5zbp75xz3/image_1cdbt8v5jl2ujn91uu1joh1p4gm.png" alt="image_1cdbt8v5jl2ujn91uu1joh1p4gm.png-11.3kB"><br>对于有序到来的数据，假设我们在timestamp为11的元素后加入一个watermark，时间记录为11，则下个元素收到该watermark时，认为所有早于11的元素均已到达。这是非常理想的情况。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/3aqwmrc5hg054b09z47lwsvp/image_1cdbtcc5c1a6i1tuaadb1rd5136913.png" alt="image_1cdbtcc5c1a6i1tuaadb1rd5136913.png-11.6kB"><br>而在现实生活中，经常会遇到乱序的数据。这时，我们虽然在timestamp为7的元素后就收到了11，但是我们一直等到了收到元素12之后，才插入了watermark为11的元素。与上面的图相比，如果我们仍然在11后就插入11的watermark，那么元素9就会被丢弃，造成数据丢失。而我们在12之后插入watermark11，就保证了9仍然会被下一个operator处理。当然，我们不可能无限制的永远等待迟到元素，所以要在哪个元素后插入11需要根据实际场景权衡。</p><p>对于来自多个数据源的watermark，可以看这张图：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/pu1cr48mq9340g5embaig9b5/image_1cdbufp4a1opmsit5n61mial4520.png" alt="image_1cdbufp4a1opmsit5n61mial4520.png-72kB"><br>可以看到，当一个operator收到多个watermark时，它遵循最小原则（或者说最早），即算子的当前watermark是流经该算子的最小watermark，以容许来自不同的source的乱序数据到来。<br>关于事件时间模型，更多内容可以参考<a href="https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101">Stream 101</a> 和谷歌的这篇论文：<a href="https://research.google.com/pubs/archive/43864.pdf">Dataflow Model paper</a></p><h3 id="7-2-FLIP-6-部署及处理模型演进"><a href="#7-2-FLIP-6-部署及处理模型演进" class="headerlink" title="7.2 FLIP-6 部署及处理模型演进"></a>7.2 FLIP-6 部署及处理模型演进</h3><p>就在老白写这篇blog的时候，Flink发布了其1.5 RELEASE版本，号称实现了其部署及处理模型（也就是FLIP-6)，所以打算简略地说一下FLIP-6的主要内容。</p><h4 id="7-2-1-现有模型不足"><a href="#7-2-1-现有模型不足" class="headerlink" title="7.2.1 现有模型不足"></a>7.2.1 现有模型不足</h4><p>1.5之前的Flink模型有很多不足，包括：</p><ul><li>只能静态分配计算资源</li><li>在YARN上所有的资源分配都是一碗水端平的</li><li>与Docker/k8s的集成非常之蠢，颇有脱裤子放屁的神韵</li><li>JobManager没有任务调度逻辑</li><li>任务在YARN上执行结束后web dashboard就不可用</li><li>集群的session模式和per job模式混淆难以理解</li></ul><p>就我个人而言，我觉得Flink有一个这里完全没提到的不足才是最应该修改的：针对任务的完全的资源隔离。尤其是如果用Standalone集群，一个用户的task跑挂了TaskManager，然后拖垮了整个集群的情况简直不要太多。</p><h4 id="7-2-2-核心变更"><a href="#7-2-2-核心变更" class="headerlink" title="7.2.2 核心变更"></a>7.2.2 核心变更</h4><p><strong>Single Job JobManager</strong><br>最重要的变更是一个JobManager只处理一个job。当我们生成JobGraph时就顺便起一个JobManager，这显然更加自然。</p><p><strong>ResourceManager</strong><br>其职责包括获取新的TM和slot，通知失败，释放资源以及缓存TM以用于重用等。重要的是，这个组件要能做到挂掉时不要搞垮正在运行的好好的任务。其职责和与JobManager、TaskManager的交互图如下：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/pzuvevivascmk2xky450ll87/image_1cfl9453k1gld4acr1m13j3195sg.png" alt="image_1cfl9453k1gld4acr1m13j3195sg.png-23.9kB"></p><p><strong>TaskManager</strong><br>TM要与上面的两个组件交互。与JobManager交互时，要能提供slot，要能与所有给出slot的JM交互。丢失与JM的连接时要能试图把本TM上的slot的情况通告给新JM，如果这一步失败，就要能重新分配slot。<br>与ResourceManager交互时，要通知RM自己的资源和当前的Job分配情况，能按照RM的要求分配资源或者关闭自身。</p><p><strong>JobManager Slot Pool</strong><br>这个pool要持有所有分配给当前job的slot资源，并且能在RM挂掉的情况下管理当前已经持有的slot。</p><p><strong>Dispatcher</strong><br>需要一个Job的分发器的主要原因是在有的集群环境下我们可能需要一个统一的提交和监控点，以及替代之前的Standalone模式下的JobManager。将来对分发器的期望可能包括权限控制等。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/on7x5expzpyvtyqvkjm1si9e/image_1cfl9ju2617bh1s191mar1jsp12vot.png" alt="image_1cfl9ju2617bh1s191mar1jsp12vot.png-31.4kB"></p><h4 id="7-2-3-Cluster-Manager的架构"><a href="#7-2-3-Cluster-Manager的架构" class="headerlink" title="7.2.3 Cluster Manager的架构"></a>7.2.3 Cluster Manager的架构</h4><p><strong>YARN</strong><br>新的基于YARN的架构主要包括不再需要先在容器里启动集群，然后提交任务；用户代码不再使用动态ClassLoader加载；不用的资源可以释放；可以按需分配不同大小的容器等。其执行过程如下：<br>无Dispatcher时<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/w3z5qz98tq5q4jtndka8kdhp/image_1cfla0n7u1lg21n3o36uu0c1o5h1a.png" alt="image_1cfla0n7u1lg21n3o36uu0c1o5h1a.png-46.2kB"><br>有Dispatcher时<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/ukhd6f3480du2nsx2wnl56g3/image_1cfla15os15i3qcsu6c4p4clk1n.png" alt="image_1cfla15os15i3qcsu6c4p4clk1n.png-50.7kB"></p><p><strong>Mesos</strong><br>与基于YARN的模式很像，但是只有带Dispatcher模式，因为只有这样才能在Mesos集群里跑其RM。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/k0b95bqzs9crsj2jwk8oy33n/image_1cfla4tka101n18bf1mno4npu9s24.png" alt="image_1cfla4tka101n18bf1mno4npu9s24.png-49.2kB"><br>Mesos的Fault Tolerance是类似这样的：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/app8m86al53shk2a83w14x0r/image_1cfla6eka1ph71mu1pll1q0mgqq2h.png" alt="image_1cfla6eka1ph71mu1pll1q0mgqq2h.png-12.1kB"><br>必须用类似Marathon之类的技术保证Dispatcher的HA。</p><p><strong>Standalone</strong><br>其实没啥可说的，把以前的JobManager的职责换成现在的Dispatcher就行了。<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/nn4vbn25yojf3vq80yffr20v/image_1cflaaim2ih2v54umsmq01lqc2u.png" alt="image_1cflaaim2ih2v54umsmq01lqc2u.png-36.8kB"><br>将来可能会实现一个类似于轻量级Yarn的模式。</p><p><strong>Docker/k8s</strong><br>用户定义好容器，至少有一个是job specific的（不然怎么启动任务）；还有用于启动TM的，可以不是job specific的。启动过程如下<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/vcow51koxy17wd3qxj60y4lj/image_1cflafs2o1trgicjmdbndn1bdq3b.png" alt="image_1cflafs2o1trgicjmdbndn1bdq3b.png-24.2kB"></p><h4 id="7-2-4-组件设计及细节"><a href="#7-2-4-组件设计及细节" class="headerlink" title="7.2.4 组件设计及细节"></a>7.2.4 组件设计及细节</h4><p><strong>分配slot相关细节</strong><br>从新的TM取slot过程：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/r1anoecf2er16nuh3h9r9jb8/image_1cflakoadvjm8pf6nt1k331qj33o.png" alt="image_1cflakoadvjm8pf6nt1k331qj33o.png-77.2kB"></p><p>从Cached TM取slot过程：<br><img src= "/img/loading.gif" data-lazy-src="http://static.zybuluo.com/bethunebtj/2uyr1ynvj8ieqi8rth8h8bub/image_1cflambu91ufi5fl1cg9gimdff45.png" alt="image_1cflambu91ufi5fl1cg9gimdff45.png-63.4kB"></p><p><strong>失败处理</strong></p><ol><li><p>TM失败<br>TM失败时，RM要能检测到失败，更新自己的状态，发送消息给JM，重启一份TM；JM要能检测到失败，从状态移除失效slot，标记该TM的task为失败，并在没有足够slot继续任务时调整规模；TM自身则要能从Checkpoint恢复</p></li><li><p>RM失败<br>此时TM要能检测到失败，并准备向新的RM注册自身，并且向新的RM传递自身的资源情况；JM要能检测到失败并且等待新的RM可用，重新请求需要的资源；丢失的数据要能从Container、TM等处恢复。</p></li><li><p>JM失败<br>TM释放所有task，向新JM注册资源，并且如果不成功，就向RM报告这些资源可用于重分配；RM坐等；JM丢失的数据从持久化存储中获得，已完成的checkpoints从HA恢复，从最近的checkpoint重启task，并申请资源。</p></li><li><p>JM &amp; RM 失败<br>TM将在一段时间内试图把资源交给新上任的JM，如果失败，则把资源交给新的RM</p></li><li><p>TM &amp; RM失败<br>JM如果正在申请资源，则要等到新的RM启动后才能获得；JM可能需要调整其规模，因为损失了TM的slot。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CockroachDB分布式事务解析</title>
      <link href="posts/9458b181.html"/>
      <url>posts/9458b181.html</url>
      
        <content type="html"><![CDATA[<h1 id="事务层"><a href="#事务层" class="headerlink" title="事务层"></a>事务层</h1><p>事务层实现了对并发操作的ACID事务支持。</p><ul><li><p>CRDB事务分为两个阶段：</p><ul><li>write &amp; reads，即事务执行阶段，当进行写操作时，CRDB并不会直接对硬盘的数据进行修改，而是使用另外两个东西来进行辅助，这两个东西也避免了锁的使用：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/cockroach/txn/transaction-execution-process.png" alt="transaction-execution-process.png"></li><li>Transaction record，存储在range第一个被修改的key处，表明了修改当前key的事务所处的状态：PENDING，COMMITTED或者ABORTED。第一个状态表示事务正在进行；第二个状态表示事务已经提交；第三个表示事务已经丢弃，正在进行重试或者rollback。</li></ul></li><li><p>Write intents，对数据的修改写在这里，此外还带一个指向transaction record的指针，来表明这些数据当前或者之前被一个事务修改过，其他事务根据这个状态来决定对这些数据的下一步操作。产生一个新的write intent前需要检查这一块数据有没有更晚时间戳的提交值，如果有的话该事务需要被重新开始。</p></li></ul><p>当进行读操作时，会检查所读的每块数据的write intent，如果不存在，那么直接读以前的mvcc数据就行了，如果有write intent，那么需要判断intent的状态，根据状态做出下一步操作。</p><ul><li><p>Commit，提交阶段，如果事务执行阶段没有问题，那么事务就可以直接进行提交，如果中途出现问题就会abort，然后进行重试或者rollback。</p></li><li><p>Cleanup，这个阶段不属于事务中，主要是用来解决事务中产生的write intent。intent并不是事务结束后就立即进行处理，而是异步处理，当有新的read或者write操作这一块数据的时候会发现这些intent，这时候如果状态是commit，那么就会把intent指向record的指针删除将其变成普通的mvcc数据，如果是aborted，那么直接将intent删除。</p></li></ul><p><strong>Detailed design ：</strong></p><p>每个事务在协调节点开始时都会有一个candidate timestamp，如果事务中途执行过程中不改变，那么这个就是mvcc中用来标志事务的timestamp，当隔离等级为snapshot时，中途可能会push事务的timestamp，从而改变candidate timestamp，最后提交的时候多个node的timestamp可能会不一致，这时候取最大的那个。 timestamp由HLC产生，hlc由物理时钟和逻辑时钟组成。物理时钟l.j是每个node的本地wall time由NTP产生，逻辑时钟c.j初始值为0，每当碰到相同的物理时间时会将其中一个逻辑时钟加一从而形成区别，因而比较hlc时间时首先比较物理时钟然后比较逻辑时钟。每当有一个event的时候hlc的时间都会更新：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">l<span class="string">&#x27;.j = l.j; // 跟当前系统时间比较，得到pt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">l.j = max(l&#x27;</span>.j, pt.j) <span class="comment">// 如果pt没有变化，则c.j加1，如果有变化，因为这时候</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 铁定PT变大了，所以我们可以将ct清零</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (l.j = l<span class="string">&#x27;.j)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123; c.j = c.j + 1 &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">else &#123; c.j = 0 &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Timestamp with l.j, c.j</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">当有一个本地event发生时，会比较当前hlc的物理时间跟系统的物理时间，取其中最大的，如果相等的话则将逻辑时间加一。为了减少节点间的时间偏移，每当其他node的event到来的时候也会更新hlc时间：</span><br><span class="line">  l<span class="string">&#x27;.j = l.j;</span></span><br><span class="line"><span class="string">// 跟当前系统事件以及节点m的pt比较，得到pt</span></span><br><span class="line"><span class="string">  l.j = max(l&#x27;</span>.j, l.m, pt.j)</span><br><span class="line">  <span class="keyword">if</span> (l.j = l<span class="string">&#x27;.j = l.m) &#123;</span></span><br><span class="line"><span class="string">    // pt一样，获取最大的ct，并加1</span></span><br><span class="line"><span class="string">    c.j = max(c.j, c.m) + 1</span></span><br><span class="line"><span class="string">  &#125; else if (l.j = l&#x27;</span>j) &#123;</span><br><span class="line">    <span class="comment">// 这里表明j原来的pt比m大，只需要增加ct</span></span><br><span class="line">    c.j = c.j + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l.j = l.m) &#123;</span><br><span class="line">    <span class="comment">// 这里表明m的pt比j原来的要大，所以直接可以用m的ct + 1</span></span><br><span class="line">    c.j = c.m + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// pt变化了，ct清零</span></span><br><span class="line">    c.j = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Timestamp with l.j, c.</span></span><br></pre></td></tr></table></figure><p>会将其他node的hlc的物理时间，本node维护的hlc的物理时间和ntp的物理时间比较，将本地维护的hlc物理时间设为最大的，如果相等则将逻辑时间最大的加一。 同时为了保证事务的外部一致性，即当一个新的事务开始的时候，需要保证分配给他的candidate timestamp需要大于所有他接下来操作涉及数据的timestamp。为了做到这点crdb给新事物分配candidate timestamp时都会给其定一个时间偏移，时间偏移是当前node与cluster的最大时间偏移，在candidate timestamp到之后时间偏移这段时间称为不确定时间，即如果碰到了在这段时间修改的数据，不能判断其timestamp到底是在candidate timestamp之前还是之后，当事务执行过程中在任意node碰到这种情况，事务就会restart。为了避免因为这种情况导致事务不停的restart，在restart之后的candidate timestamp会push到不确定数据的timestamp，而时间偏移的上限不变，这样就减少了时间偏移的间隔，从而减少了restart的可能性。 跟Google的True time相比，这个优点是不需要google那样提供精确的GPS和原子种，类似的点是都可以在本地生成时间戳而不需要一个时间中心之类的辅助，缺点是生成的时间戳的不准确性需要在事务执行时才能发现，会导致事务restart，而Google通过commit wait避免了这个情况。</p><ul><li><p>隔离等级：crdb有两种隔离等级，SNAPSHOT和SERIALIZABLE，第二种是默认的隔离等级，这两种等级在实现上的主要区别在于两个事务在相同数据intent处发生冲突时，前者可以向后push其中一个事务的timestamp。crdb这两种隔离等级的实现都不需要锁，它们依赖于前面提到的transaction record和write intent，通过它们可以发现冲突并选择解决方法，不过代价就是更多的事务重试。</p></li><li><p>事务执行流程细节：</p><ul><li><p>事务开始后，先选取一个range写入transaction record状态PENDING，与此同时将所有需要修改的数据写入一个write intent，write intent中带普通的MVCC数据和一个指针指向record。当事务读取数据的时候，如果没有发现intent，那么只需要正常读取MVCC数据就行了，如果发现了intent，就需要根据intent的指针找到record从而确定当前正在使用intent的事务的状态，在下面我列了事务冲突的几种情况。</p><ul><li><p>提交事务时更新record状态，但是并不清理intent。提交事务使用的时间戳一般是candidate timestamp，但是如果是SNAPSHOT隔离等级，那么可能每个node的candidate timestamp不一致，这时协调节点会取最大的那一个。</p></li><li><p>不论是事务commit了或者abort了，之前事务的intent在当时都没有处理，而是在下一次有write或者read使用这块数据的时候会发现这些intent，这时会根据状态来清理intent，如果是commit那么将其转变为MVCC数据，如果是abort那么将其删除。需要注意的一点是record状态的更新是协调节点通过heartbeat对应record来更新和确认事务存活的，因而每次事务检查record状态时都需要heartbeat协调节点来确定事务状态是否准确的。</p></li></ul></li></ul></li><li><p>冲突解决：</p><ul><li><p>读操作碰到时间戳较新的write intent：这不会造成冲突，因为修改在读之后，读操作直接按时间戳读取MVCC数据即可。</p></li><li><p>读操作碰到时间戳相近的write intent：由于cluster的时钟存在偏移，因而这一时间段的数据状态不能确认，需要事务restart，具体的前面说过。</p></li><li><p>读操作碰到时间戳较旧的write intent：通过指针查看record状态，如果事务已经提交了，那么直接读取该intent数据并将其变成MVCC数据即可；如果事务没有提交，那么根据隔离等级来进行处理：</p><ul><li>1.当隔离等级为SNAPSHOT时，为了让读操作尽快完成，这时会将写操作的timestamp往后push，这样当写操作的timestamp大于当前读的timestamp后就不会造成冲突了，但是这样也可能会造成写偏斜（write skew）。</li><li>2.当隔离等级为SERIALIZABLE时，则根据事务的优先级来判断，如果读操作优先级较高，那么restart写事务；如果读操作跟写事务优先级相等或者较少，那么restart读事务并重新给一个较高的优先级（冲突事务优先级-1）。</li></ul></li><li><p>写操作碰到未提交的write intent：如果写操作的优先级较高，那么restart冲突的事务；如果相等或者较低，则restart写操作事务并给一个较高的优先级（冲突事务优先级-1）.</p></li><li><p>写操作碰到最近新提交的值：由于正在进行的写操作时间戳在已提交的时间戳前面，那么不能继续执行写操作不然会导致脏数据，需要restart写操作事务，优先级不变但是candidate timestamp push到发生冲突的值的timestamp之后。</p></li><li><p>写操作碰到最近被读过的值：最近读操作的时间戳会存在timestamp cache中，如果写操作的timestamp小于cache中读操作的timestamp，那么继续写就会造成问题，因而使写操作事务以一个新的timestamp restart。</p></li></ul></li><li><p>对于一个事务它的重试的次数跟持续时间的关系：</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/cockroach/txn/tranction-completion.png" alt="transaction-execution-process.png"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> CockroachDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java资源大全</title>
      <link href="posts/4040ef7a.html"/>
      <url>posts/4040ef7a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java资源大全中文版"><a href="#Java资源大全中文版" class="headerlink" title="Java资源大全中文版"></a>Java资源大全中文版</h1><p>我想很多程序员应该记得 GitHub 上有一个 Awesome - XXX 系列的资源整理。<a href="https://github.com/akullpp/awesome-java">awesome-java</a> 就是 akullpp 发起维护的 Java 资源列表，内容包括：构建工具、数据库、框架、模板、安全、代码分析、日志、第三方库、书籍、Java 站点等等。伯乐在线已经把 awesome-java 资源列表翻成中文后发布于 <a href="http://www.importnew.com/14429.html">ImportNew</a>。</p><p>Awesome 系列虽然挺全，但基本只对收录的资源做了极为简要的介绍，如果有更详细的中文介绍，对相应开发者的帮助会更大。这也是我们发起这个开源项目的初衷。</p><hr><h3 id="我们要做什么？"><a href="#我们要做什么？" class="headerlink" title="我们要做什么？"></a>我们要做什么？</h3><ul><li>基于 awesome-java 资源列表，我们将对各个资源项进行编译整理。</li><li>整理后的内容，将收录在<a href="http://hao.jobbole.com/">伯乐在线资源频道</a>。可参考已整理的内容：<ul><li>《<a href="http://hao.jobbole.com/owner/">OWNER：Java配置文件解决方案</a>》</li><li>《<a href="http://hao.jobbole.com/spring-boot/">Spring Boot：简化Spring应用初始搭建以及开发过程</a>》</li><li>《<a href="http://hao.jobbole.com/sonarqube/">SonarQube：开源的代码质量管理工具</a>》</li></ul></li></ul><hr><h3 id="如何参与本项目？"><a href="#如何参与本项目？" class="headerlink" title="如何参与本项目？"></a>如何参与本项目？</h3><!-- 从下面的目录来看，本项目的工作量小不了，所以非常期待能有更多程序员一起来参与。不过加入前，有几个小要求：* 英文还不错，能读懂英文并用自己的话复述；* 在用 Java；如有兴趣，请加 QQ：50872495。加 Q 时请注明「Java大全」 --><hr><h3 id="如何为列表贡献新资源？"><a href="#如何为列表贡献新资源？" class="headerlink" title="如何为列表贡献新资源？"></a>如何为列表贡献新资源？</h3><p>欢迎大家为列表贡献高质量的新资源，提交PR时请参照以下要求：</p><ul><li>请确保推荐的资源自己使用过</li><li>提交PR时请注明推荐理由</li></ul><p>资源列表管理收到PR请求后，会定期（每周）在微博转发本周提交的PR列表，并在微博上面听取使用过这些资源的意见。确认通过后，会加入资源大全。</p><p>感谢您的贡献！</p><hr><h3 id="本项目的参与者"><a href="#本项目的参与者" class="headerlink" title="本项目的参与者"></a>本项目的参与者</h3><ul><li><p>维护者：<a href="https://github.com/tangyouhua">tangyouhua</a></p></li><li><p>贡献者：<a href="https://github.com/tangyouhua">tangyouhua</a>、<a href="https://github.com/kingzone">kingzone</a>、<a href="https://github.com/llhua2329">llhua2329</a>、<a href="https://github.com/BadCoderChou">BadCoderChou</a>、<a href="http://www.jobbole.com/members/anankun/">anankun</a>、<a href="http://www.jobbole.com/members/jianghehe/">贺贺</a>、<a href="http://www.jobbole.com/members/petra/">大彭</a>、<a href="https://github.com/wing00yf/">superXiaoFan</a>、<a href="http://www.jobbole.com/members/3951356/">javayrf</a>、<a href="http://www.jobbole.com/members/John%20Smith/">John Smith</a>、<a href="http://www.jobbole.com/members/jaler/">Jaler</a>、<a href="http://www.jobbole.com/members/fdconan/">JM</a>、<a href="http://www.jobbole.com/members/zy124348985/">dreamkidd</a>、<a href="http://www.jobbole.com/members/cheenlie">cheenlie</a>、<a href="http://www.jobbole.com/members/zhangQian1991">zhangQian1991</a>、<a href="http://www.jobbole.com/members/wt726553124/">王涛</a>、<a href="http://www.jobbole.com/members/xun_cui">马</a>、<a href="http://www.jobbole.com/members/xuhf_1988/">vvkee</a>、<a href="http://www.jobbole.com/members/yangxy81118">凝枫</a>、<a href="https://github.com/luhaixun">haixunlu</a>、<a href="http://www.jobbole.com/members/milly/">milly</a>、<a href="http://www.jobbole.com/members/xuhf_1988/">Hodur</a>、<a href="http://www.jobbole.com/members/FakeHank">FakeHank</a>、<a href="http://www.jobbole.com/members/%E8%BF%9E%E4%B9%90/">连乐</a>、<a href="http://www.jobbole.com/members/UncleTim/">UncleTim</a>、<a href="http://www.jobbole.com/members/sunbiaobiao">sunbiaobiao</a>、<a href="http://www.jobbole.com/members/wx2702327993/">zhiguo</a>、<a href="http://www.jobbole.com/members/zhongjianno1/">光光头去打酱油</a>、<a href="http://www.jobbole.com/members/TonyAaron/">云中游</a>、<a href="http://www.jobbole.com/members/zemo/">Zemo</a>、<a href="https://github.com/sdcuike">sdcuike</a>、<a href="https://github.com/danielwii">danielwii</a>、<a href="http://www.jobbole.com/members/q1118024125/">oneDay</a>、<a href="https://github.com/dfghj44444">邢敏</a>、<a href="https://github.com/heikehuan">heikehuan</a>、<a href="https://github.com/fgcui1204">fgcui1204</a>、<a href="https://github.com/wenxueliu">wenxueliu</a>、<a href="https://github.com/node">Gentle Yang</a>、<a href="http://hao.jobbole.com/author/huangxiaofei/">黄小非</a>、<a href="http://www.jobbole.com/members/wtgn1m1/">wangtg</a>、<a href="http://www.jobbole.com/members/2937134480/">百焱</a>、<a href="http://www.jobbole.com/members/2480130384/">胡不GUI</a>、<a href="http://www.jobbole.com/members/mtHzm/">Another_mt</a>、<a href="http://www.jobbole.com/members/adonis/">Rainbow</a>、<a href="http://www.jobbole.com/members/menghuanqiqi">super^糖</a>、<a href="http://www.jobbole.com/members/huangyuliang/">黄余粮</a>、<a href="http://www.jobbole.com/members/sunbojian100/">Sun</a>、<a href="https://github.com/SoberChina">李伟高</a>、<a href="https://github.com/q977734161">lixiaobao</a>、<a href="https://github.com/XuZhongCN">許中</a>、You</p></li></ul><p>注：名单不分排名，不定期补充更新</p><hr><!-- ### 奖励计划虽然奖励可能并不是你加入的主要原因，但还是有必要提一下：* 整理超过 20 个资源后，可在伯乐在线上开通打赏；* 每整理 20 个资源，有机会获得技术书籍或各种有意思的创意、极客产品；* [奖励详情](http://hao.jobbole.com/rewards/)* * * --><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#awesome-java-cn">Java资源大全中文版</a><ul><li><a href="#ancients">古董级工具</a></li><li><a href="#build">构建工具</a></li><li><a href="#bytecode-manipulation">字节码操作</a></li><li><a href="#cluster-management">集群管理</a></li><li><a href="#code-analysis">代码分析</a></li><li><a href="#compiler-compiler">编译器生成工具</a></li><li><a href="#configuration">外部配置工具</a></li><li><a href="#constraint-satisfaction-problem-solver">约束满足问题求解程序</a></li><li><a href="#continuous-integration">持续集成</a></li><li><a href="#csv">CSV解析</a></li><li><a href="#data-structures">数据结构</a></li><li><a href="#database">数据库</a></li><li><a href="#date-and-time">时间日期工具库</a></li><li><a href="#dependency-injection">依赖注入</a></li><li><a href="#development">开发流程增强工具</a></li><li><a href="#distributed-applications">分布式应用</a></li><li><a href="#distributed-databases">分布式数据库</a></li><li><a href="#distribution">发布</a></li><li><a href="#document-processing">文档处理工具</a></li><li><a href="#functional-programming">函数式编程</a></li><li><a href="#game-development">游戏开发</a></li><li><a href="#gui">GUI</a></li><li><a href="#high-performance">高性能计算</a></li><li><a href="#ide">IDE</a></li><li><a href="#imagery">图像处理</a></li><li><a href="#json">JSON</a></li><li><a href="#jvm-and-jdk">JVM与JDK</a></li><li><a href="#languages">基于JVM的语言</a></li><li><a href="#logging">日志</a></li><li><a href="#machine-learning">机器学习</a></li><li><a href="#messaging">消息传递</a></li><li><a href="#miscellaneous">杂项</a></li><li><a href="#monitoring">应用监控工具</a></li><li><a href="#native">原生开发库</a></li><li><a href="#natural-language-processing">自然语言处理</a></li><li><a href="#networking">网络</a></li><li><a href="#orm">ORM</a></li><li><a href="#pdf">PDF</a></li><li><a href="#performance-analysis">性能分析</a></li><li><a href="#reactive-libraries">响应式开发库</a></li><li><a href="#rest-frameworks">REST框架</a></li><li><a href="#science">科学计算与分析</a></li><li><a href="#search">搜索引擎</a></li><li><a href="#security">安全</a></li><li><a href="#serialization">序列化</a></li><li><a href="#server">应用服务器</a></li><li><a href="#template-engine">模板引擎</a></li><li><a href="#testing">测试</a></li><li><a href="#utility">通用工具库</a></li><li><a href="#web-crawling">网络爬虫</a></li><li><a href="#web-frameworks">Web框架</a></li><li><a href="#Business-Process-Management">业务流程管理套件</a></li></ul></li><li><a href="#resources">资源</a><ul><li><a href="#communities">社区</a></li><li><a href="#influential-books">有影响力的书</a></li><li><a href="#podcasts">播客</a></li><li><a href="#weibo-weixin">微博、微信公众号</a></li><li><a href="#twitter">Twitter</a></li><li><a href="#websites">知名网站</a></li></ul></li></ul><h2 id="ancients">古董级工具</h2><p><em>这些工具伴随着Java一起出现，在各自辉煌之后还在一直使用。</em></p><ul><li><a href="http://hao.jobbole.com/apache-ant/">Apache Ant</a>：基于XML的构建管理工具。<a href="http://ant.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/cglib/">cglib</a>：字节码生成库。<a href="https://github.com/cglib/cglib">官网</a></li><li><a href="http://hao.jobbole.com/glassfish/">GlassFish</a>：应用服务器，由Oracle赞助支持的Java EE参考实现。<a href="https://glassfish.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/hudson/">Hudson</a>：持续集成服务器，目前仍在活跃开发。<a href="http://hudson-ci.org/">官网</a></li><li><a href="http://hao.jobbole.com/javaserver-faces/">JavaServer Faces</a>：Mojarra是JSF标准的一个开源实现，由Oracle开发。<a href="https://javaserverfaces.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/javaserver-pages/">JavaServer Pages</a>：支持自定义标签库的网站通用模板库。<a href="https://jsp.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/liquibase/">Liquibase</a>：与具体数据库独立的追踪、管理和应用数据库Scheme变化的工具。<a href="http://www.liquibase.org/">官网</a></li></ul><h3 id="build">构建工具</h3><p><em>构建及应用依赖关系处理工具。</em></p><ul><li><a href="http://hao.jobbole.com/maven/">Apache Maven</a>：Maven是一款声明式构建及依赖管理工具，采用约定优于配置方式进行管理。相对Apache Ant更推荐使用Maven，前者采用了过程式管理，维护相对困难。<a href="http://maven.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/bazel/">Bazel</a>：来自Google的构建工具，可以快速、可靠地构建代码。<a href="http://bazel.io/">官网</a></li><li><a href="http://hao.jobbole.com/gradle/">Gradle</a>：使用Groovy（非XML）进行增量构建，可以很好地与Maven依赖管理配合工作。<a href="http://gradle.org/">官网</a></li><li><a href="http://hao.jobbole.com/buck/">Buck</a>：Facebook构建工具。<a href="https://buckbuild.com/">官网</a></li></ul><h3 id="bytecode-manipulation">字节码操作</h3><p><em>编程方式操作字节码的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/asm/">ASM</a>：通用底层字节码操作和分析开发库。<a href="http://asm.ow2.org/">官网</a></li><li><a href="http://hao.jobbole.com/byte-buddy/">Byte Buddy</a>：使用流式API进一步简化字节码生成。<a href="http://bytebuddy.net/">官网</a></li><li><a href="http://hao.jobbole.com/byteman/">Byteman</a>：在运行时通过DSL（规则）操作字节码进行测试和故障排除。<a href="http://byteman.jboss.org/">官网</a></li><li><a href="http://hao.jobbole.com/javassist/">Javassist</a>：一个简化字节码编辑尝试。<a href="http://jboss-javassist.github.io/javassist">官网</a></li></ul><h3 id="cluster-management">集群管理</h3><p><em>在集群内动态管理应用程序的框架。</em></p><ul><li><a href="http://hao.jobbole.com/apache-aurora/">Apache Aurora</a>：Apache Aurora是一个Mesos框架，用于长时间运行服务和定时任务（cron job）。<a href="http://aurora.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/singularity/">Singularity</a>：Singularity是一个Mesos框架，方便部署和操作。它支持Web Service、后台运行、调度作业和一次性任务。<a href="http://getsingularity.com/">官网</a></li></ul><h3 id="code-analysis">代码分析</h3><p><em>测量代码指标和质量工具。</em></p><ul><li><a href="http://hao.jobbole.com/checkstyle/">Checkstyle</a>：代码编写规范和标准静态分析工具。<a href="https://github.com/checkstyle/checkstyle">官网</a></li><li><a href="http://hao.jobbole.com/error-prone/">Error Prone</a>：将常见编程错误作为运行时错误报告。<a href="https://github.com/google/error-prone">官网</a></li><li>FindBugs：通过字节码静态分析查找隐藏bug。<a href="http://findbugs.sourceforge.net/">官网</a></li><li><a href="http://hao.jobbole.com/jqassistant/">jQAssistant</a>：使用基于Neo4J查询语言进行代码静态分析。<a href="http://jqassistant.org/">官网</a></li><li><a href="http://hao.jobbole.com/pmd/">PMD</a>：对源代码分析查找不良的编程习惯。<a href="https://github.com/pmd/pmd">官网</a></li><li><a href="http://hao.jobbole.com/sonarqube/">SonarQube</a>：通过插件集成其它分析组件，对过去一段时间内的数据进行统计。<a href="http://www.sonarqube.org/">官网</a></li></ul><h3 id="compiler-compiler">编译器生成工具</h3><p><em>用来创建解析器、解释器或编译器的框架。</em></p><ul><li><a href="http://hao.jobbole.com/antlr/">ANTLR</a>：复杂的全功能自顶向下解析框架。<a href="http://www.antlr.org/">官网</a></li><li><a href="http://hao.jobbole.com/javacc/">JavaCC</a>：JavaCC是更加专门的轻量级工具，易于上手且支持语法超前预测。<a href="https://javacc.org/">官网</a></li></ul><h3 id="configuration">外部配置工具</h3><p><em>支持外部配置的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/config/">config</a>：针对JVM语言的配置库。<a href="https://github.com/typesafehub/config">官网</a></li><li><a href="http://hao.jobbole.com/owner/">owner</a>：减少冗余配置属性。<a href="https://github.com/lviggiano/owner">官网</a></li></ul><h3 id="constraint-satisfaction-problem-solver">约束满足问题求解程序</h3><p><em>帮助解决约束满足问题的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/choco/">Choco</a>：可直接使用的约束满足问题求解程序，使用了约束规划技术。<a href="http://choco-solver.org/">官网</a></li><li><a href="http://hao.jobbole.com/jacop/">JaCoP</a>：为FlatZinc语言提供了一个接口，可以执行MiniZinc模型。<a href="https://github.com/radsz/jacop/">官网</a></li><li><a href="http://hao.jobbole.com/optaplanner/">OptaPlanner</a>：业务规划与资源调度优化求解程序。<a href="http://www.optaplanner.org/">官网</a></li><li><a href="http://hao.jobbole.com/sat4j/">Sat4J</a>：逻辑代数与优化问题最先进的求解程序。<a href="http://www.sat4j.org/">官网</a></li></ul><h3 id="continuous-integration">持续集成</h3><ul><li><a href="http://hao.jobbole.com/bamboo/">Bamboo</a>：Atlassian解决方案，可以很好地集成Atlassian的其他产品。可以选择开源许可，也可以购买商业版。<a href="https://www.atlassian.com/software/bamboo">官网</a></li><li>CircleCI：提供托管服务，可以免费试用。<a href="https://circleci.com/">官网</a></li><li><a href="http://hao.jobbole.com/codeship/">Codeship</a>：提供托管服务，提供有限的免费模式。<a href="https://codeship.com/features">官网</a></li><li><a href="hao.jobbole.com/fabric8/">fabric8</a>：容器集成平台。<a href="http://fabric8.io/">官网</a></li><li><a href="http://hao.jobbole.com/go/">Go</a>：ThoughtWork开源解决方案。<a href="https://www.gocd.io/">官网</a></li><li><a href="http://hao.jobbole.com/jenkins/">Jenkins</a>：支持基于服务器的部署服务。<a href="http://jenkins-ci.org/">官网</a></li><li><a href="http://hao.jobbole.com/teamcity/">TeamCity</a>：JetBrain的持续集成解决方案，有免费版。<a href="http://www.jetbrains.com/teamcity/">官网</a></li><li><a href="http://hao.jobbole.com/travis/">Travis</a>：通常用作开源项目的托管服务。<a href="https://travis-ci.org/">官网</a></li><li><a href="http://hao.jobbole.com/buildkite/">Buildkite</a>: 持续集成工具，用简单的脚本就能设置pipeline，而且能快速构建，可以免费试用。<a href="https://buildkite.com/">官网</a></li></ul><h3 id="csv">CSV解析</h3><p><em>简化CSV数据读写的框架与开发库</em></p><ul><li><a href="http://hao.jobbole.com/univocity-parsers/">uniVocity-parsers</a>：速度最快功能最全的CSV开发库之一，同时支持TSV与固定宽度记录的读写。<a href="https://github.com/uniVocity/univocity-parsers">官网</a></li></ul><h3 id="database">数据库</h3><p><em>简化数据库交互的相关工具。</em></p><ul><li><a href="http://hao.jobbole.com/apache-phoenix/">Apache Phoenix</a>：HBase针对低延时应用程序的高性能关系数据库层。<a href="http://phoenix.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/crate/">Crate</a>：实现了数据同步、分片、缩放、复制的分布式数据存储。除此之外还可以使用基于SQL的语法跨集群查询。<a href="https://crate.io/">官网</a></li><li><a href="http://hao.jobbole.com/flyway/">Flyway</a>：简单的数据库迁移工具。<a href="http://flywaydb.org/">官网</a></li><li><a href="http://hao.jobbole.com/h2/">H2</a>：小型SQL数据库，以可以作为内存数据库使用著称。<a href="http://h2database.com/">官网</a></li><li><a href="http://hao.jobbole.com/hikaricp/">HikariCP</a>：高性能JDBC连接工具。<a href="https://github.com/brettwooldridge/HikariCP">官网</a></li><li><a href="http://hao.jobbole.com/jdbi/">JDBI</a>：便捷的JDBC抽象。<a href="http://jdbi.org/">官网</a></li><li><a href="http://hao.jobbole.com/jooq/">jOOQ</a>：为SQL schema生成typesafe代码。<a href="http://www.jooq.org/">官网</a></li><li><a href="http://hao.jobbole.com/mapdb/">MapDB</a>：以磁盘或堆内存中并发集合为基础的嵌入式数据库引擎。<a href="http://www.mapdb.org/">官网</a></li><li><a href="http://hao.jobbole.com/presto/">Presto</a>：针对大数据的分布式SQL查询引擎。<a href="https://github.com/facebook/presto">官网</a></li><li><a href="http://hao.jobbole.com/querydsl/">Querydsl</a>：Typesafe统一查询。<a href="http://www.querydsl.com/">官网</a></li></ul><h3 id="data-structures">数据结构</h3><ul><li><a href="http://hao.jobbole.com/apache-parquet/">Apache Parquet</a>：Google Dremel论文中发布的基于组装算法的列式（Columnar）存储格式。<a href="http://parquet.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/protobuf/">Protobuf</a>：Google数据交换格式。<a href="https://github.com/google/protobuf">官网</a></li><li><a href="http://hao.jobbole.com/sbe/">SBE</a>：简单二进制编码，是最快速的消息格式之一。<a href="https://github.com/real-logic/simple-binary-encoding">官网</a></li><li><a href="http://hao.jobbole.com/wire/">Wire</a>：整洁轻量级协议缓存。<a href="https://github.com/square/wire">官网</a></li></ul><h3 id="date-and-time">时间日期工具库</h3><p><em>处理时间和日期的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/joda-time/">Joda-Time</a>：在Java 8发布前，Joda-Time是实际使用的时间日期库标准。<a href="http://www.joda.org/joda-time/">官网</a></li><li><a href="http://hao.jobbole.com/time4j/">Time4J</a>：高级时间和日期库。<a href="https://github.com/MenoData/Time4J">官网</a></li><li><a href="http://hao.jobbole.com/ThreeTen/">ThreeTen</a>：JSR-310实现，为JDK提供更具特点的时间和日期API。<a href="http://www.threeten.org/">官网</a></li></ul><h3 id="dependency-injection">依赖注入</h3><p><em>帮实现依赖翻转范式的开发库。</em> <a href="https://en.wikipedia.org/wiki/Inversion_of_control">官网</a></p><ul><li><a href="http://hao.jobbole.com/apache-deltaspike/">Apache DeltaSpike</a>：CDI扩展框架。<a href="https://deltaspike.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/dagger2/">Dagger2</a>：编译时注入框架，不需要使用反射。<a href="http://google.github.io/dagger/">官网</a></li><li><a href="http://hao.jobbole.com/guice/">Guice</a>：可以匹敌Dagger的轻量级注入框架。<a href="https://github.com/google/guice">官网</a></li><li><a href="http://hao.jobbole.com/hk2/">HK2</a>：轻量级动态依赖注入框架。<a href="https://hk2.java.net/">官网</a></li></ul><h3 id="development">开发流程增强工具</h3><p><em>从最基本的层面增强开发流程。</em></p><ul><li><a href="http://hao.jobbole.com/adt4j/">ADT4J</a>：针对代数数据类型的JSR-269代码生成器。<a href="https://github.com/sviperll/adt4j">官网</a></li><li><a href="http://hao.jobbole.com/aspectj/">AspectJ</a>：面向切面编程（AOP）的无缝扩展。<a href="https://eclipse.org/aspectj/">官网</a></li><li><a href="http://hao.jobbole.com/auto/">Auto</a>：源代码生成器集合。<a href="https://github.com/google/auto">官网</a></li><li><a href="http://hao.jobbole.com/dcevm/">DCEVM</a>：通过修改JVM在运行时支持对已加载的类进行无限次重定义。<a href="http://dcevm.github.io/">官网</a></li><li>HotswapAgent：支持无限次重定义运行时类与资源。<a href="https://github.com/HotswapProjects/HotswapAgent">官网</a></li><li>Immutables：类似Scala的条件类。<a href="http://immutables.github.io/">官网</a></li><li>JHipster：基于Spring Boot与AngularJS应用程序的Yeoman源代码生成器。<a href="https://github.com/jhipster/generator-jhipster">官网</a></li><li><a href="http://hao.jobbole.com/jrebel/">JRebel</a>：无需重新部署，可以即时重新加载代码与配置的商业软件。<a href="http://zeroturnaround.com/software/jrebel/">官网</a></li><li>Lombok：减少冗余的代码生成器。<a href="https://projectlombok.org/">官网</a></li><li>Spring Loaded：类重载代理。<a href="https://github.com/spring-projects/spring-loaded">官网</a></li><li><a href="http://hao.jobbole.com/vert-x/">vert.x</a>：多语言事件驱动应用框架。<a href="http://vertx.io/">官网</a></li></ul><h3 id="distributed-applications">分布式应用</h3><p><em>用来编写分布式容错应用的开发库和框架。</em></p><ul><li><a href="http://hao.jobbole.com/akka/">Akka</a>：用来编写分布式容错并发事件驱动应用程序的工具和运行时。<a href="http://akka.io/">官网</a></li><li><a href="http://hao.jobbole.com/storm/">Apache Storm</a>：实时计算系统。<a href="http://storm.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/zookeeper/">Apache ZooKeeper</a>：针对大型分布式系统的协调服务，支持分布式配置、同步和名称注册。<a href="http://zookeeper.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/Hazelcast/">Hazelcast</a>：高可扩展内存数据网格。<a href="http://hazelcast.org/">官网</a></li><li><a href="http://hao.jobbole.com/hystrix/">Hystrix</a>：提供延迟和容错。<a href="https://github.com/Netflix/Hystrix">官网</a></li><li><a href="http://hao.jobbole.com/jgroups/">JGroups</a>：提供可靠的消息传递和集群创建的工具。<a href="http://www.jgroups.org/">官网</a></li><li><a href="http://hao.jobbole.com/orbit/">Orbit</a>：支持虚拟角色（Actor），在传统角色的基础上增加了另外一层抽象。<a href="http://orbit.bioware.com/">官网</a></li><li><a href="http://hao.jobbole.com/quasar/">Quasar</a>：为JVM提供轻量级线程和角色。<a href="http://www.paralleluniverse.co/quasar/">官网</a></li></ul><h3 id="distributed-databases">分布式数据库</h3><p><em>对应用程序而言，在分布式系统中的数据库看起来就像是只有一个数据源。</em></p><ul><li><a href="http://hao.jobbole.com/cassandra/">Apache Cassandra</a>：列式数据库，可用性高且没有单点故障。<a href="http://cassandra.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/hbase/">Apache HBase</a>：针对大数据的Hadoop数据库。<a href="http://hbase.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/druid/">Druid</a>：实时和历史OLAP数据存储，在聚集查询和近似查询方面表现不俗。<a href="http://druid.io/">官网</a></li><li><a href="http://hao.jobbole.com/infinispan/">Infinispan</a>：针对缓存的高并发键值对数据存储。<a href="http://infinispan.org/">官网</a></li><li><a href="">TiDB</a>：开源分布式HTAP数据库，结合了传统的RDBMS和NoSQL的最佳特性。<a href="https://pingcap.com/">官网</a></li></ul><h3 id="distribution">发布</h3><p><em>以本机格式发布应用程序的工具。</em></p><ul><li>Bintray：发布二进制文件版本控制工具。可以于Maven或Gradle一起配合使用。提供开源免费版本和几种商业收费版本。<a href="https://bintray.com/">官网</a></li><li><a href="http://hao.jobbole.com/central-repository/">Central Repository</a>：最大的二进制组件仓库，面向开源社区提供免费服务。Apache Maven默认使用Central <a href="http://search.maven.org/">官网</a>Repository，也可以在所有其他构建工具中使用。</li><li>IzPack：为跨平台部署建立创作工具（Authoring Tool）。<a href="http://izpack.org/">官网</a></li><li>JitPack：打包GitHub仓库的便捷工具。可根据需要构建Maven、Gradle项目，发布可立即使用的组件。<a href="https://jitpack.io/">官网</a></li><li>Launch4j：将JAR包装为轻量级本机Windows可执行程序。<a href="http://launch4j.sourceforge.net/">官网</a></li><li>Nexus：支持代理和缓存功能的二进制管理工具。<a href="http://www.sonatype.com/nexus">官网</a></li><li>packr：将JAR、资源和JVM打包成Windows、Linux和Mac OS X本地发布文件。<a href="https://github.com/libgdx/packr/">官网</a></li></ul><h3 id="document-processing">文档处理工具</h3><p><em>处理Office文档的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/poi/">Apache POI</a>：支持OOXML规范（XLSX、DOCX、PPTX）以及OLE2规范（XLS、DOC、PPT）。<a href="http://poi.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/documents4j/">documents4j</a>：使用第三方转换器进行文档格式转换，转成类似MS Word这样的格式。<a href="http://documents4j.com/">官网</a></li><li><a href="http://hao.jobbole.com/jopendocument/">jOpenDocument</a>：处理OpenDocument格式（由Sun公司提出基于XML的文档格式）。<a href="http://www.jopendocument.org/">官网</a></li></ul><h3 id="functional-programming">函数式编程</h3><p><em>函数式编程支持库。</em></p><ul><li>Cyclops：支持一元（Monad）操作和流操作工具类、comprehension（List语法）、模式匹配、trampoline等特性。<a href="https://github.com/aol/cyclops">官网</a></li><li>Fugue：Guava的函数式编程扩展。<a href="https://bitbucket.org/atlassian/fugue">官网</a></li><li>Functional Java：实现了多种基础和高级编程抽象，用来辅助面向组合开发（composition-oriented development）。<a href="http://www.functionaljava.org/">官网</a></li><li>Javaslang：一个函数式组件库，提供持久化数据类型和函数式控制结构。<a href="http://javaslang.com/">官网</a></li><li>jOOλ：旨在填补Java 8 lambda差距的扩展，提供了众多缺失的类型和一组丰富的顺序流API。<a href="https://github.com/jOOQ/jOOL">官网</a></li></ul><h3 id="game-development">游戏开发</h3><p><em>游戏开发框架。</em></p><ul><li><a href="http://hao.jobbole.com/jmonkeyengine/">jMonkeyEngine</a>：现代3D游戏开发引擎。<a href="http://jmonkeyengine.org/">官网</a></li><li><a href="http://hao.jobbole.com/libgdx/">libGDX</a>：全面的跨平台高级框架。<a href="https://libgdx.badlogicgames.com/">官网</a></li><li><a href="http://hao.jobbole.com/lwjgl/">LWJGL</a>：对OpenGL/CL/AL等技术进行抽象的健壮框架。<a href="https://www.lwjgl.org/">官网</a></li><li>jPCT：基于OpenGL技术开发的3D图形引擎。纯Java的3D引擎。<a href="http://www.jpct.net/">官网</a></li></ul><h3 id="gui">GUI</h3><p><em>现代图形化用户界面开发库。</em></p><ul><li><a href="http://hao.jobbole.com/javafx/">JavaFX</a>：Swing的后继者。<a href="http://www.oracle.com/technetwork/java/javase/overview/javafx-overview-2158620.html">官网</a></li><li><a href="http://hao.jobbole.com/scene_builder/">Scene Builder</a>：开发JavaFX应用的可视化布局工具。<a href="http://docs.oracle.com/javase/8/scene-builder-2/get-started-tutorial/overview.htm#JSBGS164">官网</a></li></ul><h3 id="high-performance">高性能计算</h3><p><em>涵盖了从集合到特定开发库的高性能计算相关工具。</em></p><ul><li>Agrona：高性能应用中常见的数据结构和工具方法。<a href="https://github.com/real-logic/Agrona">官网</a></li><li>Disruptor：线程间消息传递开发库。<a href="http://lmax-exchange.github.io/disruptor/">官网</a></li><li>fastutil：快速紧凑的特定类型集合（Collection）。<a href="http://fastutil.di.unimi.it/">官网</a></li><li>GS Collections：受Smalltalk启发的集合框架。<a href="https://github.com/goldmansachs/gs-collections">官网</a></li><li><a href="http://hao.jobbole.com/hppc/">HPPC</a>：基础类型集合。<a href="http://labs.carrotsearch.com/hppc.html">官网</a></li><li>Javolution：实时和嵌入式系统的开发库。<a href="http://javolution.org/">官网</a></li><li><a href="http://hao.jobbole.com/jctools/">JCTools</a>：JDK中缺失的并发工具。<a href="https://github.com/JCTools/JCTools">官网</a></li><li><a href="http://hao.jobbole.com/koloboke/">Koloboke</a>：Hash set和hash map。<a href="https://github.com/OpenHFT/Koloboke">官网</a></li><li>Trove：基础类型集合。<a href="http://trove.starlight-systems.com/">官网</a></li><li>High-scale-lib:Cliff Click 个人开发的高性能并发库<a href="https://github.com/stephenc/high-scale-lib">官网</a></li></ul><h3 id="ide">IDE</h3><p><em>简化开发的集成开发环境。</em></p><ul><li><a href="http://hao.jobbole.com/eclipse/">Eclipse</a>：老牌开源项目，支持多种插件和编程语言。<a href="http://www.eclipse.org/">官网</a></li><li><a href="http://hao.jobbole.com/intellij-idea/">IntelliJ IDEA</a>：支持众多JVM语言，是安卓开发者好的选择。商业版主要针对企业客户。<a href="http://www.jetbrains.com/idea/">官网</a></li><li><a href="http://hao.jobbole.com/netbeans/">NetBeans</a>：为多种技术提供集成化支持，包括Java SE、Java EE、数据库访问、HTML5等。<a href="https://netbeans.org/">官网</a></li><li><a href="http://hao.jobbole.com/scala-ide/">Scala IDE</a>：一款基于Eclipse开源平台打造的Scala集成开发环境。<a href="http://scala-ide.org/">官网</a></li><li><a href="http://hao.jobbole.com/springsource-tool-suite/">SpringSource Tool Suite（STS）</a>:一款基于Eclipse开源平台打造的Spring应用开发环境。<a href="http://spring.io/tools/sts/">官网</a></li></ul><h3 id="imagery">图像处理</h3><p><em>创建、评价和操作图片的支持库。</em></p><ul><li><a href="http://hao.jobbole.com/imgscalr/">Imgscalr</a>：纯Java 2D实现，简单、高效、支持硬件加速的图像缩放开发库。<a href="https://github.com/thebuzzmedia/imgscalr">官网</a></li><li><a href="http://hao.jobbole.com/picasso/">Picasso</a>：安卓图片下载和图片缓存开发库。<a href="http://square.github.io/picasso/">官网</a></li><li><a href="http://hao.jobbole.com/thumbnailator/">Thumbnailator</a>：Thumbnailator是一个高质量Java缩略图开发库。<a href="https://github.com/coobird/thumbnailator">官网</a></li><li><a href="http://hao.jobbole.com/zxing/">ZXing</a>：支持多种格式的一维、二维条形码图片处理开发库。<a href="https://github.com/zxing/zxing">官网</a></li><li><a href="http://hao.jobbole.com/im4java/">im4java</a>: 基于ImageMagick或GraphicsMagick命令行的图片处理开发库，基本上ImageMagick能够支持的图片格式和处理方式都能够处理。<a href="http://im4java.sourceforge.net/">官网</a></li><li>Apache Batik：在Java应用中程序以SVG格式显示、生成及处理图像的工具集，包括SVG解析器、SVG生成器、SVG DOM等模块，可以集成使用也可以单独使用，还可以扩展自定义的SVG标签。<a href="http://xmlgraphics.apache.org/batik/">官网</a></li></ul><h3 id="json">JSON</h3><p><em>简化JSON处理的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/genson/">Genson</a>：强大且易于使用的Java到JSON转换开发库。<a href="http://owlike.github.io/genson">官网</a></li><li><a href="http://hao.jobbole.com/gson/">Gson</a>：谷歌官方推出的JSON处理库，支持在对象与JSON之间双向序列化，性能良好且可以实时调用。<a href="https://github.com/google/gson">官网</a></li><li><a href="http://hao.jobbole.com/jackson/">Jackson</a>：与GSON类似，在频繁使用时性能更佳。<a href="http://wiki.fasterxml.com/JacksonHome">官网</a></li><li><a href="http://hao.jobbole.com/logansquare/">LoganSquare</a>：基于Jackson流式API，提供对JSON解析和序列化。比GSON与Jackson组合方式效果更好。<a href="https://github.com/bluelinelabs/LoganSquare">官网</a></li><li><a href="http://hao.jobbole.com/fastjson/">Fastjson</a>：一个Java语言编写的高性能功能完善的JSON库。<a href="https://github.com/Alibaba/fastjson">官网</a></li><li>Kyro：快速、高效、自动化的Java对象序列化和克隆库。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li></ul><h3 id="jvm-and-jdk">JVM与JDK</h3><p><em>目前的JVM和JDK实现。</em></p><ul><li><a href="http://hao.jobbole.com/jdk-9/">JDK 9</a>：JDK 9的早期访问版本。<a href="https://jdk9.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/openjdk/">OpenJDK</a>：JDK开源实现。<a href="http://openjdk.java.net/">官网</a></li></ul><h3 id="languages">基于JVM的语言</h3><p><em>除Java外，可以用来编写JVM应用程序的编程语言。</em></p><ul><li>Scala：融合了面向对象和函数式编程思想的静态类型编程语言。<a href="http://www.scala-lang.org/">官网</a></li><li><a href="http://hao.jobbole.com/groovy/">Groovy</a>：类型可选（Optionally typed）的动态语言，支持静态类型和静态编译。目前是一个Apache孵化器项目。<a href="http://www.groovy-lang.org/">官网</a></li><li>Clojure：可看做现代版Lisp的动态类型语言。<a href="http://clojure.org/">官网</a></li><li>Ceylon：RedHat开发的面向对象静态类型编程语言。<a href="http://ceylon-lang.org/">官网</a></li><li>Kotlin：JetBrain针对JVM、安卓和浏览器提供的静态类型编程语言。<a href="http://kotlinlang.org/">官网</a></li><li><a href="http://hao.jobbole.com/xtend/">Xtend</a>：一种静态编程语言，能够将其代码转换为简洁高效的Java代码，并基于JVM运行。<a href="http://www.eclipse.org/xtend/">官网</a></li></ul><h3 id="logging">日志</h3><p><em>记录应用程序行为日志的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/log4j2/">Apache Log4j 2</a>：使用强大的插件和配置架构进行完全重写。<a href="http://logging.apache.org/log4j/">官网</a></li><li><a href="http://hao.jobbole.com/kibana/">kibana</a>：分析及可视化日志文件。<a href="https://www.elastic.co/products/kibana">官网</a></li><li><a href="http://hao.jobbole.com/logback/">Logback</a>：强健的日期开发库，通过Groovy提供很多有趣的选项。<a href="http://logback.qos.ch/">官网</a></li><li><a href="http://hao.jobbole.com/logstash/">logstash</a>：日志文件管理工具。<a href="https://www.elastic.co/products/logstash">官网</a></li><li><a href="http://hao.jobbole.com/metrics/">Metrics</a>：通过JMX或HTTP发布参数，并且支持存储到数据库。<a href="https://github.com/dropwizard/metrics">官网</a></li><li><a href="http://hao.jobbole.com/slf4j/">SLF4J</a>：日志抽象层，需要与具体的实现配合使用。<a href="http://www.slf4j.org/">官网</a></li></ul><h3 id="machine-learning">机器学习</h3><p><em>提供具体统计算法的工具。其算法可从数据中学习。</em></p><ul><li><a href="http://hao.jobbole.com/apache-flink/">Apache Flink</a>：快速、可靠的大规模数据处理引擎。<a href="https://flink.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/apache-hadoop/">Apache Hadoop</a>：在商用硬件集群上用来进行大规模数据存储的开源软件框架。<a href="http://hadoop.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/apache-mahout/">Apache Mahout</a>：专注协同过滤、聚类和分类的可扩展算法。<a href="https://mahout.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/apache-spark/">Apache Spark</a>：开源数据分析集群计算框架。<a href="http://spark.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/deepdive/">DeepDive</a>：从非结构化数据建立结构化信息并集成到已有数据库的工具。<a href="http://deepdive.stanford.edu/">官网</a></li><li><a href="http://hao.jobbole.com/deeplearning4j/">Deeplearning4j</a>：分布式多线程深度学习开发库。<a href="http://deeplearning4j.org/">官网</a></li><li><a href="http://hao.jobbole.com/h2o/">H2O</a>：用作大数据统计的分析引擎。<a href="http://h2o.ai/">官网</a></li><li><a href="http://hao.jobbole.com/weka/">Weka</a>：用作数据挖掘的算法集合，包括从预处理到可视化的各个层次。<a href="http://www.cs.waikato.ac.nz/ml/weka/">官网</a></li><li><a href="http://hao.jobbole.com/quickml/">QuickML</a>：高效机器学习库。<a href="http://quickml.org/">官网</a>、<a href="https://github.com/sanity/quickml">GitHub</a></li></ul><h3 id="messaging">消息传递</h3><p><em>在客户端之间进行消息传递，确保协议独立性的工具。</em></p><ul><li><a href="http://hao.jobbole.com/aeron/">Aeron</a>：高效可扩展的单播、多播消息传递工具。<a href="https://github.com/real-logic/Aeron">官网</a></li><li><a href="http://hao.jobbole.com/activemq/">Apache ActiveMQ</a>：实现JMS的开源消息代理（broker），可将同步通讯转为异步通讯。<a href="http://activemq.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/apache-camel/">Apache Camel</a>：通过企业级整合模式（Enterprise Integration Pattern EIP）将不同的消息传输API整合在一起。<a href="http://camel.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/kafka/">Apache Kafka</a>：高吞吐量分布式消息系统。<a href="http://kafka.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/hermes/">Hermes</a>：快速、可靠的消息代理（Broker），基于Kafka构建。<a href="http://hermes.allegro.tech/">官网</a></li><li>JBoss HornetQ：清晰、准确、模块化，可以方便嵌入的消息工具。<a href="http://hornetq.jboss.org/">官网</a></li><li><a href="http://hao.jobbole.com/jeromq/">JeroMQ</a>：ZeroMQ的纯Java实现。<a href="https://github.com/zeromq/jeromq">官网</a></li><li><a href="http://hao.jobbole.com/smack/">Smack</a>：跨平台XMPP客户端函数库。<a href="https://github.com/igniterealtime/Smack/">官网</a></li><li>Openfire：是开源的、基于XMPP、采用Java编程语言开发的实时协作服务器。 Openfire安装和使用都非常简单，并可利用Web界面进行管理。 <a href="http://www.igniterealtime.org/projects/openfire/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Openfire">GitHub</a></li><li>Spark：是一个开源，跨平台IM客户端。它的特性支持集组聊天，电话集成和强大安全性能。如果企业内部部署IM使用Openfire+Spark是最佳的组合。 <a href="http://www.igniterealtime.org/projects/spark/index.jsp">官网</a> <a href="https://github.com/igniterealtime/Spark">GitHub</a></li><li>Tigase： 是一个轻量级的可伸缩的 Jabber/XMPP 服务器。无需其他第三方库支持，可以处理非常高的复杂和大量的用户数，可以根据需要进行水平扩展。 <a href="http://www.tigase.net/">官网</a></li></ul><h3 id="miscellaneous">杂项</h3><p><em>未分类其它资源。</em></p><ul><li>Design Patterns：实现并解释了最常见的设计模式。<a href="https://github.com/iluwatar/java-design-patterns">官网</a></li><li>Jimfs：内存文件系统。<a href="https://github.com/google/jimfs">官网</a></li><li>Lanterna：类似curses的简单console文本GUI函数库。<a href="https://code.google.com/p/lanterna/">官网</a></li><li>LightAdmin：可插入式CRUD UI函数库，可用来快速应用开发。<a href="http://lightadmin.org/">官网</a></li><li>OpenRefine：用来处理混乱数据的工具，包括清理、转换、使用Web Service进行扩展并将其关联到数据库。<a href="http://openrefine.org/">官网</a></li><li>RoboVM：Java编写原生iOS应用。<a href="https://robovm.com/">官网</a></li><li><a href="http://hao.jobbole.com/quartz/">Quartz</a>：强大的任务调度库.<a href="http://www.quartz-scheduler.org/">官网</a></li></ul><h3 id="monitoring">应用监控工具</h3><p><em>监控生产环境中应用程序的工具。</em></p><ul><li><a href="http://hao.jobbole.com/appdynamics/">AppDynamics</a>：性能监测商业工具。<a href="http://www.appdynamics.com/">官网</a></li><li><a href="http://hao.jobbole.com/javamelody/">JavaMelody</a>：性能监测和分析工具。<a href="https://github.com/javamelody/javamelody">官网</a></li><li><a href="http://hao.jobbole.com/Kamon/">Kamon</a>：Kamon用来监测在JVM上运行的应用程序。<a href="http://www.kamon.io/">官网</a></li><li><a href="http://hao.jobbole.com/new-relic/">New Relic</a>：性能监测商业工具。<a href="http://newrelic.com/">官网</a></li><li>SPM：支持对JVM应用程序进行分布式事务追踪的性能监测商业工具。<a href="https://sematext.com/spm/">官网</a></li><li><a href="http://hao.jobbole.com/overops_takipi/">OverOps(Takipi)</a>：产品运行时错误监测及调试商业工具。<a href="https://www.takipi.com/">官网</a></li></ul><h3 id="native">原生开发库</h3><p><em>用来进行特定平台开发的原生开发库。</em></p><ul><li><a href="http://hao.jobbole.com/jna/">JNA</a>：不使用JNI就可以使用原生开发库。此外，还为常见系统函数提供了接口。<a href="https://github.com/java-native-access/jna">官网</a></li></ul><h3 id="natural-language-processing">自然语言处理</h3><p><em>用来专门处理文本的函数库。</em></p><ul><li><a href="http://hao.jobbole.com/apache-opennlp/">Apache OpenNLP</a>：处理类似分词等常见任务的工具。<a href="https://opennlp.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/stanford_corenlp/">CoreNLP</a>：斯坦佛CoreNLP提供了一组基础工具，可以处理类似标签、实体名识别和情感分析这样的任务。<a href="http://nlp.stanford.edu/software/coenlp.shtml">官网</a></li><li><a href="http://hao.jobbole.com/lingpipe/">LingPipe</a>：一组可以处理各种任务的工具集，支持POS标签、情感分析等。<a href="http://alias-i.com/lingpipe/">官网</a></li><li><a href="http://hao.jobbole.com/mallet/">Mallet</a>：统计学自然语言处理、文档分类、聚类、主题建模等。<a href="http://mallet.cs.umass.edu/">官网</a></li></ul><h3 id="networking">网络</h3><p><em>网络编程函数库。</em></p><ul><li><a href="http://hao.jobbole.com/async-http-client/">Async Http Client</a>：异步HTTP和WebSocket客户端函数库。<a href="https://github.com/AsyncHttpClient/async-http-client">官网</a></li><li><a href="http://hao.jobbole.com/grizzly/">Grizzly</a>：NIO框架，在Glassfish中作为网络层使用。<a href="https://grizzly.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/netty/">Netty</a>：构建高性能网络应用程序开发框架。<a href="http://netty.io/">官网</a></li><li><a href="http://hao.jobbole.com/okhttp/">OkHttp</a>：一个Android和Java应用的HTTP+SPDY客户端。<a href="http://square.github.io/okhttp/">官网</a></li><li>Undertow：基于NIO实现了阻塞和非阻塞API的Web服务器，在WildFly中作为网络层使用。<a href="http://undertow.io/">官网</a></li><li>unirest-java: Unirest 是一个轻量级的 HTTP 请求库，涵盖 Node、Ruby、Java、PHP、Python、Objective-C、.NET 等多种语言。可发起 GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS 请求。<a href="http://unirest.io/java">官网</a></li><li>brpc-java: java版baidu rpc框架，高性能、多协议、易扩展、低耦合。<a href="https://github.com/baidu/brpc-java">官网</a></li></ul><h3 id="orm">ORM</h3><p><em>处理对象持久化的API。</em></p><ul><li><a href="http://hao.jobbole.com/ebean/">Ebean</a>：支持快速数据访问和编码的ORM框架。<a href="http://ebean-orm.github.io/">官网</a></li><li><a href="http://hao.jobbole.com/eclipselink/">EclipseLink</a>：支持许多持久化标准，JPA、JAXB、JCA和SDO。<a href="https://www.eclipse.org/eclipselink/">官网</a></li><li><a href="http://hao.jobbole.com/hibernate/">Hibernate</a>：广泛使用、强健的持久化框架。Hibernate的技术社区非常活跃。<a href="http://hibernate.org/orm/">官网</a></li><li><a href="http://hao.jobbole.com/mybatis/">MyBatis</a>：带有存储过程或者SQL语句的耦合对象（Couples object）。<a href="http://mybatis.github.io/mybatis-3/">官网</a></li><li><a href="http://hao.jobbole.com/ormlite/">OrmLite</a>：轻量级开发包，免除了其它ORM产品中的复杂性和开销。<a href="http://ormlite.com/">官网</a></li><li>Nutz：另一个SSH。<a href="http://nutzam.com/">官网</a>，<a href="https://github.com/nutzam/nutz">Github</a>，<a href="https://nutz.cn/">论坛</a></li><li>JFinal：JAVA WEB + ORM框架。<a href="http://www.jfinal.com/">官网</a>，<a href="https://github.com/jfinal/jfinal">Github</a></li><li><a href="http://openjpa.apache.org/">Apache OpenJPA</a>: 实现了 EJB 3.0 中的 JPA 标准,为开发者提供功能强大、使用简单的持久化数据管理框架。 <a href="http://openjpa.apache.org/">官网</a></li></ul><h3 id="pdf">PDF</h3><p><em>用来帮助创建PDF文件的资源。</em></p><ul><li><a href="http://hao.jobbole.com/apache_fop/">Apache FOP</a>：从XSL-FO创建PDF。<a href="http://xmlgraphics.apache.org/fop/">官网</a></li><li><a href="http://hao.jobbole.com/apache-pdfbox/">Apache PDFBox</a>：用来创建和操作PDF的工具集。<a href="http://pdfbox.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/dynamicreports/">DynamicReports</a>：JasperReports的精简版。<a href="http://dynamicreports.org/">官网</a></li><li><a href="http://hao.jobbole.com/flyingsaucer/">flyingsaucer</a>：XML/XHTML和CSS 2.1渲染器。<a href="https://github.com/flyingsaucerproject/flyingsaucer">官网</a></li><li><a href="http://hao.jobbole.com/itext/">iText</a>：一个易于使用的PDF函数库，用来编程创建PDF文件。注意，用于商业用途时需要许可证。<a href="http://itextpdf.com/">官网</a></li><li><a href="http://hao.jobbole.com/jasperreports/">JasperReports</a>：一个复杂的报表引擎。<a href="http://community.jaspersoft.com/project/jasperreports-library">官网</a></li></ul><h3 id="performance-analysis">性能分析</h3><p><em>性能分析、性能剖析及基准测试工具。</em></p><ul><li><a href="http://hao.jobbole.com/jhiccup/">jHiccup</a>：提供平台中JVM暂停的日志和记录。<a href="https://github.com/giltene/jHiccup">官网</a></li><li><a href="http://hao.jobbole.com/jmh/">JMH</a>：JVM基准测试工具。<a href="http://openjdk.java.net/projects/code-tools/jmh/">官网</a></li><li><a href="http://hao.jobbole.com/jprofiler/">JProfiler</a>：商业分析器。<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">官网</a></li><li><a href="http://hao.jobbole.com/latencyutils/">LatencyUtils</a>：测量和报告延迟的工具。<a href="https://github.com/LatencyUtils/LatencyUtils">官网</a></li><li><a href="http://hao.jobbole.com/visualvm/">VisualVM</a>：对运行中的应用程序信息提供了可视化界面。<a href="http://visualvm.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/yourkit-java-profiler/">YourKit Java Profiler</a>：商业分析器。<a href="https://www.yourkit.com/features/">官网</a></li></ul><h3 id="reactive-libraries">响应式开发库</h3><p><em>用来开发响应式应用程序的开发库。</em></p><ul><li><a href="http://hao.jobbole.com/reactive-streams/">Reactive Streams</a>：异步流处理标准，支持非阻塞式反向压力（backpressure）。<a href="https://github.com/reactive-streams/reactive-streams-jv/">官网</a></li><li><a href="http://hao.jobbole.com/reactor/">Reactor</a>：构建响应式快速数据（fast-data）应用程序的开发库。<a href="http://projectreactor.io/">官网</a></li><li><a href="http://hao.jobbole.com/rxjava/">RxJava</a>：通过JVM可观察序列（observable sequence）构建异步和基于事件的程序。<a href="https://github.com/ReactiveX/RxJava">官网</a></li></ul><h3 id="rest-frameworks">REST框架</h3><p><em>用来创建RESTful 服务的框架。</em></p><ul><li><a href="http://hao.jobbole.com/dropwizard/">Dropwizard</a>：偏向于自己使用的Web框架。用来构建Web应用程序，使用了Jetty、Jackson、Jersey和Metrics。<a href="https://dropwizard.github.io/drpwizard/">官网</a></li><li><a href="http://hao.jobbole.com/feign/">Feign</a>：受Retrofit、JAXRS-2.0和WebSocket启发的HTTP客户端连接器（binder）。<a href="https://github.com/Netflix/feign">官网</a></li><li>Jersey：JAX-RS参考实现。<a href="https://jersey.java.net/">官网</a></li><li><a href="http://hao.jobbole.com/resteasy/">RESTEasy</a>：经过JAX-RS规范完全认证的可移植实现。<a href="http://resteasy.jboss.org/">官网</a></li><li><a href="http://hao.jobbole.com/restexpress/">RestExpress</a>：一个Java类型安全的REST客户端。<a href="https://github.com/RestExpress/RestExpress">官网</a></li><li><a href="http://hao.jobbole.com/restx/">RestX</a>：基于注解处理和编译时源码生成的框架。<a href="http://restx.io/">官网</a></li><li><a href="http://hao.jobbole.com/retrofit/">Retrofit</a>：类型安全的REST客户端。<a href="http://square.github.io/retrofit/">官网</a></li><li><a href="http://hao.jobbole.com/sparkjava/">Spark</a>：受到Sinatra启发的Java REST框架。<a href="http://sparkjava.com/">官网</a></li><li><a href="http://hao.jobbole.com/swagger/">Swagger</a>：Swagger是一个规范且完整的框架，提供描述、生产、消费和可视化RESTful Web Service。<a href="http://swagger.io/">官网</a></li><li><a href="http://hao.jobbole.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://lets-blade.com/">官网</a></li></ul><h3 id="science">科学计算与分析</h3><p><em>用于科学计算和分析的函数库。</em></p><ul><li><a href="http://hao.jobbole.com/datamelt/">DataMelt</a>：用于科学计算、数据分析及数据可视化的开发环境。<a href="http://jwork.org/dmelt/">官网</a></li><li><a href="http://hao.jobbole.com/jgrapht/">JGraphT</a>：支持数学图论对象和算法的图形库。<a href="https://github.com/jgrapht/jgrapht">官网</a></li><li><a href="http://hao.jobbole.com/jscience/">JScience</a>：用来进行科学测量和单位的一组类。<a href="http://jscience.org/">官网</a></li></ul><h3 id="search">搜索引擎</h3><p><em>文档索引引擎，用于搜索和分析。</em></p><ul><li><a href="http://hao.jobbole.com/solr/">Apache Solr</a>：一个完全的企业搜索引擎。为高吞吐量通信进行了优化。<a href="http://lucene.apache.org/solr/">官网</a></li><li>Elasticsearch：一个分布式、支持多租户（multitenant）全文本搜索引擎。提供了RESTful Web接口和无schema的JSON文档。<a href="http://www.elsticsearch.org/">官网</a></li><li>Apache Lucene：是一个开放源代码的全文检索引擎工具包，是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎。<a href="http://lucene.apache.org/">官网</a></li></ul><h3 id="security">安全</h3><p><em>用于处理安全、认证、授权或会话管理的函数库。</em></p><ul><li><a href="http://hao.jobbole.com/shiro/">Apache Shiro</a>：执行认证、授权、加密和会话管理。<a href="http://shiro.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/bouncy-castle/">Bouncy Castle</a>，涵盖了从基础的帮助函数到PGP/SMIME操作。<a href="https://www.bouncycastle.org/java.html">官网</a>：多途加密开发库。支持JCA提供者（JCA provider)</li><li><a href="http://hao.jobbole.com/cryptomator/">Cryptomator</a>：在云上进行客户端跨平台透明加密。<a href="https://cryptomator.org/">官网</a></li><li><a href="http://hao.jobbole.com/keycloak/">Keycloak</a>：为浏览器应用和RESTful Web Service集成SSO和IDM。目前还处于beta版本，但是看起来非常有前途。<a href="http://keycloak.jboss.org/">官网</a></li><li><a href="http://hao.jobbole.com/picketlink/">PicketLink</a>：PicketLink是一个针对Java应用进行安全和身份认证管理的大型项目（Umbrella Project）。<a href="http://picketlink.org/">官网</a></li></ul><h3 id="serialization">序列化</h3><p><em>用来高效处理序列化的函数库。</em></p><ul><li><a href="http://hao.jobbole.com/flatbuffers/">FlatBuffers</a>：高效利用内存的序列化函数库，无需解包和解析即可高效访问序列化数据。<a href="https://github.com/google/flatbuffers">官网</a></li><li><a href="http://hao.jobbole.com/kryo/">Kryo</a>：快速、高效的对象图形序列化框架。<a href="https://github.com/EsotericSoftware/kryo">官网</a></li><li><a href="http://hao.jobbole.com/fst/">FST</a>：提供兼容JDK的高性能对象图形序列化。<a href="https://github.com/RuedigerMoeller/fast-serialization">官网</a></li><li><a href="http://hao.jobbole.com/messagepack/">MessagePack</a>：一种高效的二进制序列化格式。<a href="https://github.com/msgpack/msgpack-java">官网</a></li></ul><h3 id="server">应用服务器</h3><p><em>用来部署应用程序的服务器。</em></p><ul><li><a href="http://hao.jobbole.com/apache-tomcat/">Apache Tomcat</a>：针对Servlet和JSP的应用服务器，健壮性好且适用性强。<a href="http://tomcat.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/tomee/">Apache TomEE</a>：Tomcat加Java EE。<a href="http://tomee.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/jetty/">Jetty</a>：轻量级、小巧的应用服务器，通常会嵌入到项目中。<a href="http://www.eclipse.org/jetty/">官网</a></li><li><a href="http://hao.jobbole.com/websphere-liberty/">WebSphere Liberty</a>：轻量级、模块化应用服务器，由IBM开发。<a href="https://developer.ibm.com/wasdev/">官网</a></li><li><a href="http://hao.jobbole.com/wildfly/">WildFly</a>：之前被称作JBoss，由Red Hat开发。支持很多Java EE功能。<a href="http://www.wildfly.org/">官网</a></li></ul><h3 id="template-engine">模板引擎</h3><p><em>在模板中替换表达式的工具。</em></p><ul><li><a href="http://hao.jobbole.com/velocity/">Apache Velocity</a>：提供HTML页面模板、email模板和通用开源代码生成器模板。<a href="http://velocity.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/freemarker/">FreeMarker</a>：通用模板引擎，不需要任何重量级或自己使用的依赖关系。<a href="http://freemarker.org/">官网</a></li><li><a href="http://hao.jobbole.com/handlebars-java/">Handlebars.java</a>：使用Java编写的模板引擎，逻辑简单，支持语义扩展（semantic Mustache）。<a href="http://jknack.github.io/handlebars.java/">官网</a></li><li><a href="http://hao.jobbole.com/thymeleaf/">Thymeleaf</a>：旨在替换JSP，支持XML文件的工具。<a href="http://www.thymeleaf.org/">官网</a></li><li><a href="http://ibeetl.com/">Beetl</a>：新一代的模板引擎，功能强大，性能良好，超过当前流行的模板引擎。而且还易学易用。<a href="http://ibeetl.com/">官网</a></li></ul><h3 id="testing">测试</h3><p><em>测试内容从对象到接口，涵盖性能测试和基准测试工具。</em></p><ul><li><a href="http://hao.jobbole.com/jmeter/">Apache JMeter</a>：功能性测试和性能评测。<a href="http://jmeter.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/arquillian/">Arquillian</a>：集成测试和功能行测试平台，集成Java EE容器。<a href="http://arquillian.org/">官网</a></li><li><a href="http://hao.jobbole.com/assertj/">AssertJ</a>：支持流式断言提高测试的可读性。<a href="http://joel-costigliola.github.io/assertj/">官网</a></li><li><a href="http://hao.jobbole.com/awaitility/">Awaitility</a>：用来同步异步操作的DSL。<a href="https://github.com/jayway/awaitility">官网</a></li><li><a href="http://hao.jobbole.com/cucumber-jvm/">Cucumber</a>：BDD测试框架。<a href="https://github.com/cucumber/cucumber-jvm">官网</a></li><li>Gatling：设计为易于使用、可维护的和高性能负载测试工具。<a href="http://gatling.io/">官网</a></li><li><a href="http://hao.jobbole.com/hamcrest/">Hamcrest</a>：可用来灵活创建意图（intent）表达式的匹配器。<a href="http://hamcrest.org/JavaHamcrest/">官网</a></li><li>JMockit：用来模拟静态、final方法等。<a href="http://jmockit.org/">官网</a></li><li><a href="http://hao.jobbole.com/junit/">JUnit</a>：通用测试框架。<a href="http://junit.org/">官网</a></li><li><a href="http://hao.jobbole.com/mockito/">Mockito</a>：在自动化单元测试中创建测试对象，为TDD或BDD提供支持。<a href="https://github.com/mockito/mockito">官网</a></li><li><a href="http://hao.jobbole.com/powermock/">PowerMock</a>： 支持模拟静态方法、构造函数、final类和方法、私有方法以及移除静态初始化器的模拟工具。<a href="https://github.com/jayway/powermock">官网</a></li><li><a href="http://hao.jobbole.com/rest-assured/">REST Assured</a>：为REST/HTTP服务提供方便测试的Java DSL。<a href="https://github.com/jayway/rest-assured">官网</a></li><li><a href="http://hao.jobbole.com/selenide/">Selenide</a>：为Selenium提供精准的周边API，用来编写稳定且可读的UI测试。<a href="http://selenide.org/">官网</a></li><li><a href="http://hao.jobbole.com/selenium/">Selenium</a>：为Web应用程序提供可移植软件测试框架。<a href="http://docs.seleniumhq.org/">官网</a></li><li><a href="http://hao.jobbole.com/spock/">Spock</a>：JUnit-compatible framework featuring an expressive Groovy-derived specification language.<a href="http://docs.spockframework.org/">官网</a>兼容JUnit框架，支持衍生的Groovy范的语言。</li><li><a href="http://hao.jobbole.com/testng/">TestNG</a>：测试框架。<a href="http://testng.org/">官网</a></li><li><a href="http://hao.jobbole.com/truth/">Truth</a>：Google的断言和命题（proposition）框架。<a href="https://github.com/google/truth">官网</a></li><li><a href="http://hao.jobbole.com/unitils/">Unitils</a>：模块化测试函数库，支持单元测试和集成测试。<a href="http://www.unitils.org/">官网</a></li><li><a href="http://hao.jobbole.com/wiremock/">WireMock</a>：Web Service测试桩（Stub）和模拟函数。<a href="http://wiremock.org/">官网</a></li></ul><h3 id="utility">通用工具库</h3><p><em>通用工具类函数库。</em></p><ul><li><a href="http://hao.jobbole.com/apache-commons/">Apache Commons</a>：提供各种用途的函数，比如配置、验证、集合、文件上传或XML处理等。<a href="http://commons.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/args4j/">args4j</a>：命令行参数解析器。<a href="http://args4j.kohsuke.org/">官网</a></li><li><a href="http://hao.jobbole.com/crash/">CRaSH</a>：为运行进行提供CLI。<a href="http://www.crashub.org/">官网</a></li><li><a href="http://hao.jobbole.com/gephi/">Gephi</a>：可视化跨平台网络图形化操作程序。<a href="https://github.com/gephi/gephi/">官网</a></li><li><a href="http://hao.jobbole.com/guava/">Guava</a>：集合、缓存、支持基本类型、并发函数库、通用注解、字符串处理、I/O等。<a href="https://github.com/google/guava">官网</a></li><li><a href="http://hao.jobbole.com/jade/">JADE</a>：构建、调试多租户系统的框架和环境。<a href="http://jade.tilab.com/">官网</a></li><li><a href="http://hao.jobbole.com/javatuples/">javatuples</a>：正如名字表示的那样，提供tuple支持。尽管目前tuple的概念还有留有争议。<a href="http://www.javatuples.org/">官网</a></li><li><a href="http://hao.jobbole.com/jcommander/">JCommander</a>：命令行参数解析器。<a href="http://jcommander.org/">官网</a></li><li><a href="http://hao.jobbole.com/protege/">Protégé</a>：提供存在论（ontology）编辑器以及构建知识系统的框架。<a href="http://protege.stanford.edu/">官网</a></li><li><a href="https://github.com/looly/hutool">Hutool</a>：一个Java工具集，缓存、HTTP、加密解密、DFA、JSON、分组配置文件、数据库操作、图片验证码、Excel读写、定时任务、模板引擎、邮件、Servlet、二维码、Emoji、分词等一系列工具类。<a href="https://hutool.cn/">官网</a></li></ul><h3 id="web-crawling">网络爬虫</h3><p><em>用于分析网站内容的函数库。</em></p><ul><li><a href="http://hao.jobbole.com/nutch/">Apache Nutch</a>：可用于生产环境的高度可扩展、可伸缩的网络爬虫。<a href="http://nutch.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/crawler4j/">Crawler4j</a>：简单的轻量级网络爬虫。<a href="https://github.com/yasserg/crawler4j">官网</a></li><li><a href="http://hao.jobbole.com/jsoup/">JSoup</a>：刮取、解析、操作和清理HTML。<a href="http://jsoup.org/">官网</a></li><li><a href="https://github.com/code4craft/webmagic/">webmagic</a>：一个可扩展的Java爬虫框架，架构类似Python的Scrapy。</li></ul><h3 id="web-frameworks">Web框架</h3><p><em>用于处理Web应用程序不同层次间通讯的框架。</em></p><ul><li><a href="http://hao.jobbole.com/apache-tapestry/">Apache Tapestry</a>：基于组件的框架，使用Java创建动态、强健的、高度可扩展的Web应用程序。<a href="http://tapestry.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/apache-wicket/">Apache Wicket</a>：基于组件的Web应用框架，与Tapestry类似带有状态显示GUI。<a href="http://wicket.apache.org/">官网</a></li><li><a href="http://hao.jobbole.com/gwt/">Google Web Toolkit</a>：一组Web开发工具集，包含在客户端将Java代码转为JavaScript的编译器、XML解析器、RCP <a href="http://www.gwtproject.org/">官网</a>API、JUnit集成、国际化支持和GUI控件。</li><li><a href="http://hao.jobbole.com/grails/">Grails</a>：Groovy框架，旨在提供一个高效开发环境，使用约定而非配置、没有XML并支持混入（mixin）。<a href="https://grails.org/">官网</a></li><li><a href="http://hao.jobbole.com/ninja/">Ninja</a>：Java全栈Web开发框架。非常稳固、快速和高效。<a href="http://www.ninjaframework.org/">官网</a></li><li><a href="http://hao.jobbole.com/pippo/">Pippo</a>：小型、高度模块化的类Sinatra框架。<a href="http://www.pippo.ro/">官网</a></li><li><a href="http://hao.jobbole.com/play-framework/">Play</a>：使用约定而非配置，支持代码热加载并在浏览器中显示错误。<a href="https://www.playframework.com/">官网</a></li><li><a href="http://hao.jobbole.com/primefaces/">PrimeFaces</a>：JSF框架，提供免费和带支持的商业版本。包括若干前端组件。<a href="http://primefaces.org/">官网</a></li><li><a href="http://hao.jobbole.com/ratpack/">Ratpack</a>：一组Java开发函数库，用于构建快速、高效、可扩展且测试完备的HTTP应用程序。<a href="https://ratpack.io/">官网</a></li><li><a href="http://hao.jobbole.com/spring-boot/">Spring Boot</a>：微框架，简化了Spring新程序的开发过程。<a href="http://projects.spring.io/spring-boot/">官网</a></li><li><a href="http://hao.jobbole.com/spring-framework/">Spring</a>：旨在简化Java EE的开发过程，提供依赖注入相关组件并支持面向切面编程。<a href="http://projects.spring.io/spring-framework/">官网</a></li><li><a href="http://hao.jobbole.com/vaadin/">Vaadin</a>：基于GWT构建的事件驱动框架。使用服务端架构，客户端使用Ajax。<a href="https://vaadin.com/">官网</a></li><li><a href="http://hao.jobbole.com/bladejava/">Blade</a>：国人开发的一个轻量级的MVC框架. 它拥有简洁的代码，优雅的设计。<a href="https://lets-blade.com/">官网</a></li></ul><h3 id="Business-Process-Management">业务流程管理套件</h3><p><em>流程驱动的软件系统构建。</em></p><ul><li><a href="http://hao.jobbole.com/jbpm/">jBPM</a>：非常灵活的业务流程管理框架，致力于构建开发与业务分析人员之间的桥梁。<a href="http://www.jbpm.org/">官网</a></li><li>Activity：轻量级工作流和业务流程管理框架。<a href="http://www.activiti.org/">官网</a> <a href="https://github.com/Activiti/Activiti">github</a></li></ul><h2 id="resources">资源</h2><h3 id="communities">社区</h3><ul><li>r/java：Reddit的Java子社区。<a href="https://www.reddit.com/r/java">官网</a></li><li>stackoverflow：问答平台。<a href="http://stackoverflow.com/questions/tagged/java">官网</a></li><li>vJUG：虚拟Java用户组。<a href="http://virtualjug.com/">官网</a></li><li>java8 新特性教程例子。<a href="https://github.com/winterbe/java8-tutorial">github</a></li></ul><h3 id="influential-books">有影响力的书</h3><p><em>具有广泛影响且值得阅读的Java经典书籍。</em></p><ul><li><a href="http://hao.jobbole.com/effective-java/">Effective Java (2nd Edition)</a></li><li><a href="http://hao.jobbole.com/java-8-in-action/">Java 8 in Action</a></li><li><a href="http://hao.jobbole.com/java-concurrency-in-practice/">Java Concurrency in Practice | Java并发编程实战</a></li><li><a href="http://hao.jobbole.com/thinking-in-java/">Thinking in Java | Java编程思想</a></li><li><a href="http://hao.jobbole.com/java-puzzlers/">Java Puzzlers | Java解惑</a></li></ul><h3 id="podcasts">播客</h3><p><em>可以一边编程一边听的东西。</em></p><ul><li>Java Council：<a href="http://virtualjug.com/#podcast/">官网</a></li><li>Java Posse：Discontinued as of 02/2015.<a href="http://www.javaposse.com/">官网</a></li></ul><h3 id="twitter">Twitter</h3><ul><li><a href="https://twitter.com/AdamBien/">Adam Bien</a>：自由职业者、作家、JavaONE明星演讲者、顾问、Java Champion。</li><li><a href="https://twitter.com/agoncal/">Antonio Goncalves</a>：Java Champion、JUG Leader、Devoxx France、Java EE 6/7、JCP、作家。</li><li><a href="https://twitter.com/arungupta/">Arun Gupta</a>：Java Champion、JavaONE明星演讲者、JUG Leader、Devoxx4Kids成员、Red Hatter。</li><li><a href="https://twitter.com/brunoborges">Bruno Borges</a>：Oracle产品经理、Java Jock。</li><li><a href="https://twitter.com/edburns">Ed Burns</a>：Oracle技术团队顾问。</li><li><a href="https://twitter.com/baeldung">Eugen Paraschiv</a>：Spring安全课程作者。</li><li><a href="https://twitter.com/JavaFXpert">James Weaver</a>：Java、JavaFX、IoT开发者、作者和演讲者。</li><li><a href="https://twitter.com/Java_EE/">Java EE</a>：Java EE Twitter官方账号。</li><li><a href="https://twitter.com/Oraclejavamag">Java Magazine</a>：Java杂志官方账号。</li><li><a href="https://twitter.com/javanetbuzz/">Java.net</a>：Java.net官方账号。</li><li><a href="https://twitter.com/java/">Java</a>：Java Twitter官方账号。</li><li><a href="https://twitter.com/javinpaul">Javin Paul</a>：知名Java博客作者。</li><li><a href="https://twitter.com/lukaseder">Lukas Eder</a>：Data Geekery（jOOQ）创始人兼CEO。</li><li><a href="https://twitter.com/mariofusco">Mario Fusco</a>：RedHatter、JUG协调、活跃讲师和作者。</li><li><a href="https://twitter.com/mreinhold">Mark Reinhold</a>：Oracle首席架构师、Java平台开发组。</li><li><a href="https://twitter.com/karianna">Martijn Verburg</a>：London JUG co-leader、演讲者、作家、Java Champion等。</li><li><a href="https://twitter.com/OpenJDK">OpenJDK</a>：OpenJDK官方账号。</li><li><a href="https://twitter.com/reza_rahman">Reza Rahman</a>：Java EE、GlassFish、WebLogic传道者、作家、演讲者、开源黑客。</li><li><a href="https://twitter.com/sjmaple">Simon Maple</a>：Java Champion、virtualJUG创始人、LJC leader、RebelLabs作者。</li><li><a href="https://twitter.com/jodastephen">Stephen Colebourne</a>： Java Champion、演讲者。</li><li><a href="https://twitter.com/kablosna">Tim Boudreau</a>：作家、NetBeans大牛。</li><li><a href="https://twitter.com/trisha_gee">Trisha Gee</a>：Java Champion、演讲者。</li></ul><h3 id="websites">知名网站</h3><p><em>值得关注的Java技术站点。</em></p><h4>中文站点</h4><ul><li><a href="http://www.importnew.com/">ImportNew</a>（ImportNew 专注 Java 技术）</li></ul><h4>英文站点</h4><ul><li><a href="https://android-arsenal.com/">Android Arsenal</a></li><li><a href="http://hao.jobbole.com/google-java-style/">Google Java Style</a>：<a href="https://google.github.io/styleguide/javaguide.html">官网</a></li><li><a href="http://hao.jobbole.com/infoq/">InfoQ</a>：<a href="http://www.infoq.com/">官网</a></li><li><a href="http://www.javacodegeeks.com/">Java Code Geeks</a></li><li><a href="http://blog.jooq.org/">Java, SQL, and jOOQ</a></li><li><a href="http://java.net/">Java.net</a></li><li><a href="http://java.dzone.com/">Javalobby</a></li><li><a href="http://hao.jobbole.com/javaworld/">JavaWorld</a>：<a href="http://www.javaworld.com/">官网</a></li><li><a href="http://hao.jobbole.com/jaxenter/">JAXenter</a>：<a href="https://jaxenter.com/">官网</a></li><li><a href="http://zeroturnaround.com/rebellabs/">RebelLabs</a></li><li><a href="http://hao.jobbole.com/javaspecialists/">The Java Specialist’ Newsletter</a>：<a href="http://www.javaspecialists.eu/archive/archive.jsp">官网</a></li><li><a href="http://blog.takipi.com/">The Takipi Blog</a></li><li><a href="http://hao.jobbole.com/theserverside/">TheServerSide.com</a>：服务器编程交流平台是一个老牌的IT信息网站，关注服务器端编程的，以Java和.Net周边信息为主。<a href="http://www.theserverside.com/">官网</a></li><li><a href="http://www.thoughts-on-java.org/">Thoughts On Java</a></li><li><a href="http://vanillajava.blogspot.ch/">Vanilla Java</a></li><li><a href="http://vladmihalcea.com/">Vlad Mihalcea on Hibernate</a></li><li><a href="https://www.voxxed.com/">Voxxed</a></li><li><a href="http://hao.jobbole.com/onjava/">OnJava</a>：O’Reilly Java包含最新的Java技术资讯，优质代码，完全的实例和详解。<a href="http://www.onjava.com/">官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 资源备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>技术资料合集</title>
      <link href="posts/fb8ee9c8.html"/>
      <url>posts/fb8ee9c8.html</url>
      
        <content type="html"><![CDATA[<h2 id="最新-1000-多本计算机电子书免费下载"><a href="#最新-1000-多本计算机电子书免费下载" class="headerlink" title="最新 1000 多本计算机电子书免费下载"></a>最新 1000 多本计算机电子书免费下载</h2><h2 id="整理那么辛苦，求个-Star，Fork-谢谢"><a href="#整理那么辛苦，求个-Star，Fork-谢谢" class="headerlink" title="整理那么辛苦，求个 Star，Fork 谢谢"></a>整理那么辛苦，求个 Star，Fork 谢谢</h2><p><strong>该文档来自于</strong>  <a class="btn-beautify button--animated orange larger" href="https://github.com/itdevbooks/pdf"   title="itdevbooks"><i class="far fa-hand-point-right fa-fw"></i><span>itdevbooks</span></a> 大佬，请给个Star,Fork支持一下</p><p>计算机类电子书下载，编程电子书整理下载，包括 <a href="https://github.com/itdevbooks/pdf#c-%E8%AF%AD%E8%A8%80">C</a>，<a href="https://github.com/itdevbooks/pdf#c-%E8%AF%AD%E8%A8%80-1">C#</a>，<a href="https://github.com/itdevbooks/pdf#docker"><strong>Docker</strong></a>，<a href="https://github.com/itdevbooks/pdf#elasticsearch"><strong>Elasticsearch</strong></a>，<a href="https://github.com/itdevbooks/pdf#git">Git</a>，<a href="https://github.com/itdevbooks/pdf#hadoop">Hadoop</a>，<a href="https://github.com/itdevbooks/pdf#headFirst">HeadFirst</a>，<a href="https://github.com/itdevbooks/pdf#java">Java</a>，<a href="https://github.com/itdevbooks/pdf#javascript">Javascript</a>，<a href="https://github.com/itdevbooks/pdf#jvm">jvm</a>，<a href="https://github.com/itdevbooks/pdf#kafka">Kafka</a>，<a href="https://github.com/itdevbooks/pdf#linux"><strong>Linux</strong></a>，<a href="https://github.com/itdevbooks/pdf#maven">Maven</a>，<a href="https://github.com/itdevbooks/pdf#mongodb">MongoDB</a>，<a href="https://github.com/itdevbooks/pdf#mybatis">MyBatis</a>，<a href="https://github.com/itdevbooks/pdf#mysql">MySQL</a>，<a href="https://github.com/itdevbooks/pdf#netty"><strong>Netty</strong></a>，<a href="https://github.com/itdevbooks/pdf#nginx">Nginx</a>，<a href="https://github.com/itdevbooks/pdf#python">Python</a>，<a href="https://github.com/itdevbooks/pdf#rabbitmq"><strong>RabbitMQ</strong></a>，<a href="https://github.com/itdevbooks/pdf#redis">Redis</a>，<a href="https://github.com/itdevbooks/pdf#scala">Scala</a>，<a href="https://github.com/itdevbooks/pdf#solr">Solr</a>，<a href="https://github.com/itdevbooks/pdf#spark">Spark</a>，<a href="https://github.com/itdevbooks/pdf#spring"><strong>Spring</strong></a>，<a href="https://github.com/itdevbooks/pdf#springboot"><strong>SpringBoot</strong></a>，<a href="https://github.com/itdevbooks/pdf#springcloud"><strong>SpringCloud</strong></a>，<a href="https://github.com/itdevbooks/pdf#tcpip">TCPIP</a>，<a href="https://github.com/itdevbooks/pdf#tomcat">Tomcat</a>，<a href="https://github.com/itdevbooks/pdf#zookeeper">Zookeeper</a>，<a href="https://github.com/itdevbooks/pdf#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>，<a href="https://github.com/itdevbooks/pdf#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB"><strong>大数据类</strong></a>，<a href="https://github.com/itdevbooks/pdf#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><strong>并发编程</strong></a>，<a href="https://github.com/itdevbooks/pdf#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB">数据库类</a>，<a href="https://github.com/itdevbooks/pdf#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98">数据挖掘</a>，<a href="https://mp.weixin.qq.com/s/YM7ul3jwM2rXL5iOM6LeJQ">新面试题</a>，<a href="https://github.com/itdevbooks/pdf#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><strong>架构设计</strong></a>，<a href="https://github.com/itdevbooks/pdf#%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97"><strong>算法系列</strong></a>，<a href="https://github.com/itdevbooks/pdf#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB">计算机类</a>，<a href="https://github.com/itdevbooks/pdf#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><strong>设计模式</strong></a>，<a href="https://github.com/itdevbooks/pdf#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</a>，<a href="https://github.com/itdevbooks/pdf#%E9%87%8D%E6%9E%84%E4%BC%98%E5%8C%96">重构优化</a>，等更多分类</p><p>重要说明：这些书涵盖入门和进阶所需，请大家各取所需，另外还会原创大厂面试题，陆续会提交上来，请大家持续关注这个项目。</p><h1 id="书籍分40多个技术大类"><a href="#书籍分40多个技术大类" class="headerlink" title="书籍分40多个技术大类"></a>书籍分40多个技术大类</h1><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://github.com/itdevbooks/pdf#c-%E8%AF%AD%E8%A8%80">C</a></td><td><a href="https://github.com/itdevbooks/pdf#c-%E8%AF%AD%E8%A8%80-1">C#</a></td><td><a href="https://github.com/itdevbooks/pdf#docker">Docker</a></td><td><a href="https://github.com/itdevbooks/pdf#elasticsearch">Elasticsearch</a></td><td><a href="https://github.com/itdevbooks/pdf#git">Git</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#hadoop">Hadoop</a></td><td><a href="https://github.com/itdevbooks/pdf#headfirst">HeadFirst</a></td><td><a href="https://github.com/itdevbooks/pdf#java">Java</a></td><td><a href="https://github.com/itdevbooks/pdf#javascript">Javascript</a></td><td><a href="https://github.com/itdevbooks/pdf#jvm">JVM</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#kafka">Kafka</a></td><td><a href="https://github.com/itdevbooks/pdf#linux">Linux</a></td><td><a href="https://github.com/itdevbooks/pdf#naven">Maven</a></td><td><a href="https://github.com/itdevbooks/pdf#mongodb">MongoDB</a></td><td><a href="https://github.com/itdevbooks/pdf#mybatis">MyBatis</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#mysql">MySQL</a></td><td><a href="https://github.com/itdevbooks/pdf#netty">Netty</a></td><td><a href="https://github.com/itdevbooks/pdf#nginx">Nginx</a></td><td><a href="https://github.com/itdevbooks/pdf#python">Python</a></td><td><a href="https://github.com/itdevbooks/pdf#rabbitmq">RabbitMQ</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#redis">Redis</a></td><td><a href="https://github.com/itdevbooks/pdf#scala">Scala</a></td><td><a href="https://github.com/itdevbooks/pdf#solr">Solr</a></td><td><a href="https://github.com/itdevbooks/pdf#spark">Spark</a></td><td><a href="https://github.com/itdevbooks/pdf#spring">Spring</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#springboot">SpringBoot</a></td><td><a href="https://github.com/itdevbooks/pdf#springcloud">SpringCloud</a></td><td><a href="https://github.com/itdevbooks/pdf#tcpip">TCPIP</a></td><td><a href="https://github.com/itdevbooks/pdf#tomcat">Tomcat</a></td><td><a href="https://github.com/itdevbooks/pdf#zookeeper">Zookeeper</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a></td><td><a href="https://github.com/itdevbooks/pdf#%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB">大数据类</a></td><td><a href="https://github.com/itdevbooks/pdf#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a></td><td><a href="https://github.com/itdevbooks/pdf#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB">数据库类</a></td><td><a href="https://github.com/itdevbooks/pdf#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98">数据挖掘</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#%E6%96%B0%E9%9D%A2%E8%AF%95%E9%A2%98">面试题</a></td><td><a href="https://github.com/itdevbooks/pdf#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1">架构设计</a></td><td><a href="https://github.com/itdevbooks/pdf#%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97">算法系列</a></td><td><a href="https://github.com/itdevbooks/pdf#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB">计算机类</a></td><td><a href="https://github.com/itdevbooks/pdf#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></td></tr><tr><td><a href="https://github.com/itdevbooks/pdf#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95">软件测试</a></td><td><a href="https://github.com/itdevbooks/pdf#%E9%87%8D%E6%9E%84%E4%BC%98%E5%8C%96">重构优化</a></td><td><a href="https://mp.weixin.qq.com/s/YM7ul3jwM2rXL5iOM6LeJQ">第三版-面试题</a></td><td>每天都有更新</td><td></td></tr></tbody></table><h2 id="新增：高清172份，累计-7701-页大厂面试题-PDF"><a href="#新增：高清172份，累计-7701-页大厂面试题-PDF" class="headerlink" title="新增：高清172份，累计 7701 页大厂面试题 PDF"></a>新增：<a href="https://github.com/souyunku/DevBooks/blob/master/docs/index.md">高清172份，累计 7701 页大厂面试题 PDF</a></h2><h2 id="新增：高清172份，累计-7701-页大厂面试题-PDF-1"><a href="#新增：高清172份，累计-7701-页大厂面试题-PDF-1" class="headerlink" title="新增：高清172份，累计 7701 页大厂面试题 PDF"></a>新增：<a href="https://github.com/souyunku/DevBooks/blob/master/docs/index.md">高清172份，累计 7701 页大厂面试题 PDF</a></h2><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><p>21天学通c++_第7版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iFtWjkx8awd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Pv45msRWe0sCurOM9RR9uQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qvdj</p><p>C++ Primer Plus（第6版）_中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iMRGakxl2lc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1EVlg9WH-6kJjmjjTjaty0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wsfu</p><p>C++ Primer第5版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iFmCLkx8e4j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oxGcN9OoQs2tRXs3sas_XA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qeke</p><p>COBOL语言（上）谭浩强.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ix653kx8ebg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1IZq6yXLmUB22rZKkfxSbjw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：stqa</p><p>COBOL语言（下）谭浩强.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOFeMkx842h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10FlZxU52Vrsy8kUo-MnSoA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：drsv</p><p>C程序设计语言（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iscm1kx84di">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nTISepdSatvOMRcMu6Zw_A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kuhe</p><p>C程序设计语言（第二版）习题解答.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i2SkIkx84ej">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MZDmM5AqyKsDQ1k3reeZ0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hphb</p><p>C程序设计语言（第二版）新版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iRieOkx84hc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17Lb6J7LM0kVy_ZSOp7Ubtg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pjcf</p><p>C程序设计语言（第二版）中文译版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i4Mqvkxl7ri">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1W7Xb8ubRnLDLWUATMxblxQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rdvu</p><p>C程序设计语言（英文第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i5DhSkx84oj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1E_hMl1VLVlDn44ew_mrHrw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rfne</p><p>C大纲.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iX8jpkx84te">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13zvfjFYaY6Pl8VutieLNHw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vrtf</p><p>C大全语言.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iXei8kx852d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Rd6trlbNhigXbMsg4uMYnA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jfwp</p><p>C和指针.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iGENEkx85ta">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1R1hZBoyKkKLj9EBC2ZUPtw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tcdg</p><p>C基础班范例代码训练.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iAxOEkx85xe">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/167--PYVLr5Uc-Fa4_pCXzQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mrah</p><p>C与指针.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i9IGjkx866d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1x9JB86DDKi6s9dldrJsa-w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uxcg</p><p>C语言编程精粹.PDF.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/igjXpkx86he">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1W8aWffFDOvubzfNHEC7-Cg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vgds</p><p>C语言参考手册第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iL8Jfkx86pc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Z2ErBjh1ERW5-lbqR9R4Uw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：twgf</p><p>C语言程序设计现代方法（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i1X6bkx8y1g">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oaxzlxeaCkYGXAEn-mCSgA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dfey</p><p>C语言大全第四版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ihGbpkx8yid">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xVIHCdekVp3iRibektJ7bg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：skvj</p><p>C语言函数大全.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iYowkkx8ylg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kDqsE3BP2UC7XupD2FzRXA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：krkk</p><p>C语言解析教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iYmUXkx8yvg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TYbhCfo1t3dIm0gAjLeOYw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：brmp</p><p>C语言深度解剖.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iQR1zkx8yyj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wc0IeIWQR28jG0uOtqKz_A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fjxw</p><p>C语言实现病毒源码演示.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iO1Q5kx8yza">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LZ1VEwZXoYuVJlN6nxAi8A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：60dt</p><p>C专家编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i12vOkxll0f">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12jZ8IHA1Cb__KMsFDa4eqA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gkup</p><p>Linux操作系统下C语言编程入门.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i8JH3kx8zde">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Nx2y1lTvdEpBuf4QhV0fyQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vrtj</p><p>华为C语言规范.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ivg6Gkx8zgh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yC1zRs37Sy-6trq4zV8kQg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：awkd</p><p>可变目标C编译器设计与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ixH3vkx914h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L9NuvV6SdF-8Bi-zreB4Ag">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vjdh</p><p>数据结构-教程c语言版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iocoikx91pi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TEjTJ05RRfnygjQlSkXKiw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ccwm</p><p>数据结构（C_语言版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iq3rekx917a">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_787HiYRbxx5U-9W6t779w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：medm</p><p>数据结构（C语言版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ioouykx91ng">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1E--h4WLOoeNH8wpHZ7zajA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sscd</p><p>数据结构、算法与应用C++语言描述原书和引2版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i8E2Zkxlsgd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1V7QAFKLY_S9eYeoeRzCgvQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jjgt</p><p>算法：C语言实现第1-4部分基础知识、数据结构、排序及搜索.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iwTadkx92sh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1h4e4RBl8jgj2netJV1nYfQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykat</p><p>网络环境下的C语言编程技巧及实例.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iaQELkx92yd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1d7iJN5JVJL_UrzpubO1k9A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hjht</p><p>自制编程语言基于C语言.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i3JC8kxlzti">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vk5rAD2pAscURdISdhR2ig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ybqh</p><h2 id="C-语言-1"><a href="#C-语言-1" class="headerlink" title="C# 语言"></a>C# 语言</h2><p>ASP.NET.2.0.XML.高级编程（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iykcDkx9wxc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1I7oyBgWo1wrlQ5iIIE1m8w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ngna</p><p>ASP.NET.2.0.高级编程（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iUm0ekx9p1i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yQaRuIvML31ealbl_EZHqw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qsts</p><p>ASP.NET.2.0.入门经典（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iVn3Nkx9s3i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jogs5FFdaRTibdhw9KjlDQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nqjp</p><p>ASP.NET.2.0.数据库入门经典（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iyVSAkx9smh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1C5dfWMcQCJZak0VQqWtw1g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gaqh</p><p>ASP.NET.基础教程-C#案例版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i0I0pkx9sxi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mIxJUSHRJ0fNIyOaGUo8xA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gnaw</p><p>ASP.NET技术内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i9p1nkx9tyf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SJ_DX1wVXY1u4MdZmurpZg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gryv</p><p>C#.4.0完全参考手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i44Sskxa01e">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eCg6Th8Ouc8Q_mlQFScblg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vqkr</p><p>C#.COM..编程指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i7sh4kx9u2j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oQwLHhblmo3EprJKAlq-1A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ncbr</p><p>C#3.0完全自学宝典.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iODgKkx9veh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DTLQFDSfuMsivoo8XLHi2g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fejw</p><p>C#编程宝典十年典藏版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOQOUkxa6sh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pLtxx5w0ccPNsTKk_0d9yw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cyjp</p><p>C#编程参考手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/itzFDkxa4eb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18XKKpwlV9R8vUX4TPdYmRA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tckx</p><p>C#编程思想.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i2AiQkxa29e">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sESNaACnZyNwtEOXnbZtbA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：augj</p><p>C#编程语言详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ij48tkxa1mb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1USE8I8Ig_lJrWrBsBss7hw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xqkw</p><p>C#程序开发范例宝典（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CY60VTs0FdlJJbKN-RciWA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：eyhe</p><p>C#程序员参考手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iKmc8kxaa1e">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fMjV4BVdfxHpbTbeMipHxg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hbbp</p><p>C#技术内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iwvIJkxad8j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VA3R90-5tHSyh2Ak7dTm3Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wywp</p><p>C#入门经典（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iet3jkxahyj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qBKgqHgs4dAJsHvopasEjw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xafy</p><p>C#软件项目开发全程剖析-全面透视SharpDevelop软件的开发内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOhl0kxai6h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10Up6eUcpL-JuRL9RuaqjqA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cxnv</p><p>C#设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i5kBOkxaibc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fUn2p0sSb-dPdIrfg9KmKg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gnns</p><p>C#网络编程技术教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iCoHMkxaj7e">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17Xskb_NvWezmdabyzRh8fw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cerg</p><p>C#项目开发案例全程实录（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ivNoskxakzi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QEa2INDhZhvbGSlAh_LT9w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：agjn</p><p>C#学习笔记.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iuDRekxrw6d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hYrT0cLyF5uUMIoUNElXBg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：veex</p><p>C#应用程序开发全程演练-从灵感到实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iuA6Dkxrzte">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yi9CiqleBP6BfR4Xf9NPlw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qbew</p><p>C#与.NET4高级程序设计-第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iL0D9kxs7qj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mGs2xNNvmPJ54AHsbmhShA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pyby</p><p>C#与.NET技术平台实战演练.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i0UaPkxscsb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Z1Oar2-0wm53BCA-f6zElw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ebvx</p><p>C#字符串和正则表达式参考手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iENCCkxal8h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jZxa5iTBvVN8iUHi9Q8yjw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cmth</p><p>C＃高级编程（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iY8hHkxacni">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vQTjdPk4hyF-efpbdYj_fw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mtpu</p><p>Microsoft.C#.Windows.程序设计（上下册）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i77A1kxamni">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UQSZpztOy3ITdZurmfV1ww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fqnq</p><p>Programming.ASP.NET.中文版（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i9GvLkxanub">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19A0krBK5AsbjC2MJIfPfWA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jssu</p><p>Programming.C#.中文版（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/itoRZkxaq1a">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JDZNMzG8WuvaYnizfuTidA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dmtx</p><p>Visual.C#.NET.网络核心编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iYlxmkxaqaj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1b1eatMs_xYJffB0LJLTC5g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jsrq</p><p>VisualC#.NET案例开发集锦.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ibtTTkxatwj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dW2LSBwkGlKUSDhBbIfFMQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gfcp</p><p>VisualC#.NET网络编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iQ1d8kxaumf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1x1FLbBHDRzHRLDFJHSljSw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kxgn</p><p>Windows应用高级编程-C#编程篇.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iWj4Nkxav0j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/192y69NahClrpiI2hkF80gA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gbpp</p><p>程序员突击Visual.C#.2008原理与系统开发.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/igcpSkxax4f">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OWf7AK5ezToNiQMo0AZyQQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：murm</p><p>叩响C#之门.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iaV7Xkxaxpg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lHUal4JysWeqwmBXYiHuuw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：atej</p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>Docker-从入门到实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iMYo7kxbaaj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ccTG4htfo-jZ1Nb8nnKeNQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：enbt</p><p>Docker_practice.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOELrkxba8h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1V8vGD2R9OG2a88HpDxG_rg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fraf</p><p>Docker经典实例.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/imwLzkxbacb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sJWlwtTSnHZhLneX2dBfaQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qjej</p><p>Docker容器与容器云（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iMsrNkxbb3i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1R5PqIB_G9pIKi3b2Rzlaeg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xfnw</p><p>Docker入门白皮书.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iGMwKkxbb5a">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16HDLIsj_Rd0tgfKpbTCEgw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kskk</p><p>Go语言实战（异步图书）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ilZK4kxbb7c">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ZdtpkG6DMd3t7-ywJOWRCQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sedj</p><p>Kubernetes实战（套装共2册）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOexQkxbblg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/15K6r6JEsdGVuQTVIydruxA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xueu</p><p>SpringCloud与Docker高并发微服务架构设计实施.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iXnsOkxbdhe">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1c6dNs1T6klinsbNtHl32GQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xrdb</p><p>SpringCloud与Docker微服务架构实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i4H8xkxbe4h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1t0r0CuIyV1fcR4l5M83ttw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：crbf</p><p>第一本Docker书.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ioCPhkxbe5i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12US2-reChfZgwy3eqpJpGA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uvmt</p><p>深入浅出Docker.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iCKMWkxbf8h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13-Ov2ZrCVAmHz13Ah8Xmpg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mfkw</p><p>微服务架构实战基于SpringBootSpringCloudDocker.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/im4CZkxbieb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KekRLkLCvLTbq24J3TNWiQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nrse</p><p>微服务架构下Docker实践，以及Docker在测试环境的应用.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iVmIXkxbigd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ngvZs7yWfuRxUxxST43LzQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pkmj</p><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>BetterELK,新浪实时日志分析服务进化.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iP88Ukxd2wf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1uUxY9AtKQEy-if3fKkhK4g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kfgc</p><p>Elasticsearch-guide-chinese.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/isNeDkxd30j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Df0xspbMMVJn20-C522niw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：baxm</p><p>Elasticsearch-the-definitive-guide-cn.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iuT60kxd38h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Td3Y7k0gQpL4jpQfmc05uw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yrfs</p><p>Elasticsearch6.1官方入门教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iu6Jokxd2yh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MXfjtz5ynkY_u08UDOCaLw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：knfe</p><p>Elasticsearch大数据搜索引擎.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iCJ3Dkxd8mb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1j4K2lZpt7ywpjo-cyodlyg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mxuu</p><p>Elasticsearch分布式大数据搜索.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOGbbkxdade">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AHxsGuZJFXDxZoGjOcBXmg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bytq</p><p>Elasticsearch服务器开发（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iCU5Ykxdb7e">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LcjmOWCBbLfEPT_woN1GuA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xatu</p><p>Elasticsearch集成Hadoop最佳实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iG4M4kxdcha">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bOwD5PBqfD31NJfWFXso3g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tfcp</p><p>Elasticsearch技术解析与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ija6Bkxdckd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1x5QOR_wrxC5BV9JorAmxtg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jews</p><p>Elasticsearch技术解析与实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iunVckxdgkh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HdKY0kVDVzc6KKkvU8fK5Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：afay</p><p>ElasticSearch可扩展的开源弹性搜索解决方案.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i1APTkxdhgj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12mH096foYT5y4YWsHFlSeA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mxjr</p><p>Elasticsearch权威指南（中文版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iScNMkxdhtc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VV9O_660sDBo_YB62QYx-w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xwtf</p><p>ElasticSearch入门.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iTWCxkxdi4d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BzO1GTBbHSmwca68Vdlbmw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hukk</p><p>Elasticsearch实战inaction中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ipDJIkxx1re">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BpK6r6MW29zb46lH_wG0yA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pveu</p><p>SpringBoot集成Elasticsearch7.4实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ip2uYkxdidc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16GhqhpmVUfKHLll3z_dnlQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tewy</p><p>大数据搜索与日志挖掘及可视化方案++ELK+Stack++Elasticsearch+Logstash+Kibana++第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i3E26kxxjqb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Q1DrL8kopQDJPvTESqy9Sw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vudd</p><p>深入理解ElasticSearch.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/izKODkxdrwf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1A8_KVHXsuFe6u--XZgL6eA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qxpf</p><p>实战Elasticsearch、Logstash、Kibana++分布式大数据搜索与日志挖掘及可视化解决方案.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iAwXbkxdpyf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xnY8s6i7hI8bzRmy38s-sQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ncce</p><p>数据分析与决策技术丛书ELKstack权威指南,饶琛琳编著,P394.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i4AjAkxdila">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Rugsxq8mfnK_tEtFB80Q4w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pgab</p><p>搜索引擎核心技术与实现（基于Lucene和Solr）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i2KLFkxdinc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1y4THdUHLG8WTa5ipYTovKA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ffjd</p><p>最新版Elasticsearch调优搜索速度.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iNXvZkxdjrc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ewPAjJ6zWPeBHLPQx66QVQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：trqt</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>GitBook（中文版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iLUKFkxe29i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xhG-q_BEFY-U4uuY9oybDQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kvak</p><p>GitCheatSheet中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/il9lkkxe2ed">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1M_aVeiwUR0Hwf9l7SjziFg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wvwp</p><p>GitforTeams.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ibym9kxe2la">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LY1Ie9FN78aUybcNxM4BcA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qrrp</p><p>GitHub入门与实践（日）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iyqIekxe2ti">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Db3YzGgVjQt9kSMg8HfcUg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ahjm</p><p>Git版本控制管理（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ioRcDkxe31g">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eJTo4qBAsiGvCSVLuU7SPA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：adrk</p><p>Git版本控制管理（第二版）迷你书.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iLkpMkxe3ni">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oimhw2LAiuVkD_8gnV_NrA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yyct</p><p>Git官方手册中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i9bekkxe3za">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NC6Oi4HdJ5b72VKaIdJR7Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：saqd</p><p>Git讲义-深度讲解.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iLMXTkxe4de">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hRGXi6L31eOj6YhTPaEUnA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：swyh</p><p>Git教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ioXiZkxe4ja">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kOBBwQi_cC6j3QvgRr6RuQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gcrp</p><p>Git权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iaye2kxe62f">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13bGqDQ35cJgVfp0ht9SkqQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wkak</p><p>Git中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iR2Swkxe8pa">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Hlh9b3NX6roVOruQ8-RcuA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pmux</p><p>Git中文手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iEl0ikxeana">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1gNKclKvcNITBXDniY0dadA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qtpb</p><p>ProGit中文版本.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iHn3pkxeawj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OkqTAyfUoCFOzgnYmImMDA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xkry</p><p>ProGit中文第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iMrizkxebib">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1l98hVaPhqHkYq3nSkETZUA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vwgk</p><p>版本控制之道使用Git.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iW6o3kxec3c">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GpOXPOBpfB8Yi15VGnIgKQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nfth</p><p>常用Git命令清单.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ifScYkxec7g">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yx5lwu0gskwfmHvn7D7M1g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ajkn</p><p>从+0+开始学习+GitHub+系列.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ifHzvkxecla">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dakSbdxFubYb_lNoApeaqw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qbqg</p><p>完全学会GITGITHUBGITSERVER的24堂课.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ij3V8kxedhc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12Hk4dMkfkE1L0WERrEa-qg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jbpj</p><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop搭建与Eclipse开发环境设置.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iQTivkxehba">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-yw-COXzqlIlOl95h8I74w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rvda</p><p>Hadoop大数据分析与挖掘实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iAlA8kxei4j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_ndlcCJjmYnPk7s914U__w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pwvr</p><p>Hadoop高级编程-构建与实现大数据解决方案.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i4JMrkxeich">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ISRomZnhzO3pTSE33HLvYg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xubc</p><p>Hadoop公平调度器指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ia2mkkxel5i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Be1AoEQZyIRVlRf261bbOQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rwyq</p><p>Hadoop技术内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iHJbDkxemed">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Nxfu7ytEhdfTDv6_G6TyNA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rvvg</p><p>hadoop简介.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iLHp3kxemwb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HjPoXCY4-aQ9OJiXNGvdfA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ebfm</p><p>hadoop开发者第三期.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/imUQnkxenfa">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qnnDciMx68FIYpGqj0ZrnQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uxhs</p><p>Hadoop开发者第四期.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iPUH6kxenoj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Pfi3AUbMfcCKz-jG85orUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tbgx</p><p>Hadoop开发者入门专刊.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iGk6wkxente">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/107Z2PCG-Q_Njiyg7bV0ibQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kejg</p><p>Hadoop权威指南（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i1S3lkxeo7i">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CFuFsngiC9nmKwc2J4_zCw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pvab</p><p>Hadoop权威指南（中文第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/irntIkxepxa">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1e1oWfYr8atVYQA3Swhb71w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tqar</p><p>基于Hadoop平台的亿贝用户邮件数据分析（苏立）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iHLQekxeqad">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1obIfdffIOX8w348MC9njVQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gcvr</p><p>实战Hadoop：开启通向云计算的捷径（刘鹏）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iTT9Hkxered">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1l-HrGhtJ3fZ6nJou4gnC7A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hsbw</p><p>数据算法HadoopSpark大数据处理技巧.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iTxcMkxetbc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OWxadCpz_iqE1Fq4cVR9JA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hxxf</p><p>数据算法：Hadoop、Spark大数据处理技巧.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iTxcMkxetbc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CL8-WG7XQOxbWLisgb7TZw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qdey</p><p>在Windows上安装Hadoop教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i8EVmkxetcd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1w1JBUHP9K4E5QwYje-UM3A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pmkv</p><h2 id="HeadFirst"><a href="#HeadFirst" class="headerlink" title="HeadFirst"></a>HeadFirst</h2><p>Head First Ajax（中文版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iXpYUkxeuhe">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-RyMwcVfgc2PplMHm0UKww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pyuq</p><p>Head First C# 第二版-中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iAQ0rcy9gH2yO1DEgv7Y_g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mhtd</p><p>Head First HTML5 Programming 中文版 .pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ioWjikxev2f">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-uMMg_GjFQedOAJQQ3UrgQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wjyy</p><p>Head First HTML与CSS、XHTML.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iH1LQkxeypg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/167awhMP91mzcBGFPoIcLDA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hspd</p><p>Head First Java 中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iEwj9kxf18h">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/155P-tL24jowuGMtNdY2wSA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bvpy</p><p>Head First JavaScript 中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iERoWkxf5zi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1cRLHU-NKIA0nQ2XMzHp2sA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fkby</p><p>Head First Java第二版涵盖java5.0.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iXHoSkxf8md">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NM7eb06vGK2iBMOF_6uEYg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cebe</p><p>Head First Networking 中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iZ0Pwkxf9if">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dD968W_tr-SUq1i_HdubVA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：upkx</p><p>Head First PMP 中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ijZbskxf9tg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DeZdj4zh7hxDnpINLdq0RA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xxau</p><p>Head First Python 重视大脑的学习指南  中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i0A5nkxfa9c">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hLAU9HqUbpgh1PQ7DVn3gQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：avey</p><p>Head First Servlet JSP.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i7J8Zkxfcsd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mlSoZJ42ukvB7Rl0YBRGdw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：apkv</p><p>Head First Servlets and JSP 第2版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i83VIkxfhni">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/139L7zhrwsgNhgIGmf1jRZQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pysa</p><p>Head First 设计模式（中文版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i6b7Wkxfj6d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GX8ZZT2_ISqJv47sBwFvgQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bafw</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>21天学通Java.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iwPMNkxfsde">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KcnqkVnoSiiOkZmkzYNGfQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jeyg</p><p>Effective+Java+中文第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i4R1ikxfsub">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13qz0iXAQdfv-7FiXiodIww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xqgg</p><p>EffectiveJava（中文版第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iEXrIkxgepi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JCdDt9dMSxIT01jBSBRDIg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cpen</p><p>Java8函数式编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/igZEhkxgc2d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_-85Wx3LYJHSktFYCH_hUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pjan</p><p>Java8中的炫酷特性和Java9中的新特性-杨晓峰.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iDzpOkxgfkj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1O6euAamgF3Y7v1JnfGyjjQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jkwc</p><p>JavaNIO（中文版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iWsplkxgfnc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/139eXkJl2jtagTZm-ROxL7A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tpaq</p><p>JavaOOP-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iRe3ekxgg7c">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vubz7vJybbosl3iLFWPhCg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pkmp</p><p>JavaRESTfulWebService实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i1xFVkxghvc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1O7km01HayjzW_yYRCyR3gw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cfju</p><p>JavaServlet和jsp学习指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ia4bkkxgkqf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1muJPmcUcjV4k4wBQqPT8yA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：daqb</p><p>JavaTCPIPSocket编程（原书第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iFwCJkxgnna">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/197jWtCamqIFQdqiPcrQCew">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vynk</p><p>JavaWEB服务.构建与运行.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i2MGbkxgo0d">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1z1XCRAtblPvbgt9qN8CMVQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gcrr</p><p>JavaWeb企业项目实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iNjuGkyordi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iZGKcMOmQmMYuxUfAkJEbA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aumu</p><p>JavaWeb整合开发王者归来.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1U2pDBLUyYqvIjo7w7gRQZg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fprs</p><p>Java编程的逻辑.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ijGyakxgtwf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PiN48omo9JLLzb63sP0Bkw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xtxs</p><p>Java编程思想第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iJiGqkxhdeh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1p_E22a4VUpWVYgzqMmfDIA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mnpq</p><p>Java编辑思想（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iGM8Fkxhdjc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eLEyRlUpxZqp5_ISdZu86w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kfaj</p><p>Java程序员修炼之道.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iHblakxhfmh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zhIZCnmLFzbBCxtwtxKltg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fpea</p><p>Java从小白到大牛精简版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iapU1kxhfqb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Kd7gdxnNtOzHDLpLYxk7vA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kaqv</p><p>Java典型模块与项目实战大全.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ie7Xvkxhjsh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1x_SsiWi2OLw3HF1CRWOJSw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：assw</p><p>Java关键技术JSP与JDBC应用详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iWXqykxhlri">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RImaM6qZcRlN_ueUN2MaEQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tscq</p><p>Java核心技术卷一基础知识第10版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iJTXAkxhngj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1urz-kz246b7KJEMREYIJyA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cjmy</p><p>Java核心技术卷二高级特性原书第10版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iVCbnkyoaha">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1biNDg0wY9NhzPEbYYFqKhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cjzp</p><p>Java基础概念.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iaqL3kxhnib">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1l8iKRzjGPYBXwrTm281LPA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wkfu</p><p>Java基础教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iqFPekxhnmf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wrCF3ttjvPTmMavEx27UMg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rrma</p><p>Java开发之道.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i2vEZkxhs6j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wgivWU-eJuvzXC3DILpEzA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rvpq</p><p>Java数据库应用基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iEJ8Ckxht7g">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17DQzOJFnaXQ2M6RWNvzo8A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fawd</p><p>Java特种兵上.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iJTuVkxhwqd">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iGdCv9y6HCfMwA8QKbsmTA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tmgf</p><p>Java图形与网络游戏开发.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iayknkxhx6j">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1B0XNM5dr7tijN-CMMKNOUg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fjjb</p><p>Java网络应用开发.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ia9AHkxi1jg">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OS8fQKKsjgcHd23oRIJ0Jw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bdxn</p><p>Java与模式（清晰书签版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/ik4Aqkxi1zc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qbwz2PMClWo11Eb1zrl1EQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：asfv</p><p>Java语言程序设计-进阶篇（原书第八版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iyQI3kxi2fi">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GdX636VmycTU9t-4OgbgIQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nqnn</p><p>Web安全开发指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iOSPgkxi2jc">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1h5fZHvtNbodM7hZbrpRLCw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rhsj</p><p>Web性能测试实战详解+Web开发典藏大系.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iTd6Akxi4kf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zC2VwRjNr8mT69ENmNUJ0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bsct</p><p>Web应用安全权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iEc6nkxi5of">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17YmTumIWjckrqBcP6Gu4RA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ydkm</p><p>Web应用开发.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i72VPkxi7mf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1n4pmkCkYbk9cDFGvMLW1HQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sfqe</p><p>编写高效优雅Java程序.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iqkHBkxi7oh">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/111RMs5dIwOt9I09aE4iMhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nskv</p><p>菜鸟成长之路—Java程序员职场全攻略.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iAbu0kxi9di">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bcnbsfSP-agoIFKUUPwgzQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vxjx</p><p>大型网站系统与JAVA中间件实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iqHZdkxig4b">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MliFXVP-mjZoMWs_RpANXA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hdbx</p><p>分布式Java应用基础与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i5ci2kxihcf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1X2x4RA1D2-Ig8vcr1KOrqg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dbeu</p><p>疯狂Java讲义.pdf&nbsp;&nbsp;&nbsp;&nbsp;nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fYIQdDNdncR3JyxAr_x-dw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hejg</p><p>高性能响应式Web开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i9wUOkxiife">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1EcPNoFTVUtHePBWePLm7tw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bafb</p><p>构建高性能Web站点.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/icEMlkxijkf">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13gYFTc0bRJvR87nY51slqQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ndfc</p><p>解密搜索引擎技术实战Java精华版.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iX3Z8kxikne">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Wjiwni7ABH2R1jUIfvrHUQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：susc</p><p>了不起的Nodejs将JavaScript进行到底.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iXFJkkxilyb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1O8Aaw8iyWNwVrD6VN6mtQQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xbbx</p><p>零成本实现Web性能测试.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iUq4xkximsb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1XS1Jy7fHc5koAkh9xbqcDw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：varj</p><p>码出高效：Java开发手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/i34i6kxirqj">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hlLIkAJYIkmeFZuUFkmrOA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fqxs</p><p>深入分析JavaWeb技术内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iuhbakxitgb">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14QwWsW4jClVyL6SepaZrNg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fbqt</p><p>使用Java.Web服务构建SOA.pdf&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://itdevtools.lanzoux.com/iyx8mkxiuab">不限速下载</a>✅&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BsDNPiQs6Lml_UkPP6aUNQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：lof7</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>JavaScript基础教程（中文第八版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KrBmT24VTDJblH9pfGTzOw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bxer</p><p>JavaScript框架高级编程应用Prototype、YUI、ExtJS、Dojo、MooTools.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dCyMSxlsdX_szCA05PB63A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hvfb</p><p>JavaScript框架设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1x226ttlJYfSYquDEojIRMQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：akbn</p><p>JavaScript面向对象精要.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GXRA3uhy_-tgksrw1Sl9Pg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jvrm</p><p>JavaScript权威指南（第六版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AhnItsQRwZN5OKH_o_amxA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cxuf</p><p>JavaScript权威指南（第五版）中文版（上）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ya6dqxo2zKB-oOolJf_oZw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vpmn</p><p>JavaScript权威指南（第五版）中文版（下）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1c4ATUyl12uM7xL1xqUGtAg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qdar</p><p>JavaScript入门经典（第五版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jmmwbpkUaEnn8TD4Kv0x_g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wawc</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>glibc内存管理ptmalloc源代码分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zrCQ4sOaDKl17P8KfD6pxA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jnbu</p><p>HotSpot实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Xpa-yfb221Kdq-FIwWbmug">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aqee</p><p>Java+JVM.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1A93OKyY11xjyGu8Y4T4wwQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dwyb</p><p>Java性能权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sXEQx5eXIhLAq_hi70_1YA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wfan</p><p>Java性能优化权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1gBnhP28-YJjzojiRlKEakQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aapq</p><p>Java虚拟机并发编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vTwsR8WgRpq--yKoBzR40A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yabq</p><p>Java虚拟机规范-JavaSE7.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RitXq-hZRH-tZiVK--NYtA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hnab</p><p>Java虚拟机规范-JavaSE8版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1uOmGGM4SdWvtZsOlGIVIww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yadt</p><p>Java虚拟机解释执行机制研究.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/146F4WskyY_6WmbBjhK_olQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hffn</p><p>JVM.Spec.v9.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1crTDBQ48j8pBSmJ41eY7Ag">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yjpk</p><p>JVM定制改进.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CFcHX0HasDNgOBl7tRLRZA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：etkj</p><p>Twitter的JVM性能调优经验.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1uWIvg9guDm4JZKnAhb0Gtw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：swpn</p><p>揭秘Java虚拟机-JVM设计原理与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GrNNvxFlqJsiNnONbRiXTw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uprt</p><p>垃圾回收的算法与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Iiwe_Aw2MwdqbufDzJtcBQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ynpk</p><p>垃圾回收算法手册++自动内存管理的艺术.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iKLOyw9YS2CT_1qTcHN-LA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jcpg</p><p>深入Java内存模型.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NOyDh5_zyeI_J1MGmeQfjw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mmkk</p><p>深入Java虚拟机.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lOU9AMAviJLzQ_bEt6zw5Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ghds</p><p>深入理解Java虚拟机：JVM高级特性与最佳实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1T0bTPTLwwOPXKXdEhKDKDw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ygxe</p><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UdIG3CvNYE4sT75YgUYong">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nrng</p><p>实战Java虚拟机.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/151o-bzu51xsRNQwfDH-v0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yxkn</p><p>实战JAVA虚拟机JVM故障诊断与性能优化.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LxC19YKuOhbTaTk3oRUVOg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cfrp</p><p>虚拟机系统与进程的通用平台.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1n1g5gbqHqbnVKeScHKDIvg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qjxg</p><p>自己动手写Java虚拟机（Java核心技术系列）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18tOPFGWfkHt8wHec6gHjuA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vdcw</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Apache Kafka实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1F2gu3LgHSz7-mCu1grPE0A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jjcw</p><p>kafka-高性能揭秘及优化.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1V-y3nnC2W43ICl4KtvUd0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rbey</p><p>Kafka并不难学！入门、进阶、商业实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SEWr4qFnK_Xo7TAWbrtBCw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tyyy</p><p>Kafka技术内幕-图文详解Kafka源码设计与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Ws1V7-zlfwlN412zLQuEtw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bbgr</p><p>Kafka技术内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SMnb-k18Oe0tGfrCo9OeHg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ftsy</p><p>Kafka权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1WzjA7J2eSK-1AyJNJYfPjQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：prjv</p><p>Kafka源码解析与实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jnaMi49J-2ssZ2VI-0IOjA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：eymk</p><p>深入理解Kafka核心设计与实践原理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sHmX9x4QrYEmo8CVDO05Og">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jubt</p><p>图文详解Kafka源码设计与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fs_pLDYhO-X3Gw0VGX__GA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhjd</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>Linux C编程一站式学习(最新版).pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nSM92Y0ACgKCnW5c_MBOQw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wchx</p><p>LinuxC函数库参考手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10g6n3vUw3WjWHCleKCeO3A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：edaw</p><p>LinuxShell脚本攻略（中文版带书签）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13Y1Ur18yR7WhLADdf0X2YQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bcnn</p><p>Linux宝典.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YtnnSKHEdHoDupKYHK694w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yvbj</p><p>Linux程序员指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10lItD3ThyEvIcys7viEMqA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mwxb</p><p>Linux初学者入门优秀教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1i6xgfH_rbCWVQpbn0T5wag">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jmpr</p><p>Linux防火墙（原书第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fo3ZVIPIDTx66H6AXIDSLQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tudk</p><p>Linux命令详解词典].施威铭研究室..pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1psZy9LInYtBYtRKwNVqo2A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kpqc</p><p>Linux内核IO性能优化及块BIO处理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NBSUxyHYkRD7gNrfcvuAKA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hphr</p><p>Linux内核设计与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sCG7F3X8pRuRrKf-rWL7bw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dyas</p><p>Linux企业运维实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RH87jSJ-bM8zR7GRUCuL5g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gffg</p><p>Linux系统常用命令快速入门.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oXW-YdsQS9FWX7FE_-ngrg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yxmn</p><p>Unix与Linux.Shell编程.PDF.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kV_srGnJaXKXbFsQnySR0w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yjfk</p><p>鸟哥的Linux私房菜-基础篇-第四版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fQOp0ay4V6BrXxOyg-L5CQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tnuy</p><p>鸟哥的Linux私房菜-基础篇第四版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MRfO9rnOs4I9PFmL0yYdpQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ptnk</p><p>鸟哥的Linux私房菜-基础学习篇%28第四版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1d_fU9jnwFOzWBM09zZzY1A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cgcm</p><p>鸟哥的Linux私房菜-基础学习篇（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BO2mAcbpmWeHpMwk8zJ_tQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jesv</p><p>鸟哥的Linux私房菜.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L2cDjyajadQLfnq8KEKvVg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：syue</p><p>鸟哥的LINUX私房菜_基础学习篇（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mFe83qmAJFxPpUitkHoHsw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vhdp</p><p>鸟哥的Linux私房菜：服务器架设篇（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1K4TM42FaxqvwI8Z40XronQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dvpc</p><p>鸟哥的Linux私房菜：服务器架设篇（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1gZqiZz4kXz0QLBlculqXZQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ghbv</p><p>鸟哥的Linux私房菜服务器架设篇（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lGXi89r_HYVKJmEaT4gn3Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nxjm</p><p>鸟哥私房菜（全）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1f5_hfVlNO1hksn_CO-cb4Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：byyb</p><p>循序渐进Linux第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ZK5-N-9aVPy9INC5XBDf1w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykch</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven权威指南_中文清晰.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bdYjpFbdTgO1jdirwXUaKw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vwqy</p><p>Maven权威指南中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jCxc7DsQYI9sM9jB99DZ-g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hrhe</p><p>Maven实战（完整带书签）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lfCCDoH1oMF950slGA5yNQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dncc</p><p>Maven应用实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1siK3mklE4FNgoN-DyA-sFQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cysv</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>50TipsandTricksforMongoDBDevelopers.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wDIEHzT8fyDQq_-nx-Vc_g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fcrm</p><p>MongoDBTheDefinitiveGuide.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SgRaWvocG9J24OFD4ctZiw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uruj</p><p>MongoDB大数据处理权威指南-第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1viqo7Xf5u1RY_RrZxgoxvw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xhdj</p><p>mongodb分片教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1XKCPsKYozxR2w1KUvGUdbA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bqsj</p><p>MongoDB权威指南第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1XFgtsaN2vh5XqhwNRpuH7Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bvkj</p><p>MongoDB实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1z81kDxzBUphuvmC-bOleZA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ggmy</p><p>MongoDB游记之轻松入门到进阶.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pcBGRm__NQ0bWb5dJ7v9-Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hrnr</p><p>MongoDB运维实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1er045VTi4TRIVueLv4fZFQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：quyw</p><p>ScalingMongoDB.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SsTNYOMU_WXrC8MVB2TKqg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：byxj</p><p>TheDefinitiveGuidetoMongoDB.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1uuCMIGBDkPXsHiqEh4g7Tg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fafw</p><p>大数据存储MongoDB实战指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1FCRYw9GGSrKFZwAaBCK7lg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qnrp</p><p>深入学习MongoDb.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19x0Yi3xyzohl6Akqr6YKUA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tkva</p><h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p>JavaEE框架技术SpringMVC+Spring+MyBatis.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1f_o0B3_zvlHVaOL2AXbAQA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kpvv</p><p>MyBatis.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19SxKgiAEyf6p3c8Nn9gFWw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ndvu</p><p>MyBatis3用户指南中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AE0PgRl_89WoIuOR2yeOog">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykkm</p><p>MyBatis3中文用户指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1j1TMakPzclyy4q6hJXoxNQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rwqq</p><p>MyBatis从入门到精通.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bgAr1YxXLUF--3gIzXvGGw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykne</p><p>MyBatis技术内幕.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/11Bb7EqCMrOZk9qdZeT9Yqg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rytk</p><p>Spring+MVC+MyBatis企业应用实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nFPpcI__63rusGRnaAPtIw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xxst</p><p>Spring+MyBatis企业应用实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fantirermH4IZ_Bg1q9R0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：arxs</p><p>深入浅出MyBatis技术原理与实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AR7-WWcbSlfBbMPvAVKH3w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jqaq</p><p>一本小小的MyBatis源码分析书.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-ci1QjI-Pgqr92J9sAWYcg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cejt</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL5.5从零开始学.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1P2rN3s0e3PC_U7WXXyozGg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xjvd</p><p>MySQL5权威指南中文版（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dm7uzjGkoQZuN6uwb20HnQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：edfs</p><p>MySQL从入门到精通.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kOo5TpfRepC2YkHkALX-AQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yvmx</p><p>MySQL高性能书籍_第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19kYPQ_Y-1QPWRPxtUrqVzA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xvkk</p><p>MySQL管理之道，性能调优，高可用与监控（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Q6ZeXnTTbsqZAk7hb1uxUQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kwpb</p><p>MySQL技术内幕.第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Edkesp8UWAvg3zsP7ASAVw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bajp</p><p>MySQL技术内幕：InnoDB存储引擎.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Bzxj4jlK9WbyC5FmlEHaAA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pvnp</p><p>MySQL技术内幕：InnoDB存储引擎（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19IgB4YxDaLWM4QyHPaPPhw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gtet</p><p>MySQL技术内幕：SQL编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12o1A5-9YWVXlZ_8y9mnnsA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tapk</p><p>MySQL开发者SQL权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16WtukI0dylCyRe4mx9XZ2Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nsvv</p><p>MySQL权威指南第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1uGow9RNUz5ZpzpOKcJHcqw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qndv</p><p>MySQL入门很简单.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Js1-s-YAPfTANBdEQVb7Tg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：huhm</p><p>MySQL入门很简单－学习笔记.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BXgczzido8DYWAw_5I0GUg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nwgq</p><p>MySQL数据库开发的三十六条规定-石展.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/183DOyuMxnPKTP9k_7mmpNQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gfxf</p><p>MySQL性能调优与架构设计–全册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Xy-7uSydvbty3O3V9FDdrQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aket</p><p>MySQL性能调优与架构设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1njPg4JsO0lRpzuHKR2CLlw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xjxv</p><p>Mysql性能优化教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LvCrKzNTHmjfK_nUMakXhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：etch</p><p>MySQL运维内参：MySQL、Galera、Inception核心原理与最佳实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KvaTodjLvF0Gn0eqt2DWoQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qtmy</p><p>MySQL最佳优化完美攻略.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ul9g5e44BABbScNeWM50wA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：chts</p><p>高可用MySQL_构建健壮的数据中心.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LTcu5PFGvqSK15wsa44gbQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：envf</p><p>高性能MySQL.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/101-v3r_-PHZtsXbJcDHAxA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dtwy</p><p>高性能MySQL（第二版）中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1b1Z0tgOxm1TWWIEyTt-TNw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：akcb</p><p>高性能MySQL（第三版）中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mzhuEvZ0n7Kwb6y4oqlUfg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gwns</p><p>高性能MySQL第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YuxX2mrJmRKKRqdD0SIU4A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hjps</p><p>深入浅出MySQL++数据库开发、优化与管理维护（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-691pY2chOJp8pk6cZ2uTg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wast</p><p>深入浅出MySQL.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1f2043vmGRx_dusNiANPNPw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rjhc</p><p>深入浅出MySQL数据库开发优化与管理维护.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PgWkcukmRUi1qXxD19381g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：absj</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><p>Netty5.0架构剖析和源码解读.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DwH83VFmXv7Dtl4CaNUMGw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dqwx</p><p>NettyinAction第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lehtQaEjHXGAJ19W8Wr7Ww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ecpc</p><p>Netty权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1se8QSu4Fuypt1aBDO_U0ig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rbvj</p><p>Netty实战（精髓）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12dcJfI17WxLBtk3lhuU5Gw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bwxe</p><p>Netty实战（异步图书）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TVs1rydRUcrru8N030L2qg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wasw</p><p>开源电子书：Netty4开发手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ft4211OqluHHlZazaqf0Dw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bpfw</p><p>开源电子书：Netty手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qe6Yjw71LpHmA0PAVIGXbg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mkpj</p><p>Netty 入门与实战：仿写微信 IM 即时通讯系统.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1h8E7ozV2kuGi1Eb-bsuVVw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uhct</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx高性能Web服务器详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1amY8cgIv7Zxci8YFupIxCg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bjwk</p><p>Nginx开发从入门到精通.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lfiRc9A6xfE5NiZu6bPTQA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fnja</p><p>精通Nginx第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HPKEC-RBXQ0jX01jn8Rh_g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bgxu</p><p>决战Nginx技术卷：高性能Web服务器部署与运维.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QvIYX-QesMmay96QfUlNCA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ccdy</p><p>开源电子书：Nginx开发手册文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yEHGKaIIWmU0-yHGEx2Vkg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：guaa</p><p>深入理解Nginx：模块开发与架构解析（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1A01qpz8rTz7Gt4C0SQS8Cw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：umpm</p><p>深入剖析Nginx.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12cb86rd92hMjsiean_Fzug">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：chpu</p><p>实战Nginx.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VPXRFg_9TyChY18lwDXnyA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dexy</p><p>实战Nginx：取代Apache的高性能Web服务器.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1IVpgtls7W8x5IC0PWJ26IQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tkej</p><p>学习NginxHTTPServer中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12oMND71vtg94ZCxOhk1vVg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yjhj</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Head_First_Python.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VFiGTiEH1UZ-O1Q7ESxWMQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bxjd</p><p>Intermediate_Python中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JKffHxAIWXf9AT8uzJhePA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pxhk</p><p>NumPy攻略-Python科学计算与数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12sy-W34olu2FxJhuF-QO7w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：urga</p><p>Python100经典练习题.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qEG1lr_-q4Sdjs0_GC_NRg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pvxx</p><p>Python3.5从零开始学.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fb_hFaz3j5DGN58IkrnS6w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fgdk</p><p>Python3程序开发指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NMNOw8CoRuYayX6pAlLAXg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xfgn</p><p>Python3高级教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QUanOjYMbvelhTJ0c-WfDg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：stdr</p><p>Python3萌新入门笔记及练习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Y1R7C1Vbe9MyqpEatCoSaw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tjrm</p><p>Python3网络爬虫数据采集.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DonjcwYxRwtK2-UlWK102g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qjej</p><p>PythonbyLiao.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lX2Ww1oH1rlNRsNiSUyRKA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tmkt</p><p>PythonCookbook（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tCuQxQkdz3TWI6By6o8lhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ypqq</p><p>PythonQtGUI快速编程PYQT编程指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qyY6q48Uaf5q18Hy-KlmJw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rptg</p><p>PythonWeb开发：测试驱动方法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OwkXe4OiEZqnGxPiTSb-ow">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vgjf</p><p>PythonWeb开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1WN4hg9V1Gb8678ni6ZHb8A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sqad</p><p>Python编程：从入门到实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1rxHSlRYDeRzER86Iat3bBg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qpew</p><p>Python编程初学者指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QigptG5G3bUT3LBR5bGh4w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gfba</p><p>Python编程导论第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DIW_V74AqzmbkSHqFM3VgA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rymv</p><p>Python编程快速上手-让繁琐工作自动化.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1cXMjJxqrgvE7mRfeo_YOqQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vfcg</p><p>Python编程入门经典.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bnwDSA2FtSOKU3OfSA4oHg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wvur</p><p>Python编程实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Mxu0wcIplfr50h3uaFgINQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sfbk</p><p>Python标准库.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14Sb6PDlIfE9Q6j-NwWpfSQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vyfw</p><p>Python参考手册（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YnYbkhEfeyrFqK0bOHkx-g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cfmd</p><p>Python程序员指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UgzN9KU0ohONquoSp0fUQw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：axgj</p><p>Python地理空间分析指南（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YgFdxCGCD88mDbv-N5UPsA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ibeq</p><p>Python高级编程（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qlPvBIfqav2NOaXdRGyQEQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fbpf</p><p>Python高级编程（清华）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-2WqO3Vr6KIGPhhJ3VuZxg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jtgk</p><p>Python高性能编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AfkFyRnsHeCcrdnzTBmDbw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nxee</p><p>Python核心编程第三版中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1npiohmcnxEfOBYDz8xgl7w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：djfv</p><p>Python核心编程中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Q__Bab9vh6rrQTNcXs89OA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：evtr</p><p>Python灰帽子-黑客与逆向工程师的Python编程之道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VauUNGVKpDVcjP0nwHXxWg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bhcc</p><p>Python机器学习基础教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1u7mQNMYqGHGa0z-JFpZzXw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fgvu</p><p>Python机器学习及实践－从零开始通往KAGGLE竞赛之路.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QL4Q-ZRSEN8Nw0FiGjQYNg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：apjt</p><p>Python机器学习预测分析核心算法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pl9gvj4Aa3UvUWH606gghA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：btgd</p><p>Python基础教程（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1P1CTx-pZVqmnjhgmabTtYA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dxtx</p><p>Python技术参考大全.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16AorSuzzprwITIH5pQnLDg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kryv</p><p>Python简明教程中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RWVAaXsTN8UZVT93qYGAow">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qqfd</p><p>Python金融大数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hPZGpgcJ4mrD-hPUHi6v-A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jkde</p><p>Python金融实战###.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xT6jWL6evmLno-DqxOwztQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tdtd</p><p>Python进阶.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MgdTNPvZmL4wCO30fD1PYA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rpge</p><p>Python开发技术详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1cBUeX7g9FO-YmQfm4tjqew">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fsen</p><p>Python开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xSoagU8uWVrd06PEV3M8cg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：akms</p><p>Python科学计算.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_QM1-pKyOX6igigD68dubA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cxnf</p><p>Python科学计算张若愚.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BKh190iPHJ6YuV8dF4u-SA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jqkk</p><p>Python快速入门.（英文版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iueknRUbscCwbuVJqnVAYQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hpmf</p><p>Python面向对象编程指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VDoUBcjeJE3E4PvpHTDnkQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mfqt</p><p>Python爬虫开发与项目实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19HvOnwlddYVTu1J_A3Ar_w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bppw</p><p>Python入门经典-图灵图书.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ADZTfo8d-BhWRVMTuc9vbg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gnys</p><p>Python入门经典_以解决计算问题为导向的Python编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AtmPablSgCYCEGlzVt0nsw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qwcc</p><p>Python实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zuj5_Pf6hlBWRDcttgs1Hw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dmkk</p><p>Python数据处理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oV8MkV9MeIEJd5vvKykSTQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nuyd</p><p>Python数据分析基础教程：NumPy学习指南（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1n_3DdmFSJIr2hvrQVdYR_g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rtfw</p><p>Python数据分析实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1etCRbwO9pnh92ZfDmk_Thw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fpl0</p><p>Python数据科学手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1y0YDhW1j2c-7y3JYa5XcRg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pdpm</p><p>Python数据可视化编程实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1t1M1cPbVc3Q4GY8KJzu3zQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wbbj</p><p>Python网络编程基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LiKopPZbm-cl3EZSsQNvaQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qxmc</p><p>Python网络数据采集.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_WYX4OuYfLZejHffPyxElw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：avqp</p><p>Python文本处理指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_2WB8aYQIsN_N_ejDHkqng">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xsbp</p><p>Python学习手册（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/112mWtJksF52XuuTbhAZDDg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bbkb</p><p>Python学习手册（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yf-Kx3QUi4FxRA4EeMSKgg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：newx</p><p>Python语言及其应用.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1M7vxF3rWfBkaEkMx1e1jfQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jper</p><p>Python语言入门.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Ag-d9IZhcJJlq0EtjCGbRA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fjvg</p><p>Python源码剖析-深度探索动态语言核心技术.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KOpCn8WpfD-u1TFDo2S1vQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hrdk</p><p>Selenium2自动化测试实战基于Python语言.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JHkKIFuYyOneIRIuZ5CWng">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sned</p><p>贝叶斯思维统计建模的PYTHON学习法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jgwOa7pAxWizS74wZgPsaA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ftvh</p><p>笨办法学Python（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1j3X9eHXyyiEx6Qt_5NG-hA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hrwu</p><p>编程小白的第一本Python入门书.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1779Scda492B6cV_JDtYVKQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gawm</p><p>编写高质量代码改善Python程序的91个建议.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RbeRjcOyoED4XssfehWCrQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fdqf</p><p>常用数据挖掘算法总结及Python实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17bCvudE58piFmzXuqPxyLQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：crhc</p><p>从Excel到Python数据分析进阶指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wGm22yDbNZb3-fMxg9U1xw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sjej</p><p>从Python开始学编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xbTixG5vp46jF978gzhjSA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jpcd</p><p>基于Python实现的微信好友数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lUNyfgLjJQ7a3wYTJohSUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qkxh</p><p>简明Python教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yAKe7FKdjykrPw1VCf0dyg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kjpe</p><p>精通Python爬虫框架Scrapy.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SsXFFATYsFuGpOIB4Wu0tA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：agdt</p><p>精通Python设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/15mPbGSDAge1rerPKlPNzOA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cstd</p><p>可爱的Python脚本语言入门精品文章.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Xa_FLvZY1HALR1DCQxgXkQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gcss</p><p>利用Python进行数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_UV9ksV1nB-74Y6jUPGgBw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nqcg</p><p>量化投资以Python为工具.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UY9A2psHqVvwBLFctFGhfQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hqng</p><p>流畅的Python.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tMriduk7AKgjhbso8PoYkA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xhra</p><p>深度学习入门：基于Python的理论与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wHkyJ49Jd0-tWN2HnyseAA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uptu</p><p>深入Python3中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Om4fYBrWWQRsdubmQZOnQg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fscr</p><p>数据结构与算法-Python语言描述.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_26rHItQjriX-uoAnfDDIw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：srqh</p><p>网络爬虫－Python和数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MbwZbJ4iCa3d--QGY_gvvg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yngd</p><p>用Python进行自然语言处理（中文翻译NLTK）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/15g8eTQEUTNC4XfGFAXlqSg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yunh</p><p>用Python写网络爬虫.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yTWnUNcViJoXTPH07sRjyQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nhas</p><p>征服Python语言基础与典型应用.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/11dPvt3a-TK_DZafOLWHXyw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tfpc</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>LearningRabbitMQ.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/11OLPEtgvamlehbM-kaJPCQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yjef</p><p>Manning.RabbitMQ.in.Depth.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/141oa5XeaJoYbImQ1J1AVpg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rmvx</p><p>RabbitMQinAction.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13Z-PX_oQvCrm8ZkfqZRFsA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kqnj</p><p>RabbitMQ安装与使用.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mCd1AXHWZ_SNoLe05y53dw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ryge</p><p>RabbitMQ实战+高效部署分布式消息队列.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AW-9Ld_h0oNBo8MBNWmlIA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tnvq</p><p>RabbitMQ实战指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16KUEfZ7E0LQ9EtWVZZoq1A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hvfa</p><p>RabbitMQ学习整理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dqd2kKDrRyF8BFfhIM3_3g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：quhr</p><p>RabbitMQ研究v1.1.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tZtvd8venJ-OH2dgpz3MyQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nvhh</p><p>RocketMQ实战与原理解析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YFSlSY9fssmzGNl4pAGTjA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uxhc</p><p>深入RabbitMQ.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1u1zZr6sYHgCk_ombXpwgVw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jwns</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis4.xCookbook中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xT5vxTrQ6GkplG7oC_njig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wyje</p><p>Redis开发手册文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HrA_VRs6-eTS1eV1a3QX7Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qehg</p><p>Redis开发运维实践指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LV8ltQSf9eZIxITQUftoDQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：txvx</p><p>Redis开发运维指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1y5toFOh6L78MBmm8NgsoGg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kegb</p><p>Redis命令参考.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QE2WAnsasYtoVLzDcyvd5w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：haps</p><p>redis命令参考手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VZOS8sNEt1VrdhGJWUsH6Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pxpf</p><p>Redis入门手册（中文）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TLR49uLo-QKh6rkDmK2UIw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fnmw</p><p>Redis入门指南+第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13ouDpjbckPseqR9unl8Qlg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xwrx</p><p>Redis入门指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KHQ1IRHFwM7QR7MQVDLIQQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：setg</p><p>Redis入门指南第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VaYgcB11STHoRbY0v5Cbjw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wyry</p><p>Redis设计与实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1x485r6hUdA6ReGS_Qs-8ug">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tgja</p><p>Redis设计与实现（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iBfqH71XF21v7UC8hp4gVA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qvhp</p><p>Redis深度历险：核心原理和应用实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dv-L9npNpGst2NB9QnF-9w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vmjs</p><p>Redis实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TC2fhntA5c3-AGQeLxWN8Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bayn</p><p>Redis实战JosiahL.Carlson.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JU2GEnIx4Z3dY_GjmpZ_ig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dcea</p><p>Redis实战手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fJklWMC9wxvbS4WJSYLAfw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sdkm</p><p>Redis小白入门指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LQG-Tens7eeKk2gTGlacQg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dqmt</p><p>Redis学习笔记.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NkE18t6odi2HXv9Oo52LOg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhbc</p><p>左手MongoDB，右手Redis.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mqaPNHWzR2mAQOR9MtQYYA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：usvk</p><h2 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h2><p>Scala伴生对象.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AjvtMiN_yNmkjHBWwIz1wA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rtbr</p><p>Scala编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/15pq_oc-8ekzfPFfri415hQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：swak</p><p>Scala编程实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pyEdgq_T0VBoguk4zSIDHw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wudx</p><p>Scala编程思想-原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1niHLNXLzzskDEGNprsZSyg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gqbb</p><p>Scala并发编程程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mj_9nxhpaUr9i3Do8WhyNg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cgpa</p><p>Scala程序设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hAYn_whVc1uJ2wyk3qdlzA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kmwv</p><p>Scala基础语法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RDSS-Eo0SPgW_uyfKwBCCg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wqet</p><p>Scala集合.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AER6yVefvsjBdx0qfX4Afg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gyyf</p><p>Scala学习手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1XePbusG3vktRYwoQyM6eqQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bhdt</p><p>Scala语言规范.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eE7s7mSKmEbyE0UEhEKTtQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhwu</p><p>快学Scala.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MubjIXRpV00O4iuk8BHN2w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kfdv</p><h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p>ApacheSolrEssentials.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Yf5ACO-f2CwWllCB90Va6Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ngks</p><p>ApacheSolr参考指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PveHHBLEa0UxlUM38_h9ng">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qvtx</p><p>cookbooksolr4.x.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1G0AKrEIwS9sPhnXgSmF-1w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ucyq</p><p>Java搜索服务Solr操作指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SHLK-B5km75SvV8Vlhv9XA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：frjr</p><p>Solr+In+Action.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1n2Ru2eEVAJhep6s9UfHFog">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yhpj</p><p>SolrJ教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AF7OMIaxKH24WBSn0Sz0MA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ttnn</p><p>Solr的应用教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1i6P1YWKu2P1hdOKxhWiV4Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ydqr</p><p>Solr权威指南上卷.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ZLt1IPqpib1shVCwXH_wuA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pdeh</p><p>Solr权威指南下卷.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1M5IyLBOevsCppdmcKiPr0A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bqbv</p><p>Solr实战中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xAOp9m5nTedRTWQoWN0CBQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fqbm</p><p>搜索引擎核心技术与实现（基于Lucene和Solr）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14dPfzeUfz_VOiGIAyUsAWw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mevj</p><p>用Solr构建垂直搜索引擎.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fztu32bV-8gzlLA63YOtDg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：utgg</p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>LearningSpark.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1a3pZe9TldXUHp_Cc0e_hMA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bpbb</p><p>SparkContext.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BmslNv9yFOOHAm1v0zNU9g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ahwk</p><p>SparkCookbook.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SbU88xeawgY43To6x0lqIg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bjnw</p><p>spark编程指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oBgXPSls4C2teTD4l1KljA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kryq</p><p>Spark初识.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PSgvOmfNshU_MLtyI09WVQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ecua</p><p>Spark大数据处理：技术应用与性能优化（全）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1rX0IMFa9mGOhkalQ3DBGAQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ffyf</p><p>Spark大数据分析实战（大数据技术丛书）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NgQ9bG27C0Y10HPe_s5pxw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sccm</p><p>Spark高级数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GrcXrbyKGFdXJaK3EPY3KQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mntr</p><p>Spark机器学习-NickPentreath.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dnYnxh0Wpej4O78lZmBFdA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uubr</p><p>Spark机器学习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1f1cgmkbyfAmXnQzp3RfXXA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xkwp</p><p>Spark快速大数据分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18rEWffYn03R9MMPXZyXt4g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rqdp</p><p>Spark快速数据处理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/125J1v1mT5sjpho1RALszGg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xhvq</p><p>Spark内核.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GrAjbQwrIZoGeqiuWZgXWw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ftvj</p><p>Spark之SQL.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UmzDoY2i4Rv6RP_x2a5Dyg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yamy</p><p>Spark总结.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oS-ORk8JmuyD2Rvhlswngw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：htvg</p><p>大数据Spark企业级实战版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1E5t7vvCg-lL4pcHPBuQvOw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vsye</p><p>深入理解Spark：核心思想与源码分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Ui-OYpKb0PrZfKS-SR5cUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wvbc</p><p>数据算法：Hadoop、Spark大数据处理技巧.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QjxarlwM3jR53fBd8h3vJw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：scym</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>JavaEE框架技术SpringMVC+Spring+MyBatis.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13t5wcfnzzSI8MaSoDs-f6A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cuqh</p><p>JavaEE设计模式：Spring企业级开发最佳实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nwMCWnj6AbBVTjzv27Spsg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rber</p><p>Spring+MVC+MyBatis企业应用实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mA9IBQAXMFHSuxMYb0dwOA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tuau</p><p>Spring+MyBatis企业应用实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10cNgpDROfBl8Y9YaiYOKXQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uugy</p><p>Spring+Security3.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bSbTHCM5sdyK4vzcmsRxsw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cecb</p><p>Spring.in.Action_4th.Edition-Spring实战（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JeGK6-fJM5JA2ob0LGEp5w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mbna</p><p>Spring3.0就这么简单.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vcGkxbdbPeJr8ZFpbasiUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kgfh</p><p>SpringBatch批处理框架.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14J6GWb8yloJobdjTn6Yo8A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhaq</p><p>SpringDataJPA从入门到精通.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mb60lfExZerVL74IMMcB-A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rhfd</p><p>SpringData实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YFgOkiOdgpI-YxS2snxDVw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ymgf</p><p>Springframeworkreference.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jeZ1XWcSTTLqKovtq07BLA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gghe</p><p>Springinaction中文版（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19hVshSMI9dKPbxj8mgufSg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nvpv</p><p>SpringMvc教学.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yBGQhQrMuDD2yW2Yo1Kurg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bxym</p><p>Spring技术内幕：深入解析Spring架构与设计原理-第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14O9Be78yllAL42XgwyD6Xw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fvwg</p><p>Spring揭秘.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12lJjIJQBpUFJEe6SHReEFA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bmtb</p><p>Spring揭秘（完整）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1y3ra1sLoZgRMLw5NwPnkfQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mqqa</p><p>Spring实战（第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ym5f1CjAaYTp2UC7q6PSLw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dtsa</p><p>Spring实战（第三版）.（Spring.in.Action.3rd.Edition）.Craig.Walls.文字版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JWMfgnsNN3CiN4kKnhAedQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xuaq</p><p>Spring实战（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AxldKhH5nE457d_z7xQ0fw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uwey</p><p>Spring微服务.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CNk_cfmr2NkT_wLdGB_I9g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dycv</p><p>Spring微服务实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MfsYnFhcS8prjR0MgidsFA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wtqy</p><p>Spring源码深度解析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yUdNGv7JwkimJ-D8ELk4_Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dnam</p><p>Spring源码深度解析[郝佳编著]sample.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1N55_R0jemO6OYrKDeTMtvQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：caha</p><p>Spring中文开发手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1trSR0TnHIwXlwxhHaT1BOg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：utnd</p><p>精通Spring+4.x++企业应用开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sboKbsdGcoJ_9C-ghJ-EzA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uyhq</p><p>精通Spring4.X企业应用开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oGAa4XQHyqZwn5fEmDLyLA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qjms</p><p>精通SpringMVC4.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UPTbM8hzQXmuzHRzYnvavA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：svmc</p><p>精通Spring（清晰书签版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TjoTtbfCUpY9vjkEXfj3-g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gmdb</p><p>开源电子书：SpringMVC开发手册文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nvqA3ZUsmt4nHlNo6KtFnQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jbwt</p><p>看透SpringMVC源代码分析与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Axx-brgEQPAyceeduOC4EA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qgbs</p><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>JavaEE开发的颠覆者SpringBoot实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18_ChlhYC5WPR0z2em0XEJA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：skhv</p><p>SpringBoot2参考手册中文文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L9ybprmzbVKVO7dM9N_dZA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wcqd</p><p>SpringBoot2精髓.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17z6b52RndqkYMy3XogSd8w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nmyr</p><p>SpringBootCookbook.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1r4_0rJJoAcOS8BHLlMsmvw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bnjq</p><p>SpringBootreference-guide-zh.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ueA9qfWcEgmIo-KFuY4WYQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xvck</p><p>SpringBoot揭秘：快速构建微服务体系.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1I3kIasza2KLVGalih1jueA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wp25</p><p>SpringBoot揭秘快速构建微服务体系.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YYCf7Nt4fIWshEDqOOHCxw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yjfp</p><p>SpringBoot企业级应用开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10oNwJpuoxIIeLJo_1L--WQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ytyn</p><p>SpringBoot实战,丁雪丰（译者）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kH2XcrxHu9blC-VpWIOT6g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：erre</p><p>SpringBoot实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yLfvcBg6kialAeCK8UtA3Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mcxf</p><p>SpringBoot实战（第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bJXfMZbKc7BRW4Os_e0ZQw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：iqh5</p><p>从零开始学SpringBoot.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wvveBEUlFd39oIE13CeMjg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nffk</p><p>开源电子书：SpringBoot开发手册文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zK-xruUmxZcMl_PBu537eg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tnca</p><p>深入浅出SpringBoot2.x.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1a0KXvVa0DxgijdD2iFi3nA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cvrv</p><p>深入实践SpringBoot.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1o28NYp6qS0GwErBZkQQEHw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fhce</p><p>微服务架构基础SpringBoot+SpringCloud+Docker.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DKC_sCenraRpiSrWUiTrXw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xrac</p><p>微服务架构实战基于SpringBootSpringCloudDocker.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qSMW_4LOLB5u3wggmpNgSQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kkws</p><p>一步一步学SpringBoot2微服务项目实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1m0hb9sIdkp3L_uvQEVof4w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：etuc</p><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloudDalston中文文档+参考手册+中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17OOwAEwU9m1xH9peLYwNuw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gepu</p><p>SpringCloudFinchley.RELEASE参考手册中文文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UYPHxpKS4ApQ5HPIjDg14A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vbcb</p><p>SpringCloud_Data_Flow.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zg2AZwiLBCsUkBHEpv-_zQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gqsb</p><p>SpringCloud微服务架构进阶.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CvIBWtGQkM30gb6vIuB_TA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hrpg</p><p>SpringCloud微服务架构开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hb5Ha9Df7DGhgysizIKG1A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gaje</p><p>SpringCloud微服务实战-翟永超-.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jzzH6aZMuplJn2f55dIreg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：svry</p><p>SpringCloud微服务实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17fBvrg0dS3jShZCtVextKg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：apkf</p><p>SpringCloud与Docker高并发微服务架构设计实施.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RZNBY5GtJEUWnSvUNOfl2Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ytxu</p><p>SpringCloud与Docker微服务架构实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tVqVWKNM2aAxM-CfDqL6bw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：eygt</p><p>SpringCloud中文文档.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AsaM1V-xAWB1N1HE0ygf1Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xjde</p><p>疯狂SpringCloud微服务架构实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17m-C1i1m4UZQ1fBU_7AKjQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：m75a</p><p>深入理解SpringCloud与微服务构建-第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UvDP10G8oFquvLkkou9vKQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bpaf</p><p>深入理解SpringCloud与微服务构建.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dvcYUenti_PGA3IFDjDPog">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gpvu</p><p>微服务架构实战基于SpringBootSpringCloudDocker.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SJH1l-B_NS0SvrSn9MvCcQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pyde</p><p>重新定义SpringCloud实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1toi6LIOPhm7uIcBshhBtJA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gcvr</p><h2 id="TCPIP"><a href="#TCPIP" class="headerlink" title="TCPIP"></a>TCPIP</h2><p>HTTP权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1V-E7qA1chayHptjMqWD4jw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qfxn</p><p>TCPIP网络编程技术基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1A0tNLreWUnfnC0OZNRzYzA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：egcj</p><p>TCPIP详解卷1.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18-1DGhzaiIGFCqnrDwuRcw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhqk</p><p>TCPIP详解卷2.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TxZ6eXOKXMLtuwUQ11b-ZQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hckb</p><p>TCPIP详解卷3.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1U-Bu8UCYxbo82T9WPIkILQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qbbs</p><p>图解HTTP.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iBy_vgZybISzYQ-pcHGXlQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uybd</p><p>图解TCPIP（第五版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1c4WusvoRv5JUT5N136KbPw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：eaeg</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>HowTomcatWorks中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bUzW18tucUfnpZplko1QuA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nqpn</p><p>Java+Web开发与实战–Eclipse+Tomcat+Servlet+JSP整合应用.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kIkW5Dy4MG19TST7MWsBlA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bnje</p><p>Tomcat架构解析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1e_gKL2PnAratdONt3ktbvQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dtph</p><p>Tomcat内核设计剖析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1R1zlCwMWNOeuNHTmvbw00g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aycy</p><p>Tomcat权威指南（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QvlZIh42lE9jt2oZdYntDw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bcpx</p><p>Tomcat源码研究.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PR52YaEr_IISdx0VAXVoTg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：teru</p><p>基于Tomcat5.0和_Axis2开发Web_Service应用实例.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zFz490uTpZ5XfpVV9m3UVw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bhkw</p><p>深入剖析Tomcat.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bIQQtU5IDwgqMufy6qRtRA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wkmw</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Netty_Redis_Zookeeper高并发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HglGmsYXMxLn5vme3-qtdQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sfje</p><p>Zookeeper_3.3.5源码分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xIWKqaK8QQSjRd0qzMqwVg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xdjy</p><p>ZooKeeper分布式过程协同技术详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1V0yMLS7N_zl5FBgOLRq67w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wwqs</p><p>ZooKeeper原理与实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1T1I8mrhHn16-4MZGi_e8LA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nxdv</p><p>从Paxos到Zookeeper分布式一致性原理与实践（书签版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hIQ0y498zyjOPsK09-8wEw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xamx</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>Java并发编程的艺术.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12noqXaPB5jQqf-dZq_mVRg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vvqk</p><p>Java并发编程核心方法与框架,高洪岩著.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AbDG2WWDfEZDNPsmmc3cpA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：krkx</p><p>Java并发编程实践（中文）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Fp2XewwqOPQ4DDS0CP26Jg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：udhx</p><p>Java并发编程实战手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Z31bV_2pKLb8QYGeqIaYTw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pygh</p><p>Java并发编程学习笔记.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DiWDJysVBMcC3BU2-77E2Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vmat</p><p>Java程序性能优化让你的Java程序更快、更稳定.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Zu7PDffnvK-jQJ-2pTS_xg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dysx</p><p>Java多线程编程核心技术-迷你书.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/194HtZ2V0Fo2qPjNKmCo3ww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cwnt</p><p>Java多线程编程核心技术_.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1IWYc0eB7T6cB1IMbW4bb9A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gxqn</p><p>Java多线程编程深入详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jiOK9QuIwkLkR53Qu8SEbQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qsrq</p><p>Java线程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BhqzszXZMCvxPNyUO0l6OQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：grjv</p><p>Java性能优化权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YsLDmlDmpf2D1ID1K0uCRA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nrcr</p><p>UNIX网络编程卷1(第3版_英文版).pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_tLFKEMmZeCbHEttWn-9hQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fyhq</p><p>UNIX网络编程卷1(第3版_中文版).pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1cNyPJY6Pgf1erI5tPqwGkA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kjph</p><p>UNIX网络编程卷2(第2版_英文版).pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16iP-wOr-97AAnmhkfTN8_A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wujv</p><p>UNIX网络编程卷2(第2版_中文版).pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12TQGM2WSWTCO6_YmuEhj-A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bvme</p><p>高并发环境下的数据产品架构设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14P_iYOF9iTNv4swqv9H3tA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ngnp</p><p>七周七并发模型.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NQlbnSS9aL5cjpVWhqzFAA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hhvn</p><p>深入浅出 Java 多线程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wLJPyMZK01aQQj4xE6VsBw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gvec</p><p>实战Java高并发程序设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1O9ITt7hdt5i1sDSLIeTFUg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ajhj</p><p>搜索引擎优化魔法书+SEO+Magic+Book.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Ulpf4W7o-MM7kLSk_3jopg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dejw</p><h2 id="大数据类"><a href="#大数据类" class="headerlink" title="大数据类"></a>大数据类</h2><p>Druid实时大数据分析原理与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/143Fl3BExT295-apzDYERmQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bvwt</p><p>白话大数据与机器学习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1H3UPxGOLyboxe-WT8rRxiA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jfsk</p><p>百度2015大数据云计算研发笔试卷.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ANm9rUkfPaLE2v30cWfdXA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jjan</p><p>大话数据结构.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ExZMQaZVhcwgbGOcjgD9kA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：udnq</p><p>大数据：互联网大规模数据挖掘与分布式处理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UdsXXk-o1Ay1w1HM46l5Uw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ytah</p><p>大数据处理hive深入详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/14ohVpdzzq-kybnX_AQAKqw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cchf</p><p>大数据时代：生活、工作与思维的大变革》.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qheslcB63Wl1RgyroXXU-g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fmhd</p><p>大数据之路：阿里巴巴大数据实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yB0FYU0selFFaW9hHqUBeA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：utjg</p><p>分布式文件系统HDFS，大数据存储实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1V_e-unVW9enh39FX8F60kQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gvvf</p><p>傅强-当当在大数据挖掘分析与管理—个性化精准营销方面的探索.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mZP6vdBzErKVVmIY6VFz4w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bgac</p><p>用户网络行为画像大数据中的用户网络行为画像分析与内容推荐应用.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NomTFjPQGsBqubmmNqWhIA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hdsy</p><p>云计算大数据10.9日课腾讯邮箱垃圾邮箱解密-机器学习之贝叶斯分类.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1EEdMdCYi6f-pdz_w57IaWw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cadp</p><p>云计算和大数据时代网络技术揭秘.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1q9iVEL2eHolQPrGbq2yYjw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wfeu</p><p>自己动手做大数据系统.张魁（带书签文字版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oef-psBj1qyYh3A7b5Y2lQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xugy</p><h2 id="计算机类"><a href="#计算机类" class="headerlink" title="计算机类"></a>计算机类</h2><p>编码：隐匿在计算机软硬件背后的语言.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ub9V4Kyo-Uqk8_nGJlFXhQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wxsc</p><p>程序是怎样跑起来的.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1FvoZx3Izkc8-4PrlS1qrAQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qtdf</p><p>程序员的数学3+线性代数.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OTxVO8d_xx08Fy86s6IZmg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ynfv</p><p>计算机操作系统.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AHemuAa0ylbcaOrAqXNkdQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uudw</p><p>计算机操作系统（第3版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1i3aCX4UPEWRmbaPN1j_cpQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cdpc</p><p>计算机系统要素：从零开始构建现代计算机.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-rZX-unw9HhH7Z-vqosJJg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vary</p><p>计算机组成：结构化方法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YT8u3GT5jdmpWSMc3tSAoA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：avgg</p><p>计算机组成及汇编语言原理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Me5ih2DjRku7m_32bbvvUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jkme</p><p>计算机组成与嵌入式系统原书第六版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sGkzfLXCIfZHoAatt4dApA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aknv</p><p>计算机组成与设计硬件软件接口原书第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yVvP4VmAKcVUgxjOwEjy-g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hyxu</p><p>计算机组成与体系结构.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12wuTAlW0Wx0eZ-FGHvje5w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qcvk</p><p>计算机组成与体系结构：性能设计第八版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19MY0qTxeJTTlu2cD7TtOTw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mjqd</p><p>计算机组成原书第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qKi0pi85y4DhJ3tiG4I3HA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kkdx</p><p>计算理论导引原书第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bUKiyTvLBwn2-UuZJ0-FcA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wpqp</p><p>深入理解计算机系统（原书第三版3）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16hvccmhx4k6IMGcE89_1KA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xyyu</p><p>实时系统与编程语言.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oqAaL8_vHDgOychXpKXdPA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sbuy</p><p>网络科学原理与应用.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Ywhevg1Yryj9jWI8kGOnKA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hnty</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><p>Microsoft.NET.框架程序设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kQrL65G9MvFJHVWTYCIF4g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bgtb</p><p>阿里双11系统管控调度架构与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SPIZK_zzFobxhHmTSBDTGg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：acmb</p><p>程序员必读之软件架构.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1WSIqyXJ9hxZTrucSXbzn7A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ysdp</p><p>大规模分布式存储系统：原理解析与架构实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lSqIq8U6gyFDP0uVpqbLTQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dckf</p><p>大规模分布式系统架构与设计实战..pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VzZ7rPaTYt6CXCirDrdJ3Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：embe</p><p>大数据架构师指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1m_fOWgcxs1KB0g6ZSQkcrw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vqgx</p><p>大数据架构详解：从数据获取到深度学习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BOxy1UYgpQnwZQOjsHaUhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cdtk</p><p>大型电商分布式系统实践 - 第三课.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1c_DDSlFcVvCGVcRhTkDL3Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gafm</p><p>大型分布式网站架构设计与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1H2d-yqMcNoK1nss04B8auA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nbuw</p><p>大型分布式网站架构设计与实践.带目录书签..pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/167Glqiy01WM5O6dlzwhk4w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hdtt</p><p>大型网站服务器容量规划（异步图书）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PcYP-GWVaNo0w4scEzdAhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ejjn</p><p>大型网站技术架构：核心原理与案例分析+李智慧.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OVmhvHeEPzgwPEbPplcgGg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tmem</p><p>大型网站技术架构：核心原理与案例分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1R8ItDeKjXdZChQmYjNDTdw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mmxj</p><p>分布式系统原理 介绍.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1O_EMeQ8ZnhUpQurCME8dJQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：trrb</p><p>计算机程序设计艺术（第二卷）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fbtY-Zd6qylgpnWJ1EnsgQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhbb</p><p>计算机程序设计艺术（第三卷）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1aASj5P2lPohVGBb0HRif3w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yhnd</p><p>计算机程序设计艺术（第一卷）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KiP1N-KmCWkFptqVQC5Qfg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pfrk</p><p>计算机网络与因特网原书第五版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1IcaX8b29y_qULbcUKSR6dg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rdfh</p><p>计算机系统概论（原书第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/15dGDm5XHjSL_qjmWmsyFpQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dgpe</p><p>计算机系统结构原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16__4vm_xk9QV4Jt35klVZg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wfca</p><p>架构即未来现代企业可扩展的Web架构流程和组织原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1uErhVIjSuczf1jm6YxZs1Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gwuy</p><p>架构探险：从零开始写分布式服务框架.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pmU3H0sEYfolwuy02P3yew">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：arfq</p><p>架构探险从零开始写Javaweb框架.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VO93QIrOWu800GzwVKIhTQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wwws</p><p>架构演进：滴滴打车架构演变及应用实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PCW2Y8psLPI-Hb3pXaelfg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vgyn</p><p>架构演进：豆瓣架构演进.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1gG8fgFQoPGypigCzgtoZrg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tuhm</p><p>架构演进：京东服务框架实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17Zw3MG4k6K5G5Ao4PXU3wg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：psqv</p><p>架构演进：京东应用架构设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/16ZUuKJgy6NaPpP-kMG1yzw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vbmq</p><p>架构演进：汽车之家架构分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wHHeiii23aui5-g6yBluZw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wber</p><p>架构演进：人寿系统架构演变.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OA56l9dM8ho7qA7D28jOUA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rmms</p><p>架构演进：网易开源.pptx.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AGn0Og5v3QyTrwwmMAI8Ig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykgy</p><p>架构演进：微信之道－至简.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qRy8pJly-tN3JMUg4cpspA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yapu</p><p>架构演进：小米的经验分享.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1d_zYN8SExBJZz5ezXX2BKA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pmqn</p><p>架构演进：一亿用户增长背后的架构秘密（全文PPT）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eGKa-TAw8rRDK7vrM20oIg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：augf</p><p>架构演进：知乎架构变迁史.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CZr31zOQfdWXDSg6dEN4nw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：eknk</p><p>面向对象程序设计图形应用实例.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1h0C6BVqLeJWC7t1F6dGshQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dxnq</p><p>面向对象软件工程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_SeVnUc1Hu413KhzDcAFgQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qkhm</p><p>面向对象与传统软件工程统一过程的理论与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tkej8trl4c36HwnzgcioaQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hxxd</p><p>敏捷软件开发：原则、模式与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HujV9N_tIm2Ue-M_F_9eNw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rspa</p><p>轻量级微服务架构（上册）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18qfvhPp649heoFmXktvFOg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xftj</p><p>轻量级微服务架构（下册）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zoX-AJLBxN5yUa5VYTgBoQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jcmb</p><p>人人都是架构师+分布式系统架构落地与瓶颈突破.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1c4sMiCOdT06pxd-e4-dbcA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dirl</p><p>软件安全从源头开始.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KFw4y1VXHsOmqwOfb8oVew">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pdsr</p><p>软件工程架构驱动的软件开发.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mntiX1Sznsl8yqS98zSHxw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wjtd</p><p>软件工程面向对象和传统的方法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fG3_AqJu-tLX2QHUOw-Q7A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ews3</p><p>软件工程原书第9版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1o8Ymui9KxyEdLy3A8E-mXA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vdgn</p><p>软件构架实践_第二版_林_巴斯等著.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fzHMMsD2wK7b4Xp-CugCeQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xhfx</p><p>软件架构师的12项修炼.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QLZMF249JTHhcY6bDENNWg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xxyr</p><p>软件可靠性方法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1IPzTU6DIrv31Gi1ZCMHdOA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ahss</p><p>深入理解Nginx模块开发与架构解析第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ldqoJcfcSIeBSWByqPBOVg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sknj</p><p>数据密集型应用系统设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vo1nEA1gj-1NF_t5lVh-KA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cgkx</p><p>数据通信、计算机网络与开放系统（原书第四版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13Fv9GeGueBOHOxcnH5o53Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fjst</p><p>数据通信基础设施、联网和安全原书第七版T.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nWlpGl3m87mzVw5e-lNS4w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：njdc</p><p>数据通信与网络-原书第四版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zgd8JZF8OXG8f3O76ob0JA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xjkb</p><p>数字设计和计算机体系结构原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mokVM4hllmfU1_dSR0Q3RQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xdxx</p><p>数字图像处理疑难解析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/154jpOVPO8CNRtgg8s2UtgA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：spdu</p><p>推荐系统整体架构和mycat.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CuZ8VUbbJMlqZ3iNHyvPng">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jfrm</p><p>微服设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eXxSXr_At-Dm_fk_jQCOBQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：atfj</p><p>微服务分布式构架开发实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QUMfzz7sEnA6dvaTWhsJfA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：abgn</p><p>微服务架构与实践（王磊著）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1LFeA-0pDUbDjxqpJ8KB3xg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ntaw</p><p>系统分析与设计导论.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L_9aH3VmLpi8slWRGI8dZQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pncy</p><p>系统分析与设计教程原书第七版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/11D62FySweDeHetxiSgaBhQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wnuk</p><p>系统分析与设计敏捷迭代方法原书第六版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1slWRoJVVfHzOOYRsM2y8iw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ycyd</p><p>系统分析与设计原书第七版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1AWfWNGlOUQ1MwMXuUkOfvg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bgsr</p><p>系统架构：复杂系统的产品设计与开发.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L5aTNNiasKgr5zEKG2kXNw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xstp</p><p>现代操作系统第三版英文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1cqO-1t5ktFyaLGoSFYrFmA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rebf</p><p>阎宏-Java与模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mZ3euwfuuZYZz0dWD2ETeg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nxdn</p><p>一线架构师实践指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1f_6dngfklUJLM7hOhD83lQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ktet</p><p>亿级流量网站架构核心技术+跟开涛学搭建高可用高并发系统.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MoSsDMzUzGc513NCrGZqzg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rgww</p><p>亿级流量网站架构核心技术-跟开涛学搭建高可用高并发系统.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1hLOp66q0bIlJ3XRTFNZTgg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：upfs</p><p>云计算架构技术与实践+第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Pi4i2YntSaPYdoSHvsonVg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：newj</p><p>重构-改善既有代码的设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17TwdU1c0BZAbGAOD-PAQ7Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fceb</p><p>自动机理论、语言和计算导论.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zlg_0XChqqcCO5oQAqNQ8g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hsyr</p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>白话深度学习与TensorFlow.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ZLw__yjBUaZlWksJp7v7FA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ddjm</p><p>机器学习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1D5Ev9mTVN7js9OhjpKH2yA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：t44o</p><p>机器学习numpy和pandas基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kk9_TAsA_R6Yb_VJKx2duw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yhys</p><p>机器学习实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pTrPGVbmLQMrIcSwMCSbLw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ecgp</p><p>人工智能复杂问题求解的结构和策略原书第六版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SDsUMKH04iyaCT9NMlapbg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ermp</p><p>人工智能智能系统指南（原书第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Wvu4z-_LSzofglfox1e4ig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dnxh</p><p>深度学习-无水印-中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1FY_754yfqikeY5qc1rKEmw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rfnn</p><p>神经网络和深度学习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1CJbzqyobhwqchZksZN7yCg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qfax</p><p>神经网络与机器学习.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L3IqJJXj8IEw5DYhu17YWw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mgtu</p><p>神经网络原理.原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Btx6EMx-zgP1wFT1_nKrZQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yhc5</p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>软件测试基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10s7yvEvwMy1caKWAwcFUPw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qdbt</p><p>软件测试基础教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oRJNseVIFgDs6SLBL3XFZA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qaav</p><p>软件测试原理与实践.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1aTkoMSzGdkAa1wXxmOLMbw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：krgp</p><p>软件测试原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10vW1n9E_7_O4bwdlOMX0EA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dcwd</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>23种Java设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eh5oqb8vbdq5RAlSL79D8Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yfja</p><p>23种设计模式知识要点.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QAL-yAVeqjRcwfsD2JGcvg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pynv</p><p>24个Java代码（Java经典模式设计）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OoosrBfBWK9QAK0TQIE4ew">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tdkn</p><p>HeadFirst设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1a9C2j3RckNZZwCWOzZagzQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jnws</p><p>JavaHeadFirst设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xSFgFkhK6lOlIGog2r8teA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sfhj</p><p>JavaWeb模式设计之道（jb51.net）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ViNmcCBVrjbhzC4YlGtVOw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：egag</p><p>Java并发编程：设计原则与模式（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MLgSHc7_gYUF2p3IP6vjUQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cxvt</p><p>Java多线程编程实战指南设计模式篇.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OakxWURtDF1MhnB5ChmvSw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：awws</p><p>Java设计模式（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1IktvcAQWoBjbOVq_LXe7Ww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dasf</p><p>大话设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1b1nQRPcA5hNyxqQas2SWEg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：afcx</p><p>设计模式-可复用面向对象软件的基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1odKYhYMr4oHMhKtkQHXmog">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ewss</p><p>设计模式之禅.秦小波.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1WWXQJ_kXE7bFNL6YGg2Uww">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rsun</p><p>设计模式之禅（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KWoz-LdblGericVV-ydvqg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ehkb</p><p>图解Java多线程设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GZsmyslADdDiG9ubWqQ1RQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dsvh</p><p>图解设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1teydg8GdbD2e-dmiNbJ1NQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wubt</p><p>研磨设计模式-.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_Eh7vreNW5U69pSVz9UZgQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pvud</p><p>研磨设计模式.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Hdjlf0Go3N6vzQIBqGfqvg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bhpx</p><h2 id="数据库类"><a href="#数据库类" class="headerlink" title="数据库类"></a>数据库类</h2><p>Java网站数据库设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_J34VM8FGV5GvIpcnmNEMA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yrmj</p><p>PostgreSQL从入门到精通.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kMwCMbF-HPnwHN3Eub5dhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fjar</p><p>PostgreSQL详解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Zlr13EcrCVviOqi5uMZy2A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rpbb</p><p>PowerDesigner16系统分析与建模实战.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19uRhLZ-y-wSeJLwtDHg1LA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：frpc</p><p>PowerDesigner_15.1教程（完整）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eOffPVGYRVnuUxKZFz0C5A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bvag</p><p>PowerDesigner教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1oPirlfDkZ8KPbBZ05cJdQg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jjau</p><p>SQLCookbook中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1BNG6VD7RGH5gIRX63xcwtA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gbgc</p><p>SQLite权威指南.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1b4ou4nLGMtDOzuW0UwmTIQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mbpu</p><p>SQL查询的艺术.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1EvRbBfMRjBeKhSrCe36DHg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yxxm</p><p>SQL经典实例.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/192IgNkJiN_jCWn4uM5Yr0w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vrmj</p><p>SQL语句大全大全.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xT7Pp57YlCrBk41z_eIyUQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tkvr</p><p>SQL语言艺术.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/11Dte6piqSqH5Pu6kJ-aY3Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vuvg</p><p>SQL注入攻击与防御第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1-8dOeTUpDLDrvVJ-Cvc7Lg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yyux</p><p>SQL注入攻击与防御原书第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1joJZS9_QK4Pzc1rzXlKxlA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：efms</p><p>VisualC#数据库高级教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1yMlj5LyHy9Wz4camNrLeGw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：l0lz</p><p>设计有效的数据库系统.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kt5mzpLMsvN51RDIszTaaw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gnbx</p><p>数据库.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19eNfc0qaI5nZn4nSS0wKgA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mqxw</p><p>数据库查询优化器的艺术：原理解析与SQL性能优化.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fr11ipECSDb-svyemX4zDQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jxcv</p><p>数据库管理基础教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1edShCJlIVc1tDRqiJmNgJw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：saky</p><p>数据库管理系统第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VgjYq5wkzPa5c0GpbTnTYg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hwek</p><p>数据库设计教程第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1llPfN3VXo6Mw5YPaycYRiA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bkww</p><p>数据库系统导论-原书第八版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RK6fCpXZX3fEkvM5SBU2_A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dhge</p><p>数据库系统概念-原书第六版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1DkVWc-iGeBWWxZuOtxYwxw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sakx</p><p>数据库系统基础教程-原书第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1w33HafOgk7h3GLJ-Ut5Zzg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ftbp</p><p>数据库系统全书.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1z54u7ZLvyHMEVO-aP2iwcA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qhvb</p><p>数据库系统设计实现与管理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Up8b6C498s7M1lLlC0ReXQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xddg</p><p>数据库系统实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1FWzyeTSTOGoCnDNTpUOSfg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dxqx</p><p>数据库与事务处理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PsJ45MHV0PCsgyrj8pDTzA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yspv</p><h2 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h2><p>社交网站的数据挖掘与分析_中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Pu9o4QYGXmBsgvJ0sGqjaw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vywe</p><p>数据挖掘：实用机器学习技术（原书第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1NroTWqpcLB19cl1IyWyOpQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kjmb</p><p>数据挖掘概念与技术.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pumcjYmKfFZ8VaUcZgCEYw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykup</p><p>数据挖掘基础教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1EREYruDyMCPmq9kqR7Uq8w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yckk</p><p>数据挖掘实用机器学习工具与技术原书第三版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Li7Xjrwmipc0U9ijr5WwUQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bwgt</p><p>数据挖掘原理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1gu8oHS2XtuPv5Jxu77DlLA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vkmp</p><h2 id="算法系列"><a href="#算法系列" class="headerlink" title="算法系列"></a>算法系列</h2><p>C数据结构和算法分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/119TlKdgXWYj5QdrGwCyicA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ckwh</p><p>C数值算法程序大全.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zHEV2a4YA4MN0_jN4iZLPw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tbgw</p><p>Java常用算法手册.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HWvLLZPJE61zXIm8yaoapg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：skcw</p><p>Java常用算法手册第三版本.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vm36ZPfncut62oZ2jJ5-3g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bnjk</p><p>Java数据结构和算法.第二版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_EKJ5IgHjZFYdLk1o4Mu2w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：csad</p><p>啊哈！算法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1c8pUakJY6xfOYUaVJKvnqQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：npxg</p><p>大数据算法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1b9H66pNc8Z0LzMvLlgizMA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fvuc</p><p>高级数据结构.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VdHbHaxefL7CA0yoniZGIQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：grrm</p><p>和小浩学算法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jOHwgH8FY5QKpZnJRhzRvA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jtke</p><p>计算机算法分析与设计课件.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1PFCrqYhrgJUDtXFti-P1LA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kctg</p><p>经典算法大全.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1rZ6xTTlHOVtqoAImgJcakw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wkfj</p><p>离散数学导学.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1SzLiz4kVKQfgAdmdK3yrbA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：srjf</p><p>离散数学及其应用原书第七版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1w4iebO1bfNocgMfPa8XuQQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bjck</p><p>漫画算法：小灰的算法之旅 - 魏梦舒.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tFgroWnaYQr-X2ci5OtPRQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hjms</p><p>密码学导引.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1h099raG_ivawHCZ4tWk31w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：twdc</p><p>密码学基础教程秘密与承诺.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1pY7nr8w6Uhh4WjhY4PYrjg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tysf</p><p>密码学算法协议c实现.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1m2Hy-VfgwD5fx6MK273kJA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：twqg</p><p>深入理解机器学习从原理到算法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1szpU-intfQFlzxkxX1WEHw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xwgp</p><p>数据结构（C#语言版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mcQEiZMNZsODci_n0QUbZQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uavm</p><p>数据结构（Java版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Tjp1nRZuhWhvC_HKwxYbuQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mckf</p><p>数据结构讲义（严蔚敏版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1eFHuo2TmZhl6RH7FwwgR_Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vwyg</p><p>数据结构实例分析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JNYwq4XX8Mp4a7SYK_jcQg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rtwf</p><p>数据结构与STL.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Pg8gyoFANjlCYyc4CNq_vw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ccgm</p><p>数据结构与算法-JAVA语言.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ofptqxxZgfGglBuB9B9T9A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tgpj</p><p>数据结构与算法.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1K3DmV6P7m2uWLeNsfNg2cA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fegs</p><p>数据结构与算法Java版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10BI3NCMafNx8niBYV2PYrg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wftu</p><p>数据结构与算法（JAVA语言版解密）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19sIVT9nm2ZbIxLMfcEEtWw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tbwv</p><p>数据科学入门.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/18W_8MN5Uu4H-zsSRmr4AhA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jkab</p><p>算法导论（原书第三版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1P9lqf2fUYuJ-laoTS4JJtQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xhaf</p><p>算法导论（原书第三版）中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1RZkZH5Tb4lE38kmieurRRg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：frpr</p><p>算法导论第三版中文.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tjZd9odmAiJCJ4VvvaMMuw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dute</p><p>算法第四版-谢路云译.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YVRjo6YXQrb8DBU9phOB8w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kgtg</p><p>算法第四版-谢路云译Java描述.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19B3NF1NqUMi_MnDGtZPEKQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mqpr</p><p>算法分析导论_11562998.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Wqvb7mEF67Qeybyet8IXhQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xrgq</p><p>算法概论.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1u6NJjJpocFe_1gKlfAY4rw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gebr</p><p>算法基础.打开算法之门.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L8Zqr4LLlEqA0oKbDps5aQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：yssa</p><p>算法设计手册-第2版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dDxKZVxq2_TplFro3cmElA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hpet</p><p>算法设计与分析导论_11888784.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1i2mSmNW72raCBbmsc2BxAg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bjsr</p><p>算法设计与分析基础.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1umRr7JTLfp6tgWvKBGzcuQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nfgv</p><p>算法图解.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1KaUCkSW_Nt1yZTfDwqTEYQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rdkb</p><p>算法与数据结构-实用算法基础教程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1h61A39ID5ZYVdAs_Fp1vmg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dvbu</p><p>图解数据结构-使用Java.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1w_dYMOWZLxGBtUYmADog5A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fpvd</p><h2 id="新面试题"><a href="#新面试题" class="headerlink" title="新面试题"></a>新面试题</h2><p>Dubbo面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1i-2HU_podnONkXCIVITXBw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dewh</p><p>Elasticsearch面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1JfNokxTzcoTGwXof-hA6vQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fryw</p><p>Java程序员面试宝典.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mchSdZg81Nz0fjoDp8E2Dg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wdcc</p><p>Java程序员面试宝典（第二版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1asqIE61lGXposZ-p0AlyZg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vunv</p><p>Java程序员面试笔试宝典-何昊.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1qLnsU39IHDSKkog5aLS8FA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ukgj</p><p>Java程序员面试笔试真题库.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xSBYutVnwVHvj6z_lv5OJg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：swsf</p><p>Java程序员面试笔试真题与解析.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19i4svUmbEDBi-_KZYtB1Jg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gybx</p><p>Java核心知识点面试题整理.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/143GVY2tfMh_d_xM0oaxyLQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rcdm</p><p>Java面试宝典.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Kbdx5etJnN7esz01lc8gnQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vawb</p><p>JVM面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QvsniJFbncUrylWV47u6rA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tcgr</p><p>Kafka面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ZI_f14B-UbRYVl6c3naCtw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：hyyw</p><p>Linux面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10mthqPHRgqu9cSGdhAWitA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uxyv</p><p>Memcached面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12FgrF54YqbQi_JES2Ug8AA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tvew</p><p>MongoDB面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1FIxAbXaSHzD5sLf8Q4HT5A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jxhn</p><p>MyBatis面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1v0Llj_7wVPMKPHWGozAl_A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aewm</p><p>Mysql面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VUZM3sqXp5O6vfJEfylMsg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kyae</p><p>RabbitMQ面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1VOPFZGNxv4v8EK4I-f4GlA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：txtf</p><p>Redis面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mrY2VfeqTdPQZ-wu1Qn3Jw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xnaj</p><p>SpringBoot面试题.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1W1SVyA5URstE2vYYZRhs6g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：area</p><p>SpringCloud面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mc8P9o2FwXslX1HZtY3O0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sqdn</p><p>String面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UKTA4SBUI7ySilvKDUT0og">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tpny</p><p>ZooKeeper面试题-发布版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/11xLMllJ1O8J22Fs2q4AmmA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xqbn</p><p>剑指offer第2版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GnoqSMTaakGcA4HJi4fPiA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gxyb</p><h2 id="重构优化"><a href="#重构优化" class="headerlink" title="重构优化"></a>重构优化</h2><p>Java虚拟机并发编程.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MBwYNHEVuOq-V1FpPq7tfw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：texj</p><p>编程之美-.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1trz5QH73sRboEDtQjPtEJQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mawq</p><p>大神手把手教你Java性能优化-江南白衣（加强版）.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1lSGEI4vD4moEV3Uzcg_rkw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ucrd</p><p>代码大全2中文版.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1_GEyjV0Y4w3XpkRDj6iHrA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：aych</p><p>代码整洁之道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Xxiz8LzT7u1wazR0o-nEJA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：tymx</p><p>江南白衣优化.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1jGcfNaiT1k1V8tX6uabb8g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mvpa</p><p>重构-改善既有代码的设计.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1UGnVQwvguIMuFMf6yy8l4g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bssy  </p><h2 id="新增，第二版：面试题"><a href="#新增，第二版：面试题" class="headerlink" title="新增，第二版：面试题"></a>新增，第二版：面试题</h2><p>第二版：面试题 Android 100 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1iKSwXFJ6QYnSvpDITa0rwg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ewdu</p><p>第二版：面试题 Android 40 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1O4GgpzQg5S_22XHmhzegeg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：bspw</p><p>第二版：面试题 CSS 17 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mrrBhTMgAM8ENTs1AukWaA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ksge</p><p>第二版：面试题 CSS 50  道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1fjpSyKzZwASii8wCPb7S0Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：prfb</p><p>第二版：面试题 Dubbo  19 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TPsIFslNRspYSm9U8FNBkA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ppmv</p><p>第二版：面试题 Dubbo 30 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17Wkqpp5DhXKGQxQbu_00kg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：etff</p><p>第二版：面试题 Dubbo 58 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1r3K652QB2msrF8ph_MkQLA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sayu</p><p>第二版：面试题 Elasticsearch 24 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1r0zJ19iQhpHMa9j-fsDDIw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cxak</p><p>第二版：面试题 HTML 18 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zdFSUdU2eCZo6s6tcy0E_g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nmab</p><p>第二版：面试题 Java  100 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wDv-YWEyWXGzuJjHJ1UcGA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：junt</p><p>第二版：面试题 Java  17 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L__c7fExhoH3KbyILzFalg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kyxy</p><p>第二版：面试题 Java  算法 50 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1s3NQewKgT3Ly93K5U7BPUA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：affq</p><p>第二版：面试题 Java 133 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mxmXTNaMzru3RyRpZOME2A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ykde</p><p>第二版：面试题 Java 47  道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kGwAhK36voheuvYNOUpA5A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wfym</p><p>第二版：面试题 Java 95 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mvPwDa9vBaUpBX_SGybp4A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jtxu</p><p>第二版：面试题 Java 集合 72 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1vuEueYxuKJwN3IF7otPp9A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：swqr</p><p>第二版：面试题 Java 综合 84 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/17OaURL3iWKAEjtBSfKWMnw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：btry</p><p>第二版：面试题 JavaScript 43 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1YA_0XYBPqBTeY7ngpSxixA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xmys</p><p>第二版：面试题 JavaScript 45 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1p9s7pCEDDl-tOHXwZ2v4Jg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kytg</p><p>第二版：面试题 JavaScript 96 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1WRfTrjEMEZAdrGrTk9_Waw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：rfrb</p><p>第二版：面试题 JVM 20 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1y4Mxc9JhyHjZQgpuH0qC2g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：wfwx</p><p>第二版：面试题 Kafka 17 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1H64nJGtvYwxQK2KVD1h3jw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gmdq</p><p>第二版：面试题 kafka 18 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1ZXyeUUAivxuy5GskxEd2LQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：efuf</p><p>第二版：面试题 Kafka 50 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1H8kXIFfxCsGno25_y6bS5A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cuye</p><p>第二版：面试题 Linux 45 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1sOqNqcc4PpScq858S93zbA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qadp</p><p>第二版：面试题 Linux 70 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1968KSi1QiqC9rPauU95p5g">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：etun</p><p>第二版：面试题 Memcached 23 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/189Q1AZmcQVXDyQC5eT1knA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fpuf</p><p>第二版：面试题 MongoDB 24 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1L3ukE4vqeDQdLcb_b4TNUw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jhmr</p><p>第二版：面试题 MyBatis 27 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1D8ICwwMg5gMdMKFn2LF2Mg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kfsd</p><p>第二版：面试题 MyBatis 40 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1xuruCkfd_zLpjYndFf-uIw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ucst</p><p>第二版：面试题 MySQL 140 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1nAHFJHPRvS22aWxbc1i4WQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：xqnk</p><p>第二版：面试题 MySql 50 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1QeaKsRriqbxmGvMgugAHkQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fbjr</p><p>第二版：面试题 MySQL索引 6 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1H5qdmoCP3yMLvr_7gWVGMQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nqgg</p><p>第二版：面试题 Netty 11 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bXgemm4jllpH73l7TA3-Vw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jamh</p><p>第二版：面试题 Nginx 18 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1329KFq2Wfg9IqZnUMe3fBA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fqet</p><p>第二版：面试题 Python  36 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1kRyX4jAuQ41yR_euJk4nTg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：unjj</p><p>第二版：面试题 Python 292 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OTrxw-3JxKDgKQspoqs_pw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kydp</p><p>第二版：面试题 RabbitMQ 12 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1zMkeMXa6e9A4jvmJWOuEBg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ntsu</p><p>第二版：面试题 RabbitMQ 23 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1mk6rfXq6ronvvQmv-tRr5A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：etkd</p><p>第二版：面试题 React 17 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bI6NHgk8Qgk9W433Jt2Xig">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ksdw</p><p>第二版：面试题 Redis 27 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1OUNs5_ZZA4ug2S1rTTJFEw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ejyc</p><p>第二版：面试题 Redis 40 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/13ns5YkrurQzGBvH5XbswPA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：cnsj</p><p>第二版：面试题 Spring 55 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tT4RIqUishJS605rNJDaBA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pswp</p><p>第二版：面试题 Spring 70 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/10c5Pfv9BZnsjsrLR0A3iow">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jxfv</p><p>第二版：面试题 SpringBoot 10 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1idLAz8DDuSURBXYO2PJzUg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jfxs</p><p>第二版：面试题 SpringBoot 22 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dFnZIePqMFeEINB51QaA-Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：t25p</p><p>第二版：面试题 SpringCloud 20 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1naqYsW4UzMfiLHq3NrSrKg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ygxb</p><p>第二版：面试题 SpringCloud 22 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1tzoUY3TZg8dwAAljnDNfaw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：nmgd</p><p>第二版：面试题 SpringCloud 29 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1seZo1XloSEc0fNBncSW4vg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：mxda</p><p>第二版：面试题 SpringCloud 50 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1v36uJU32IXNkvqZZK9EAdg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：qbvn</p><p>第二版：面试题 SpringCloud 70 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1GG9X8Av_HZKh56ZWNRWEiw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uhbr</p><p>第二版：面试题 SpringCloud 8 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1gXQq18Zu0SEfC7hH6Oping">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vfwf</p><p>第二版：面试题 SpringMVC 35 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/15QaXlVGXUPh4FHGAF0y3JQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：canh</p><p>第二版：面试题 Tomcat 16 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1HkloT28H8Jb8Z1Cslaj22Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：gmqb</p><p>第二版：面试题 Vue 20 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1bE36aDEoRFLlv9vP33WMNw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：fcmg</p><p>第二版：面试题 Vue 39 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1dwPL_XHNnOMYDETFQ4Xs4Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：vapx</p><p>第二版：面试题 ZooKeeper 23 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/12_kkYMkwPuhts8RnoQWm9w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ufqw</p><p>第二版：面试题 ZooKeeper 28 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1Q-sxq0vpzInt-9HKTRqZ_Q">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：kkjh</p><p>第二版：面试题 ZooKeeper 36 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1B5T6Hmeb_uIvAV2wQHNVwA">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：dkwd</p><p>第二版：面试题 并发编程 140 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1FYsA869oaPcv1LJF9mdJnQ">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：pwek</p><p>第二版：面试题 并发编程 48 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1m5ThtAWHp4k2FGxQ72LHXg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：njgu</p><p>第二版：面试题 多线程 75 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1wiw1kA_iWQCjyFBTbndjtg">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：uxty</p><p>第二版：面试题 精选设计模式 10 道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1TijTPNvjqFAOBosM78ax7w">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：sxnn</p><p>第二版：面试题 前端汇总 100  道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/19XbZKt8QDrbDtTkBXOjy9A">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：jtfq</p><p>第二版：面试题 前端综合 45  道.pdf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://pan.baidu.com/s/1MiXOm2pkWFBvQL3-qrocfw">百度云下载链接</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;百度云提取码：ybev</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 资源备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言学习资料与社区索引</title>
      <link href="posts/59b44c83.html"/>
      <url>posts/59b44c83.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go-语言学习资料与社区索引"><a href="#Go-语言学习资料与社区索引" class="headerlink" title="Go 语言学习资料与社区索引"></a>Go 语言学习资料与社区索引</h1><p>go语言相关资料备忘</p><h2 id="交流社区"><a href="#交流社区" class="headerlink" title="交流社区"></a>交流社区</h2><h3 id="中文社区"><a href="#中文社区" class="headerlink" title="中文社区"></a>中文社区</h3><ul><li><a href="http://www.golangtc.com/">Golang 中国</a>：国内较早的 Go 社区，汇聚各类信息与服务</li><li><a href="http://studygolang.com/">Study Golang</a>：国内 Go 社区先驱，同样汇聚各类信息与服务</li><li><a href="http://gorevel.cn/">Revel 交流论坛</a>：<a href="https://github.com/revel/revel">Revel</a> 框架的中文社区</li><li><a href="https://gocn.vip/">GoCN Forum</a>：Go 语言爱好者中文交流论坛</li><li><a href="https://igo.pub/">IGO.PUB Go社区</a>：Go语言技术社区（新），完美主义者社区</li><li><a href="https://learnku.com/go">Go 技术论坛</a>: Golang / Go 语言中国知识社区</li><li>QQ 群：<ul><li>Go Web 交流群：259316004</li><li>Golang 中国：211938256</li><li>Go 内部实现与标准库：192706294</li><li>Go 编程语言：102319854</li><li>Martini&amp;Macaron 交流群：371440803</li><li>Golang 新手群：369793160</li></ul></li></ul><h3 id="英文社区"><a href="#英文社区" class="headerlink" title="英文社区"></a>英文社区</h3><ul><li><a href="https://forum.golangbridge.org/">Go Forum</a>：Go 语言爱好者英文交流论坛</li><li><a href="https://groups.google.com/forum/#!forum/golang-nuts">golang-nuts 邮件列表</a>：Go 语言官方指定邮件列表讨论区</li><li><a href="https://plus.google.com/u/0/communities/114112804251407510571">Go+ 社区</a>：Go 语言官方指定 G+ 社区</li></ul><h3 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h3><ul><li><a href="https://github.com/gocn/knowledge">Go Knowledge Graph</a>：Go 知识图谱</li></ul><h2 id="网址导航"><a href="#网址导航" class="headerlink" title="网址导航"></a>网址导航</h2><ul><li>官方：<ul><li><a href="https://golang.google.cn/">Go 中国站点</a>: Go 语言中国官方站点(无需翻墙)</li><li><a href="http://play.golang.org/">Playground</a>：Go 语言代码在线运行</li></ul></li><li>国内镜像：<ul><li><a href="http://tour.golangtc.com/">Go 指南国内镜像</a></li><li><a href="http://www.golangtc.com/download">Go 语言国内下载镜像</a></li><li><a href="http://docs.studygolang.com/">Go 官方网站国内镜像</a></li></ul></li><li>Web 框架：<ul><li><a href="https://go-macaron.com/">Macaron</a>：模块化 Web 框架</li><li><a href="http://beego.me/">Beego</a>：重量级 Web 框架</li><li><a href="https://github.com/revel/revel">Revel</a>：较早成熟的重量级 Web 框架</li><li><a href="https://github.com/go-martini/martini">Martini</a>: 一个强大为了编写模块化 Web 应用而生的 Go 语言框架</li><li><a href="https://echo.labstack.com/">Echo</a>: 功能模块齐全, 上手容易, 文档示例齐全</li><li><a href="https://github.com/gin-gonic/gin">Gin</a>：轻量级 HTTP Web 框架</li><li><a href="https://github.com/kataras/iris">Iris</a>：Iris 是基于 Go 编写的一个快速，简单但功能齐全且非常高效的 Web 框架</li></ul></li><li>ORM 以及数据库驱动：<ul><li><a href="https://github.com/go-xorm/xorm">xorm</a>：支持 MySQL、PostgreSQL、SQLite3 以及 MsSQL</li><li><a href="http://labix.org/mgo">mgo</a>：MongoDB 官方推荐驱动</li><li><a href="https://github.com/jinzhu/gorm">gorm</a>: 全功能 ORM (无限接近) 支持 MySQL、PostgreSQL、SQLite3 以及 MsSQL</li><li><a href="https://github.com/rushteam/gosql">gosql</a>:  gosql 一款全新ORM go-style风格、轻量、简单、强大 支持 MySQL</li></ul></li><li>辅助站点：<ul><li><a href="https://gowalker.org/">Go Walker</a>：Go 语言在线 API 文档</li><li><a href="http://gobuild.io/">gobuild.io</a>：Go 语言在线二进制编译与下载</li><li><a href="http://regoio.herokuapp.com/">Rego</a>：Go 语言正则在线测试</li><li><a href="https://gopm.io/">gopm.io</a>：科学下载第三方包</li><li><a href="https://mholt.github.io/json-to-go/">Json To Go struct</a>:Convert JSON to Go struct在线工具</li></ul></li><li>开发工具：<ul><li><a href="http://ftp.gnu.org/gnu/emacs/">Emacs24</a>：<a href="https://github.com/wackonline/hack/blob/master/install-mint-dev/install-emacs.d.sh">配置脚本</a> / <a href="http://emacser.com/">(中文社区)</a></li><li><a href="https://github.com/visualfc/liteide">LiteIDE</a></li><li><a href="http://sublimetext.com/">Sublime Text 2/3</a>：<a href="http://my.oschina.net/Obahua/blog/110767">配置教程</a></li><li><a href="https://www.jetbrains.com/go/?fromMenu">GoLand</a></li><li><a href="https://atom.io/">Atom</a>：<a href="https://atom.io/packages/go-plus">配置插件</a>（感觉还不错，类似 Sublime，配置比较简单）</li><li><a href="http://www.vim.org/">VIM</a>：<a href="https://github.com/humiaozuzu/dot-vimrc">配置插件</a>（嫌 vim 配置麻烦的童鞋可以直接用这个）</li></ul></li><li>学习站点：<ul><li><a href="https://gobyexample.com/">Go by Example</a></li><li><a href="http://go-database-sql.org/">Go database/sql tutorial</a></li></ul></li><li>支持 Go 的云平台：<ul><li><a href="https://koding.com/">Koding</a></li><li><a href="https://www.nitrous.io/">Nitrous.IO</a></li><li><a href="https://cloud.google.com/go/">Get up and running with Go on Google Cloud Platform</a></li><li><a href="http://aws.amazon.com/cn/sdk-for-go/">AWS SDK for Go - Developer Preview</a>:=&gt;<a href="https://github.com/aws/aws-sdk-go">github</a></li><li><a href="https://godoc.org/github.com/Azure/azure-sdk-for-go">azure sdk for go</a>:=&gt;<a href="https://github.com/Azure/azure-sdk-for-go">github</a><ul><li><a href="https://azure.microsoft.com/zh-cn/documentation/articles/virtual-machines-linux-coreos-how-to/">How to Use CoreOS on Azure</a></li><li><a href="https://azure.microsoft.com/zh-cn/documentation/templates/101-webapp-with-golang/">Create Azure Web app with GoLang extension</a></li></ul></li><li><a href="https://www.qiniu.com/">Qiniu</a><ul><li><a href="http://developer.qiniu.com/docs/v6/sdk/go-sdk.html">Qiniu SDK for Go</a>:=&gt;<a href="https://github.com/qiniu/api.v6">github</a></li></ul></li></ul></li><li>其它站点：<ul><li><a href="https://flipboard.com/section/the-golang-magazine-bJ1GqB">Golang 杂志</a>：<a href="http://bbs.go-china.org/post/476">订阅说明</a></li><li><a href="http://www.reddit.com/r/golang/">Reddit</a></li><li><a href="http://www.newspaper.io/golang">Newspaper.IO</a>：Golang 新闻订阅</li><li><a href="http://www.golangweekly.com/">Go Newsletter</a>：Golang 新闻订阅</li></ul></li></ul><h2 id="资料汇总"><a href="#资料汇总" class="headerlink" title="资料汇总"></a>资料汇总</h2><h3 id="中文资料"><a href="#中文资料" class="headerlink" title="中文资料"></a>中文资料</h3><ul><li>书籍：<ul><li><a href="https://github.com/tiancaiamao/go-internals">《深入解析Go》</a></li><li><a href="https://github.com/astaxie/Go-in-Action">《Go实战开发》</a></li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">《Go入门指南》</a></li><li><a href="https://github.com/polaris1119/The-Golang-Standard-Library-by-Example">《Go语言标准库》</a></li><li><a href="https://github.com/astaxie/build-web-application-with-golang">《Go Web 编程》</a></li><li><a href="https://github.com/achun/Go-Blog-In-Action">《Go语言博客实践》</a></li><li><a href="https://github.com/qyuhen/book">《Go语言学习笔记》</a></li><li><a href="https://github.com/chai2010/advanced-go-programming-book">《Go语言高级编程》</a></li></ul></li><li>翻译：<ul><li><a href="https://golang.org/doc/effective_go.html">Effective Go</a> 英文版</li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN">The Way to Go</a> 中文版</li><li><a href="https://github.com/miekg/gobook">《Learning Go》</a>英文版:=&gt;<a href="https://github.com/mikespook/Learning-Go-zh-cn">《Learning Go》</a> 中文版</li></ul></li><li>教程：<ul><li><a href="https://github.com/Unknwon/go-fundamental-programming">《Go编程基础》</a></li><li><a href="https://github.com/Unknwon/go-web-foundation">《Go Web基础》</a></li><li><a href="https://github.com/Unknwon/go-rock-libraries-showcases">《Go名库讲解》</a></li><li><a href="https://github.com/hyper-carrot/go_command_tutorial">Go 命令教程</a></li></ul></li></ul><h3 id="英文资料"><a href="#英文资料" class="headerlink" title="英文资料"></a>英文资料</h3><ul><li>文档：<ul><li><a href="https://code.google.com/p/go-wiki/wiki/CodeReviewComments">Go Code Review Comments</a>：Go 语言代码风格指导</li><li><a href="https://github.com/Unknwon/go-code-convention">Go Code Convention</a>：无闻的 Go 语言编码规范</li><li><a href="https://github.com/xxjwxc/uber_go_guide_cn">Uber Go Guide</a>: Uber Go 语言编码规范</li><li><a href="https://github.com/gophercon/2014-talks">GopherCon 2014</a></li><li><a href="https://github.com/gophercon/2015-talks">GopherCon 2015</a></li><li><a href="https://github.com/gophercon/2016-talks">GopherCon 2016</a></li><li><a href="https://github.com/gophercon/2017-talks">GopherCon 2017</a></li></ul></li><li>书籍：<ul><li><a href="http://jan.newmarch.name/go/">Network programming with Go</a>：<a href="https://github.com/astaxie/NPWG_zh">中文版</a></li><li><a href="https://leanpub.com/gocrypto/read#leanpub-auto-select-bibliography">Practical Cryptography With Go</a></li><li><a href="http://www.golang-book.com/">An Introduction to Programming in Go</a></li><li><a href="http://www.golangbootcamp.com/book">Go Bootcamp</a></li><li><a href="https://www.packtpub.com/application-development/mastering-concurrency-go">Mastering Concurrency in Go(July 2014)Nathan Kozyra</a></li><li><a href="https://www.packtpub.com/application-development/go-programming-blueprints">Go Programming Blueprints(January 23,2015)</a></li><li><a href="http://www.gopl.io/">The Go Programming Language(Published Oct 30, 2015,Not Yet Published)</a></li><li><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html">Practical Go: Real world advice for writing maintainable Go programs</a></li></ul></li></ul><h3 id="视频资料"><a href="#视频资料" class="headerlink" title="视频资料"></a>视频资料</h3><ul><li>基础：<ul><li>Go Slices and Bytes - Shakeel Mahate：<a href="http://v.youku.com/v_show/id_XNjkzMjM1Mjg4.html">优酷视频</a> - <a href="http://www.youtube.com/watch?v=dKlNSIUSfz0">Youtube</a></li></ul></li><li>COSCUP 2013:<ul><li>Golang &amp; ORM - 林佑安：<a href="http://v.youku.com/v_show/id_XNjkzMTQ1MjYw.html">优酷视频</a> - <a href="http://www.youtube.com/watch?v=VwAtYGyjTks">Youtube</a></li></ul></li><li>GopherCon：<ul><li>2014：<a href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBcD_BiJiDJUcyrb2w3bTulF">Youtube</a></li><li>2015：<a href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm">Youtube</a></li><li>2016：<a href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBdliXelGAItjzTMxy2WQh0P">Youtube</a></li><li>2017：<a href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBdD9bru6IR-_WXUgJqvrtx9">Youtube</a></li><li>2018：<a href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBdatAqf-2_125H4sGzaWngM">Youtube</a></li><li>2019：<a href="https://www.youtube.com/playlist?list=PL2ntRZ1ySWBdDyspRTNBIKES1Y-P__59_">Youtube</a></li></ul></li><li>Golang UK Conference：<ul><li>2015：<a href="https://www.youtube.com/playlist?list=PLDWZ5uzn69ezRJYeWxYNRMYebvf8DerHd">Youtube</a></li><li>2016：<a href="https://www.youtube.com/playlist?list=PLDWZ5uzn69eyh791ZTkEA9OaTxVpGY8_g">Youtube</a></li><li>2017：<a href="https://www.youtube.com/playlist?list=PLDWZ5uzn69eyM81omhIZLzvRhTOXvpeX9">Youtube</a></li><li>2018：<a href="https://www.youtube.com/playlist?list=PLDWZ5uzn69ewsMyuGjVsAnpQIjyud1Cv9">Youtube</a></li><li>2019：<a href="https://www.youtube.com/playlist?list=PLDWZ5uzn69ezokLCB-nGgYInxL0uP1PeZ">Youtube</a></li></ul></li><li>GopherCon India 2015: <a href="https://www.youtube.com/playlist?list=PLxFC1MYuNgJTY3uQ5Ja4F5Sz305nnrBOq">Youtube</a></li></ul><h2 id="职业信息"><a href="#职业信息" class="headerlink" title="职业信息"></a>职业信息</h2><ul><li>Go/Golang jobs：<ul><li>官方网站：<a href="http://www.golangprojects.com/">http://www.golangprojects.com/</a></li><li>Twitter: <a href="https://twitter.com/golangprojects">@golangprojects</a>  </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 资源备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言上下文Context</title>
      <link href="posts/881e81b3.html"/>
      <url>posts/881e81b3.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文章转载自"><a href="#本文章转载自" class="headerlink" title="本文章转载自  "></a><strong>本文章转载自</strong>  <a class="btn-beautify button--animated orange larger" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/"   title="draveness"><i class="far fa-hand-point-right fa-fw"></i><span>draveness</span></a></h2><h1 id="1-1-上下文-Context"><a href="#1-1-上下文-Context" class="headerlink" title="1.1 上下文 Context"></a>1.1 上下文 Context</h1><p>上下文 context.Context Go 语言中用来设置截止日期、同步信号，传递请求相关值的结构体。上下文与 Goroutine 有比较密切的关系，是 Go 语言中独特的设计，在其他编程语言中我们很少见到类似的概念。</p><p>context.Context 是 Go 语言在 1.7 版本中引入标准库的接口1，该接口定义了四个需要实现的方法，其中包括：</p><ul><li><p>Deadline — 返回 context.Context 被取消的时间，也就是完成工作的截止日期；</p></li><li><p>Done — 返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消后关闭，多次调用 Done 方法会返回同一个 Channel；</p></li><li><p>Err — 返回 context.Context 结束的原因，它只会在 Done 方法对应的 Channel 关闭时返回非空的值；</p><ul><li>如果 context.Context 被取消，会返回 Canceled 错误；</li><li>如果 context.Context 超时，会返回 DeadlineExceeded 错误；</li></ul></li><li><p>Value — 从 context.Context 中获取键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法可以用来传递请求特定的数据；</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">Err() error</span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context 包中提供的 <code>context.Background</code>、<code>context.TODO</code>、<code>context.WithDeadline</code> 和 <code>context.WithValue</code> 函数会返回实现该接口的私有结构体，我们会在后面详细介绍它们的工作原理。</p></li></ul><h2 id="1-1-1-设计原理"><a href="#1-1-1-设计原理" class="headerlink" title="1.1.1 设计原理"></a>1.1.1 设计原理</h2><p>在 Goroutine 构成的树形结构中对信号进行同步以减少计算资源的浪费是 context.Context 的最大作用。Go 服务的每一个请求都是通过单独的 Goroutine 处理的2，HTTP/RPC 请求的处理器会启动新的 Goroutine 访问数据库和其他服务。</p><p>如下图所示，我们可能会创建多个 Goroutine 来处理一次请求，而 context.Context 的作用是在不同 Goroutine 之间同步请求特定数据、取消信号以及处理请求的截止日期。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/golang-context-usage.png" alt="golang-context-usage.png"><br>图 1-1 Context 与 Goroutine 树</p><p>每一个 context.Context 都会从最顶层的 Goroutine 一层一层传递到最下层。context.Context 可以在上层 Goroutine 执行出现错误时，将信号及时同步给下层。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/golang-without-context.png" alt="golang-without-context.png"><br>图 1-2 不使用 Context 同步信号</p><p>如上图所示，当最上层的 Goroutine 因为某些原因执行失败时，下层的 Goroutine 由于没有接收到这个信号所以会继续工作；但是当我们正确地使用 context.Context 时，就可以在下层及时停掉无用的工作以减少额外资源的消耗：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/golang-with-context.png" alt="golang-with-context.png"></p><p>图 1-3 使用 Context 同步信号</p><p>我们可以通过一个代码片段了解 context.Context 是如何对信号进行同步的。在这段代码中，我们创建了一个过期时间为 1s 的上下文，并向上下文传入 handle 函数，该方法会使用 500ms 的时间处理传入的请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> handle(ctx, <span class="number">500</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;main&quot;</span>, ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;handle&quot;</span>, ctx.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">fmt.Println(<span class="string">&quot;process request with&quot;</span>, duration)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为过期时间大于处理时间，所以我们有足够的时间处理该请求，运行上述代码会打印出下面的内容：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run context.<span class="keyword">go</span></span><br><span class="line">process request with <span class="number">500</span>ms</span><br><span class="line">main context deadline exceeded</span><br></pre></td></tr></table></figure><p>handle 函数没有进入超时的 select 分支，但是 main 函数的 select 却会等待 context.Context 超时并打印出 main context deadline exceeded。</p><p>如果我们将处理请求时间增加至 1500ms，整个程序都会因为上下文的过期而被中止，：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run context.<span class="keyword">go</span></span><br><span class="line">main context deadline exceeded</span><br><span class="line">handle context deadline exceeded</span><br></pre></td></tr></table></figure><p>相信这两个例子能够帮助各位读者理解 context.Context 的使用方法和设计原理 — 多个 Goroutine 同时订阅 ctx.Done() 管道中的消息，一旦接收到取消信号就立刻停止当前正在执行的工作。</p><h2 id="1-1-2-默认上下文"><a href="#1-1-2-默认上下文" class="headerlink" title="1.1.2 默认上下文"></a>1.1.2 默认上下文</h2><p>context 包中最常用的方法还是 context.Background、context.TODO，这两个方法都会返回预先初始化好的私有变量 background 和 todo，它们会在同一个 Go 程序中被复用：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个私有变量都是通过 new(emptyCtx) 语句初始化的，它们是指向私有结构体 context.emptyCtx 的指针，这是最简单、最常用的上下文类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中，我们不难发现 context.emptyCtx 通过空方法实现了 context.Context 接口中的所有方法，它没有任何功能。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/golang-context-hierarchy.png" alt="golang-context-hierarchy.png"><br>图 1-4 Context 层级关系</p><p>从源代码来看，context.Background 和 context.TODO 也只是互为别名，没有太大的差别，只是在使用和语义上稍有不同：</p><p>context.Background 是上下文的默认值，所有其他的上下文都应该从它衍生出来；<br>context.TODO 应该仅在不确定应该使用哪种上下文时使用；<br>在多数情况下，如果当前函数没有上下文作为入参，我们都会使用 context.Background 作为起始的上下文向下传递。</p><h2 id="1-1-3-取消信号"><a href="#1-1-3-取消信号" class="headerlink" title="1.1.3 取消信号"></a>1.1.3 取消信号</h2><p>context.WithCancel 函数能够从 context.Context 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/golang-parent-cancel-context.png" alt="golang-parent-cancel-context.png"><br>图 1-5 Context 子树的取消</p><p>我们直接从 context.WithCancel 函数的实现来看它到底做了什么：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span> &#123;</span><br><span class="line">c := newCancelCtx(parent)</span><br><span class="line">propagateCancel(parent, &amp;c)</span><br><span class="line"><span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context.newCancelCtx</code> 将传入的上下文包装成私有结构体 <code>context.cancelCtx</code>；<br><code>context.propagateCancel</code> 会构建父子上下文之间的关联，当父上下文被取消时，子上下文也会被取消：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">done := parent.Done()</span><br><span class="line"><span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// 父上下文不会触发取消信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err()) <span class="comment">// 父上下文已经被取消</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数总共与父上下文相关的三种不同的情况：</p><p>当 <code>parent.Done() == nil</code>，也就是 <code>parent</code> 不会触发取消事件时，当前函数会直接返回；<br>当 <code>child</code> 的继承链包含可以取消的上下文时，会判断 <code>parent</code> 是否已经触发了取消信号；<br>如果已经被取消，<code>child</code> 会立刻被取消；<br>如果没有被取消，<code>child</code> 会被加入 <code>parent</code> 的 <code>children</code> 列表中，等待 <code>parent</code> 释放取消信号；<br>当父上下文是开发者自定义的类型、实现了 <code>context.Context</code> 接口并在 <code>Done()</code> 方法中返回了非空的管道时；<br>运行一个新的 Goroutine 同时监听 <code>parent.Done()</code> 和 <code>child.Done()</code> 两个 Channel；<br>在 <code>parent.Done()</code> 关闭时调用 <code>child.cancel</code> 取消子上下文；<br><code>context.propagateCancel</code> 的作用是在 <code>parent</code> 和 <code>child</code> 之间同步取消和结束的信号，保证在 <code>parent</code> 被取消时，<code>child</code> 也会收到对应的信号，不会出现状态不一致的情况。</p><p><code>context.cancelCtx</code> 实现的几个接口方法也没有太多值得分析的地方，该结构体最重要的方法是 <code>context.cancelCtx.cancel</code>，该方法会关闭上下文中的 Channel 并向所有的子上下文同步取消信号：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">c.err = err</span><br><span class="line"><span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">c.done = closedchan</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(c.done)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">c.children = <span class="literal">nil</span></span><br><span class="line">c.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 <code>context.WithCancel</code> 之外，<code>context</code> 包中的另外两个函数 <code>context.WithDeadline</code> 和 <code>context.WithTimeout</code> 也都能创建可以被取消的计时器上下文 <code>context.timerCtx</code>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span> <span class="params">(Context, CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// 已经过了截止日期</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context.WithDeadline</code> 在创建 <code>context.timerCtx</code> 的过程中判断了父上下文的截止日期与当前日期，并通过 <code>time.AfterFunc </code>创建定时器，当时间超过了截止日期后会调用 <code>context.timerCtx.cancel</code> 同步取消信号。</p><p><code>context.timerCtx</code> 内部不仅通过嵌入 <code>context.cancelCtx</code> 结构体继承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消的功能：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span> <span class="title">cancel</span><span class="params">(removeFromParent <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context.timerCtx.cancel</code> 方法不仅调用了 <code>context.cancelCtx.cancel</code>，还会停止持有的定时器减少不必要的资源浪费。</p><h2 id="1-1-4-传值方法"><a href="#1-1-4-传值方法" class="headerlink" title="1.1.4 传值方法"></a>1.1.4 传值方法</h2><p>在最后我们需要了解如何使用上下文传值，context 包中的 context.WithValue 能从父上下文中创建一个子上下文，传值的子上下文使用 context.valueCtx 类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br><span class="line">Go</span><br><span class="line">context.valueCtx 结构体会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，它只会响应 context.valueCtx.Value 方法，该方法的实现也很简单：</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">if</span> c.key == key &#123;</span><br><span class="line"><span class="keyword">return</span> c.val</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 context.valueCtx 中存储的键值对与 context.valueCtx.Value 方法中传入的参数不匹配，就会从父上下文中查找该键对应的值直到某个父上下文中返回 nil 或者查找到对应的值。</p><h2 id="1-1-5-小结"><a href="#1-1-5-小结" class="headerlink" title="1.1.5 小结"></a>1.1.5 小结</h2><p>Go 语言中的 context.Context 的主要作用还是在多个 Goroutine 组成的树中同步取消信号以减少对资源的消耗和占用，虽然它也有传值的功能，但是这个功能我们还是很少用到。</p><p>在真正使用传值的功能时我们也应该非常谨慎，使用 context.Context 进行传递参数请求的所有参数一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。</p><h1 id="1-2-使用示例"><a href="#1-2-使用示例" class="headerlink" title="1.2 使用示例"></a>1.2 使用示例</h1><h2 id="1-2-1-在go程序中使用context进行取消操作"><a href="#1-2-1-在go程序中使用context进行取消操作" class="headerlink" title="1.2.1 在go程序中使用context进行取消操作"></a>1.2.1 在go程序中使用context进行取消操作</h2><h3 id="1-2-1-1-使用context取消的目的是什么？"><a href="#1-2-1-1-使用context取消的目的是什么？" class="headerlink" title="1.2.1.1 使用context取消的目的是什么？"></a>1.2.1.1 使用context取消的目的是什么？</h3><p>简而言之，我们需要取消操作以防止我们的系统执行不必要的工作。例如HTTP服务器调用数据库并将查询的数据返回给客户端的常见情况：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/client-diagram.svg" alt="client-diagram.svg"></p><p>1-6 客户端服务器模型图</p><ul><li>如果一切正常，时序图将如下所示：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/timing-ideal.svg" alt="timing-ideal.svg"></li></ul><p>1-7 所有事件结束的时序图</p><ul><li>但是，如果客户端在中间取消了请求，将会发生什么？<ul><li>例如，如果客户端在请求中关闭了浏览器，则可能会发生这种情况。如果不取消，则应用程序服务器和数据库将继续执行其工作，即使这样做会浪费工作的结果：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/timing-without-cancel.svg" alt="timing-without-cancel.svg"><br>1-8 取消HTTP请求后所有进程继续执行的时序图</li><li>理想情况下，如果我们知道该进程（在此示例中为HTTP请求）已停止，则我们希望该进程的所有下游组件都停止运行：<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/timing-with-cancel.svg" alt="timing-with-cancel.svg"><br>1-9 取消HTTP请求后所有进程都将取消的时序图</li></ul></li></ul><h3 id="1-2-1-2-使用context取消"><a href="#1-2-1-2-使用context取消" class="headerlink" title="1.2.1.2 使用context取消"></a>1.2.1.2 使用context取消</h3><p>现在我们知道了为什么需要取消，让我们进入如何在Go中实现它。由于“取消”事件与交易或正在执行的操作高度相关，因此很自然地将其与捆绑在一起context。</p><p>cancel有两个方面：</p><ul><li>监听取消事件</li><li>发出取消事件</li></ul><h4 id="监听取消事件"><a href="#监听取消事件" class="headerlink" title="监听取消事件"></a>监听取消事件</h4><p>该Context类型提供一种Done()方法，struct{}每次上下文接收到取消事件时，该方法都会返回一个接收空类型的通道。聆听取消事件就像等待一样容易&lt;- ctx.Done()。</p><p>例如，让我们考虑一个需要花费两秒钟来处理事件的HTTP服务器。如果在此之前请求被取消，我们想立即返回：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create an HTTP server that listens on port 8000</span></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">ctx := r.Context()</span><br><span class="line"><span class="comment">// This prints to STDOUT to show that processing has started</span></span><br><span class="line">fmt.Fprint(os.Stdout, <span class="string">&quot;processing request\n&quot;</span>)</span><br><span class="line"><span class="comment">// We use `select` to execute a peice of code depending on which</span></span><br><span class="line"><span class="comment">// channel receives a message first</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line"><span class="comment">// If we receive a message after 2 seconds</span></span><br><span class="line"><span class="comment">// that means the request has been processed</span></span><br><span class="line"><span class="comment">// We then write this as the response</span></span><br><span class="line">w.Write([]<span class="keyword">byte</span>(<span class="string">&quot;request processed&quot;</span>))</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">// If the request gets cancelled, log it</span></span><br><span class="line"><span class="comment">// to STDERR</span></span><br><span class="line">fmt.Fprint(os.Stderr, <span class="string">&quot;request cancelled\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="发出取消事件"><a href="#发出取消事件" class="headerlink" title="发出取消事件"></a>发出取消事件</h4><p>如果有可以取消的操作，则必须通过上下文发出取消事件。可以使用上下文包中的WithCancel函数（该函数返回一个上下文对象）和一个函数来完成此操作。此函数不带任何参数，不返回任何内容，当您要取消上下文时会调用此函数。<br>考虑2个从属操作的情况。在这里，“依赖”意味着如果一个失败，那么另一个就没有意义。在这种情况下，如果我们很早就知道其中一个操作失败，那么我们想取消所有相关的操作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation1</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Let&#x27;s assume that this operation failed for some reason</span></span><br><span class="line"><span class="comment">// We use time.Sleep to simulate a resource intensive operation</span></span><br><span class="line">time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// We use a similar pattern to the HTTP server</span></span><br><span class="line"><span class="comment">// that we saw in the earlier example</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;halted operation2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a new context</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line"><span class="comment">// Create a new context, with its cancellation function</span></span><br><span class="line"><span class="comment">// from the original context</span></span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run two operations: one in a different go routine</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := operation1(ctx)</span><br><span class="line"><span class="comment">// If this operation returns an error</span></span><br><span class="line"><span class="comment">// cancel all operations using this context</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run operation2 with the same context we use for operation1</span></span><br><span class="line">operation2(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基于时间的取消事件"><a href="#基于时间的取消事件" class="headerlink" title="基于时间的取消事件"></a>基于时间的取消事件</h4><p>例如，对外部服务进行HTTP API调用。如果服务花费的时间太长，最好尽早失败并取消请求：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Create a new context</span></span><br><span class="line"><span class="comment">// With a deadline of 100 milliseconds</span></span><br><span class="line">ctx := context.Background()</span><br><span class="line">ctx, _ = context.WithTimeout(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make a request, that will call the google homepage</span></span><br><span class="line">req, _ := http.NewRequest(http.MethodGet, <span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// Associate the cancellable context we just created to the request</span></span><br><span class="line">req = req.WithContext(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new HTTP client and execute the request</span></span><br><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="comment">// If the request failed, log to STDOUT</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Request failed:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Print the statuscode if the request succeeds</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Response received, status code:&quot;</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-1-3-小结"><a href="#1-2-1-3-小结" class="headerlink" title="1.2.1.3 小结"></a>1.2.1.3 小结</h3><p>尽管Go中的上下文取消功能是一种多功能工具，但是在继续操作之前，需要牢记一些注意事项。其中最重要的是，上下文只能被取消一次。如果希望在同一操作中传播多个错误，那么使用上下文取消可能不是最佳选择。使用取消的最惯用的方式是当实际上要取消某项时，而不仅仅是通知下游进程发生了错误。<br>还需要记住的另一件事是，应将相同的上下文实例传递给可能要取消的所有函数和例程。用<code>WithTimeout</code>或<code>WithCancel</code>包装已经可以取消的上下文会导致取消上下文的多种可能性，应该避免。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言插件系统</title>
      <link href="posts/cd337a10.html"/>
      <url>posts/cd337a10.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文章转载自"><a href="#本文章转载自" class="headerlink" title="本文章转载自  "></a><strong>本文章转载自</strong>  <a class="btn-beautify button--animated orange larger" href="https://draveness.me/golang/docs/part4-advanced/ch08-metaprogramming/golang-plugin/"   title="draveness"><i class="far fa-hand-point-right fa-fw"></i><span>draveness</span></a></h2><h1 id="8-1-插件系统"><a href="#8-1-插件系统" class="headerlink" title="8.1 插件系统"></a>8.1 插件系统</h1><p>熟悉 Go 语言的开发者一般都非常了解 Goroutine 和 Channel 的原理，包括如何设计基于 CSP 模型的应用程序，但是 Go 语言的插件系统是很少有人了解的模块，通过插件系统，我们可以在运行时加载动态库实现一些比较有趣的功能。</p><h2 id="8-1-1-设计原理"><a href="#8-1-1-设计原理" class="headerlink" title="8.1.1 设计原理"></a>8.1.1 设计原理</h2><p>Go 语言的插件系统基于 C 语言动态库实现的，所以它也继承了 C 语言动态库的优点和缺点，我们在本节中会对比 Linux 中的静态库和动态库，分析它们各自的特点和优势。</p><p>静态库或者静态链接库是由编译期决定的程序、外部函数和变量构成的，编译器或者链接器会将程序和变量等内容拷贝到目标的应用并生成一个独立的可执行对象文件1；<br>动态库或者共享对象可以在多个可执行文件之间共享，程序使用的模块会在运行时从共享对象中加载，而不是在编译程序时打包成独立的可执行文件2；<br>由于特性不同，静态库和动态库的优缺点也比较明显；只依赖静态库并且通过静态链接生成的二进制文件因为包含了全部的依赖，所以能够独立执行，但是编译的结果也比较大；而动态库可以在多个可执行文件之间共享，可以减少内存的占用，其链接的过程往往也都是在装载或者运行期间触发的，所以可以包含一些可以热插拔的模块并降低内存的占用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/static-library-dynamic-library.png" alt="static-library-dynamic-library.png"></p><p>图 8-1 静态库与动态库</p><p>使用静态链接编译二进制文件在部署上有非常明显的优势，最终的编译产物也可以直接运行在大多数的机器上，静态链接带来的部署优势远比更低的内存占用显得重要，所以很多编程语言包括 Go 都将静态链接作为默认的链接方式。</p><h3 id="插件系统"><a href="#插件系统" class="headerlink" title="插件系统"></a>插件系统</h3><p>在今天，动态链接带来的低内存占用优势虽然已经没有太多作用，但是动态链接的机制却可以为我们提供更多的灵活性，主程序可以在编译后动态加载共享库实现热插拔的插件系统。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/plugin-system.png" alt="plugin-system.png"></p><p>图 8-2 插件系统</p><p>通过在主程序和共享库直接定义一系列的约定或者接口，我们可以通过以下的代码动态加载其他人编译的 Go 语言共享对象，这样做的好处是主程序和共享库的开发者不需要共享代码，只要双方的约定不变，修改共享库后也不需要重新编译主程序。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">    Name() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p, err := plugin.Open(<span class="string">&quot;driver.so&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newDriverSymbol, err := p.Lookup(<span class="string">&quot;NewDriver&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newDriverFunc := newDriverSymbol.(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">Driver</span>)</span></span><br><span class="line">    newDriver := newDriverFunc()</span><br><span class="line">    fmt.Println(newDriver.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了 Driver 接口并认为共享库中一定包含 func NewDriver() Driver 函数，当我们通过 plugin.Open 读取包含 Go 语言插件的共享库后，获取文件中的 NewDriver 符号并转换成正确的函数类型，可以通过该函数初始化新的 Driver 并获取它的名字了。</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>不同的操作系统会实现不同的动态链接机制和共享库格式，Linux 中的共享对象会使用 ELF 格式3并提供了一组操作动态链接器的接口，在本节的实现中我们会看到以下的几个接口4：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br></pre></td></tr></table></figure><p>dlopen 会根据传入的文件名加载对应的动态库并返回一个句柄（Handle）；我们可以直接使用 dlsym 函数在该句柄中搜索特定的符号，也就是函数或者变量，它会返回该符号被加载到内存中的地址。因为待查找的符号可能不存在于目标动态库中，所以在每次查找后我们都应该调用 dlerror 查看当前查找的结果。</p><h2 id="8-1-2-动态库"><a href="#8-1-2-动态库" class="headerlink" title="8.1.2 动态库"></a>8.1.2 动态库</h2><p>Go 语言插件系统的全部实现都包含在 plugin 中，这个包实现了符号系统的加载和决议。插件是一个带有公开函数和变量的包，我们需要使用下面的命令编译插件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -buildmode=plugin ...</span><br></pre></td></tr></table></figure><p>该命令会生成一个共享对象 .so 文件，当该文件被加载到 Go 语言程序时会使用下面的结构体 plugin.Plugin 表示，该结构体中包含文件的路径以及包含的符号等信息：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Plugin <span class="keyword">struct</span> &#123;</span><br><span class="line">pluginpath <span class="keyword">string</span></span><br><span class="line">syms       <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与插件系统相关的两个核心方法分别是用于加载共享文件的 plugin.Open 和在插件中查找符号的 plugin.Plugin.Lookup，本节将详细介绍它们的实现原理。</p><h3 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h3><p>在具体分析 plugin 包中几个公有方法之前，我们需要先了解一下包中使用的两个 C 语言函数 plugin.pluginOpen 和 plugin.pluginLookup；plugin.pluginOpen 只是简单包装了一下标准库中的 dlopen 和 dlerror 函数并在加载成功后返回指向动态库的句柄：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> <span class="title">pluginOpen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>** err)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span>* h = dlopen(path, RTLD_NOW|RTLD_GLOBAL);</span><br><span class="line"><span class="keyword">if</span> (h == <span class="literal">NULL</span>) &#123;</span><br><span class="line">*err = (<span class="keyword">char</span>*)dlerror();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)h;</span><br><span class="line">&#125;</span><br><span class="line">C</span><br><span class="line">plugin.pluginLookup 使用了标准库中的 dlsym 和 dlerror 获取动态库句柄中的特定符号：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">pluginLookup</span><span class="params">(<span class="keyword">uintptr_t</span> h, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">char</span>** err)</span> </span>&#123;</span><br><span class="line"><span class="keyword">void</span>* r = dlsym((<span class="keyword">void</span>*)h, name);</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">NULL</span>) &#123;</span><br><span class="line">*err = (<span class="keyword">char</span>*)dlerror();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数的实现原理都比较简单，它们的作用也只是简单封装标准库中的 C 语言函数，让它们的签名看起来更像是 Go 语言中的函数签名，方便在 Go 语言中调用。</p><h3 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h3><p>用于加载共享对象的函数 plugin.Open 会将共享对象文件的路径作为参数并返回 plugin.Plugin 结构：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(*Plugin, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> open(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数会调用私有的函数 plugin.open 加载插件，它是插件加载过程的核心函数，我们可以将该函数拆分成以下几个步骤：</p><ul><li>准备 C 语言函数 plugin.pluginOpen 的参数；</li><li>通过 cgo 调用 plugin.pluginOpen 并初始化加载的模块；</li><li>查找加载模块中的 init 函数并调用该函数；</li><li>通过插件的文件名和符号列表构建 plugin.Plugin 结构；<br>首先是使用 cgo 提供的一些结构准备调用 plugin.pluginOpen 所需要的参数，下面的代码会将文件名转换成 *C.char 类型的变量，该类型的变量可以作为参数传入 C 函数：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Plugin, error)</span></span> &#123;</span><br><span class="line">cPath := <span class="built_in">make</span>([]<span class="keyword">byte</span>, C.PATH_MAX+<span class="number">1</span>)</span><br><span class="line">cRelName := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(name)+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">copy</span>(cRelName, name)</span><br><span class="line"><span class="keyword">if</span> C.realpath(</span><br><span class="line">(*C.char)(unsafe.Pointer(&amp;cRelName[<span class="number">0</span>])),</span><br><span class="line">(*C.char)(unsafe.Pointer(&amp;cPath[<span class="number">0</span>]))) == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">`plugin.Open(&quot;`</span> + name + <span class="string">`&quot;): realpath failed`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filepath := C.GoString((*C.char)(unsafe.Pointer(&amp;cPath[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> cErr *C.char</span><br><span class="line">h := C.pluginOpen((*C.char)(unsafe.Pointer(&amp;cPath[<span class="number">0</span>])), &amp;cErr)</span><br><span class="line"><span class="keyword">if</span> h == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">`plugin.Open(&quot;`</span> + name + <span class="string">`&quot;): `</span> + C.GoString(cErr))</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当我们拿到了指向动态库的句柄之后会调用 plugin.lastmoduleinit，链接器会将它会链接到运行时的 runtime.plugin_lastmoduleinit 函数上，它会解析文件中的符号并返回共享文件的目录和其中包含的全部符号：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Plugin, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">pluginpath, syms, errstr := lastmoduleinit()</span><br><span class="line"><span class="keyword">if</span> errstr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">plugins[filepath] = &amp;Plugin&#123;</span><br><span class="line">pluginpath: pluginpath,</span><br><span class="line">err:        errstr,</span><br><span class="line">&#125;</span><br><span class="line">pluginsMu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">`plugin.Open(&quot;`</span> + name + <span class="string">`&quot;): `</span> + errstr)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在该函数的最后，我们会构建一个新的 plugin.Plugin 结构体并遍历 plugin.lastmoduleinit 返回的全部符号，为每一个符号调用 plugin.pluginLookup：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Plugin, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">p := &amp;Plugin&#123;</span><br><span class="line">pluginpath: pluginpath,</span><br><span class="line">&#125;</span><br><span class="line">plugins[filepath] = p</span><br><span class="line">...</span><br><span class="line">updatedSyms := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> symName, sym := <span class="keyword">range</span> syms &#123;</span><br><span class="line">isFunc := symName[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span></span><br><span class="line"><span class="keyword">if</span> isFunc &#123;</span><br><span class="line"><span class="built_in">delete</span>(syms, symName)</span><br><span class="line">symName = symName[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fullName := pluginpath + <span class="string">&quot;.&quot;</span> + symName</span><br><span class="line">cname := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(fullName)+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">copy</span>(cname, fullName)</span><br><span class="line"></span><br><span class="line">p := C.pluginLookup(h, (*C.char)(unsafe.Pointer(&amp;cname[<span class="number">0</span>])), &amp;cErr)</span><br><span class="line">valp := (*[<span class="number">2</span>]unsafe.Pointer)(unsafe.Pointer(&amp;sym))</span><br><span class="line"><span class="keyword">if</span> isFunc &#123;</span><br><span class="line">(*valp)[<span class="number">1</span>] = unsafe.Pointer(&amp;p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">(*valp)[<span class="number">1</span>] = p</span><br><span class="line">&#125;</span><br><span class="line">updatedSyms[symName] = sym</span><br><span class="line">&#125;</span><br><span class="line">p.syms = updatedSyms</span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上述函数在最后会返回一个包含符号名到函数或者变量映射的 plugin.Plugin 结构体，调用方可以将该结构体作为句柄查找其中的符号，需要注意的是，我们在这段代码中省略了查找 init 并初始化插件的过程。</li></ul><h3 id="符号查找"><a href="#符号查找" class="headerlink" title="符号查找"></a>符号查找</h3><p>plugin.Plugin.Lookup 可以在 plugin.Open 返回的结构体中查找符号 plugin.Symbol，该符号是 interface{} 类型的一个别名，我们可以将它转换成变量或者函数真实的类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Plugin)</span> <span class="title">Lookup</span><span class="params">(symName <span class="keyword">string</span>)</span> <span class="params">(Symbol, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> lookup(p, symName)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lookup</span><span class="params">(p *Plugin, symName <span class="keyword">string</span>)</span> <span class="params">(Symbol, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s := p.syms[symName]; s != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;plugin: symbol &quot;</span> + symName + <span class="string">&quot; not found in plugin &quot;</span> + p.pluginpath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法调用的私有函数 plugin.lookup 实现比较简单，它直接利用了结构体中的符号表，如果没有找到对应的符号会直接返回错误。</p><h2 id="8-1-3-小结"><a href="#8-1-3-小结" class="headerlink" title="8.1.3 小结"></a>8.1.3 小结</h2><p>Go 语言的插件系统利用了操作系统的动态库实现模块化的设计，它提供功能虽然比较有趣，但是在实际使用中会遇到比较多的限制，目前的插件系统也仅支持 Linux、Darwin 和 FreeBSD，在 Windows 上是没有办法使用的。因为插件系统的实现基于一些黑魔法，所以跨平台的编译也会遇到一些比较奇葩的问题，作者在使用插件系统时也踩过很多坑，如果对 Go 语言不是特别了解，还是不建议使用该模块的。</p><h2 id="8-1-4-推荐阅读"><a href="#8-1-4-推荐阅读" class="headerlink" title="8.1.4 推荐阅读"></a>8.1.4 推荐阅读</h2><p>Static Libraries vs. Dynamic Libraries <a href="https://medium.com/@StueyGK/static-libraries-vs-dynamic-libraries-af78f0b5f1e4">https://medium.com/@StueyGK/static-libraries-vs-dynamic-libraries-af78f0b5f1e4</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang Mutex源码分析</title>
      <link href="posts/e65f8f8e.html"/>
      <url>posts/e65f8f8e.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-Mutex源码分析"><a href="#Golang-Mutex源码分析" class="headerlink" title="Golang Mutex源码分析"></a>Golang Mutex源码分析</h1><p>Golang 中的Mutex 主要借助了 CAS 指令 + 自旋 + 信号量</p><h2 id="CAS-指令"><a href="#CAS-指令" class="headerlink" title="CAS 指令"></a>CAS 指令</h2><p>比较并交换(compare and swap, CAS)，是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作，从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。 该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。</p><h3 id="CAS-缺点"><a href="#CAS-缺点" class="headerlink" title="CAS 缺点"></a>CAS 缺点</h3><ol><li><p>CAS在共享资源竞争比较激烈的时候，每个goroutine会容易处于自旋状态，影响效率，在竞争激烈的时候推荐使用锁。</p></li><li><p>无法解决ABA问题</p><p><strong>ABA问题</strong></p><p><em><strong>进程P1读取了一个数值A<br>P1被挂起(时间片耗尽、中断等)，进程P2开始执行<br>P2修改数值A为数值B，然后又修改回A<br>P1被唤醒，比较后发现数值A没有变化，程序继续执行。</strong></em></p></li></ol><h2 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h2><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量的概念是计算机科学家 Dijkstra （Dijkstra算法的发明者）提出来的，广泛应用在不同的操作系统中。系统中，会给每一个进程一个信号量，代表每个进程当前的状态，未得到控制权的进程，会在特定的地方被迫停下来，等待可以继续进行的信号到来。<br>如果信号量是一个任意的整数，通常被称为计数信号量（Counting semaphore），或一般信号量（general semaphore）；如果信号量只有二进制的0或1，称为二进制信号量（binary semaphore）。在linux系统中，二进制信号量（binary semaphore）又称互斥锁（Mutex）<br>计数信号量具备两种操作动作，称为V（ signal()）与P（ wait()）（即部分参考书常称的“PV操作”）。V操作会增加信号量S的数值，P操作会减少它。<br>运行方式：</p><ol><li>初始化信号量，给与它一个非负数的整数值。</li><li>运行P（wait()），信号量S的值将被减少。企图进入临界区的进程，需要先运行P（wait()）。当信号量S减为负值时，进程会被阻塞住，不能继续；当信号量S不为负值时，进程可以获准进入临界区。</li><li>运行V（signal()），信号量S的值会被增加。结束离开临界区段的进程，将会运行V（signal()）。当信号量S不为负值时，先前被阻塞住的其他进程，将可获准进入临界区。</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>Go 语言中<code>Mutex</code>结构体共由两个字段组成</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">  state <span class="keyword">int32</span></span><br><span class="line">  sema  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>如下图所示，<code>Mutex.State</code> 由 <code>waiterNum</code> 、<code>straving</code>、<code>woken</code>、<code>locked</code>组成。</p><ul><li><p><em><strong>waiterNum</strong></em> 表示目前互斥锁等待队列中有多少goroutine在等待</p></li><li><p><em><strong>straving</strong></em> 表示目前互斥锁是否处于饥饿状态</p></li><li><p><em><strong>woken</strong></em> 表示目前互斥锁是否为唤醒状态</p></li><li><p><em><strong>locked</strong></em> 表示目前互斥锁资源是否被goroutine持有</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/go-mutex-state.png" alt="go-mutex-state"></p><h4 id="sema"><a href="#sema" class="headerlink" title="sema"></a>sema</h4><p>用于等待队列。</p><h3 id="Lock-流程分析"><a href="#Lock-流程分析" class="headerlink" title="Lock 流程分析"></a>Lock 流程分析</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/go-lock.png" alt="image-20210329210758755"></p><p><strong>Lock</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock locks m.</span></span><br><span class="line"><span class="comment">// If the lock is already in use, the calling goroutine</span></span><br><span class="line"><span class="comment">// blocks until the mutex is available.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   通过CAS获取锁资源，获取不到则初始化当前goroutine所需要的变量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用<em><strong>CAS方法</strong></em>（<strong>CompareAndSwap</strong>）去判断是否可以直接获取锁，如果可以获取锁资源，则修改<code>Mutex.state</code>中的<code>locked</code>状态位并成功获取锁，如果获取不到，则执行lockSlow()方法。</p><p><strong>lockSlow</strong></p><p>初始化当前goroutine需要的变量，执行for循环尝试获取锁资源</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">lockSlow</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="keyword">int64</span></span><br><span class="line">starving := <span class="literal">false</span></span><br><span class="line">awoke := <span class="literal">false</span></span><br><span class="line">iter := <span class="number">0</span></span><br><span class="line">old := m.state</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//一、尝试通过自旋方式获取锁资源</span></span><br><span class="line"><span class="comment">// Don&#x27;t spin in starvation mode, ownership is handed off to waiters</span></span><br><span class="line"><span class="comment">// so we won&#x27;t be able to acquire the mutex anyway.</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line"><span class="comment">// Active spinning makes sense.</span></span><br><span class="line"><span class="comment">// Try to set mutexWoken flag to inform Unlock</span></span><br><span class="line"><span class="comment">// to not wake other blocked goroutines.</span></span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//二、更新互斥锁状态</span></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="comment">// Don&#x27;t try to acquire starving mutex, new arriving goroutines must queue.</span></span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 如果不是饥饿状态，则尝试更新锁的状态到new上</span></span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 如果锁处于饥饿状态或被其他goroutine持有</span></span><br><span class="line">      <span class="comment">// 等待队列+1</span></span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The current goroutine switches mutex to starvation mode.</span></span><br><span class="line"><span class="comment">// But if the mutex is currently unlocked, don&#x27;t do the switch.</span></span><br><span class="line"><span class="comment">// Unlock expects that starving mutex has waiters, which will not</span></span><br><span class="line"><span class="comment">// be true in this case.</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">// 如果当前锁为饥饿状态，并且锁资源被其他goroutine持有</span></span><br><span class="line">      <span class="comment">// 更新当前锁状态副本的饥饿状态的值</span></span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="comment">// The goroutine has been woken from sleep,</span></span><br><span class="line"><span class="comment">// so we need to reset the flag in either case.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过CAS设置new的值</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">       <span class="comment">//当锁没有处在饥饿状态下，可以视作成功获取了锁</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If we were already waiting before, queue at the front of the queue.</span></span><br><span class="line">      <span class="comment">// 判断是否处于等待状态</span></span><br><span class="line">queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">       <span class="comment">// 获取等待开始的时间</span></span><br><span class="line"><span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// runtime_nanotime 实际上是一个系统调用，获取当前时间</span></span><br><span class="line">waitStartTime = runtime_nanotime()</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          如果我们没有通过 CAS 获得锁，</span></span><br><span class="line"><span class="comment">          会调用 sync.runtime_SemacquireMutex </span></span><br><span class="line"><span class="comment">          使用信号量保证资源不会被两个 Goroutine 获取。</span></span><br><span class="line"><span class="comment">          sync.runtime_SemacquireMutex </span></span><br><span class="line"><span class="comment">          会在方法中不断调用尝试获取锁并休眠当前 Goroutine 等待信号量的释放，</span></span><br><span class="line"><span class="comment">          一旦当前 Goroutine 可以获取信号量，它就会立刻返回，</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">       <span class="comment">// 当等待时间超过1ms时候，变为饥饿状态</span></span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// If this goroutine was woken and mutex is in starvation mode,</span></span><br><span class="line"><span class="comment">// ownership was handed off to us but mutex is in somewhat</span></span><br><span class="line"><span class="comment">// inconsistent state: mutexLocked is not set and we are still</span></span><br><span class="line"><span class="comment">// accounted as waiter. Fix that.</span></span><br><span class="line">        <span class="comment">// 如果为饥饿状态的话</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// delta的实际值为等待的位数</span></span><br><span class="line">delta := <span class="keyword">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Exit starvation mode.</span></span><br><span class="line"><span class="comment">// Critical to do it here and consider wait time.</span></span><br><span class="line"><span class="comment">// Starvation mode is so inefficient, that two goroutines</span></span><br><span class="line"><span class="comment">// can go lock-step infinitely once they switch mutex</span></span><br><span class="line"><span class="comment">// to starvation mode.</span></span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 对m.state中的等待计进行ADD的原子操作</span></span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 唤醒次数为true, 自旋次数重置</span></span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果CAS不成功，则获取新的state状态</span></span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>一、尝试通过自旋的方式获取锁</strong></p><p>尝试通过自旋方式获取锁资源，自旋可以避免goroutine切换，但是消耗的资源更多，当goroutine进行自旋的时候，实际上是调用 <strong>sync_runtime_doSpin</strong>方法，该方法会在CPU上执行若干次PAUSE指令，也就是什么都不做，sleep一小会儿，但是会占用CPU资源。所以goroutine进入自旋的条件非常苛刻，通常需要满足以下两个条件：</p><ol><li><p>互斥锁只有在普通模式才能进行自旋</p></li><li><p>**sync_runtime_canSpin(iter)**返回true</p><ul><li><p>自旋次数（iter）小于4</p></li><li><p>ncpu &gt; 1 也就是CPU核数大于1</p></li><li><p>当前机器上有一个运行的P队列，且GOMAXPROS（可以用的处理器）大于1</p></li></ul></li></ol><p><strong>二、更新互斥锁状态</strong></p><p>主要是更新互斥锁的相关状态，详细流程可见上图蓝框部分。</p><p><strong>三、更新互斥锁状态后</strong></p><ol><li><p>首先尝试使用CAS设置目前new的值。</p></li><li><p>如果没有成功设置则代表有新的goroutine更新了当前的锁资源，我们需要更新当前锁状态，重新进行for循环尝试获取锁。</p></li><li><p>如果当前锁不处于饥饿状态以及没有被别的goroutine获取，则视为拿到锁资源。</p></li><li><p>判断等待实际以及更新等待时间，调用<strong>runtime_SemaacquireMute</strong>x使用信号量使资源不会被两个goroutine同时获取，而当有别的goroutine释放了锁资源，则第一时间会将信号量返回给该goroutine，立即获得锁资源。</p></li><li><p>当等待时间超过1ms得时候，更新饥饿状态。</p></li><li><p>如果锁处于饥饿状态，且当前goroutine不属于饥饿状态，或锁位未处于饥饿状态，则退出饥饿模式</p></li><li><p>如果锁不处于饥饿状态，唤醒该goroutine然后将自旋次数重置。</p></li></ol><p>整个加锁过程结束。</p><h3 id="UnLock流程分析"><a href="#UnLock流程分析" class="headerlink" title="UnLock流程分析"></a>UnLock流程分析</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/go-unlock.png" alt="image-20210329210906862"></p><p>根据上图，分析一下<code>Unlock</code>逻辑,</p><ol><li><p>首先判断锁的状态，如果锁处于非饥饿且非唤醒状态，则释放锁资源，否则执行unlockSlow()</p></li><li><p>unlockSlow 逻辑</p><ol><li><p>如果直接解锁一个没有被锁定的锁，抛出异常</p></li><li><p>判断锁是否为饥饿状态</p><ul><li>如果锁不为饥饿状态，且锁不为（锁住、唤醒、饥饿）状态的任一，直接解锁</li><li>如果为上面三种情况的一种，需要唤醒在等待队列中的goroutine</li><li>如果锁处于饥饿状态，直接唤醒等待队列中的goroutine.</li></ul></li></ol></li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock unlocks m.</span></span><br><span class="line"><span class="comment">// It is a run-time error if m is not locked on entry to Unlock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A locked Mutex is not associated with a particular goroutine.</span></span><br><span class="line"><span class="comment">// It is allowed for one goroutine to lock a Mutex and then</span></span><br><span class="line"><span class="comment">// arrange for another goroutine to unlock it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">_ = m.state</span><br><span class="line">race.Release(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line"><span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">unlockSlow</span><span class="params">(<span class="built_in">new</span> <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">//如果直接解锁一个没有被锁定的锁，抛出异常</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//判断锁是否为饥饿状态</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// If there are no waiters or a goroutine has already</span></span><br><span class="line"><span class="comment">// been woken or grabbed the lock, no need to wake anyone.</span></span><br><span class="line"><span class="comment">// In starvation mode ownership is directly handed off from unlocking</span></span><br><span class="line"><span class="comment">// goroutine to the next waiter. We are not part of this chain,</span></span><br><span class="line"><span class="comment">// since we did not observe mutexStarving when we unlocked the mutex above.</span></span><br><span class="line"><span class="comment">// So get off the way.</span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//如果锁不为饥饿状态，且锁不为（锁住、唤醒、饥饿）状态的任一，直接解锁</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Grab the right to wake someone.</span></span><br><span class="line">      <span class="comment">//如果为锁住、唤醒、饥饿三种情况的一种，需要唤醒在等待队列中的goroutine</span></span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Starving mode: handoff mutex ownership to the next waiter, and yield</span></span><br><span class="line"><span class="comment">// our time slice so that the next waiter can start to run immediately.</span></span><br><span class="line"><span class="comment">// Note: mutexLocked is not set, the waiter will set it after wakeup.</span></span><br><span class="line"><span class="comment">// But mutex is still considered locked if mutexStarving is set,</span></span><br><span class="line"><span class="comment">// so new coming goroutines won&#x27;t acquire it.</span></span><br><span class="line">    <span class="comment">//如果锁处于饥饿状态，直接唤醒等待队列中的goroutine.</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mutex-使用注意"><a href="#Mutex-使用注意" class="headerlink" title="Mutex 使用注意"></a>Mutex 使用注意</h2><p><strong>Lock/UnLock 成对使用</strong></p><p><strong>Mutex 千万不能被复制</strong></p><p>我们使用 Mutex 是为了不同 goroutine 之间共享某个变量, 所以需要让这个变量做到能够互斥, 不然该变量就会被互相被覆盖. Mutex 底层是由 <code>state</code> <code>sema</code> 控制的, 当 Mutex 变量被复制时, Mutex 的 state, sema 当时的状态也被复制走了, 但是由于不同 goroutine 之间的 Mutex 已经不是同一个变量了, 这样就会造成要么某个 goroutine 死锁或者不同 goroutine 共享的变量达不到互斥</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"> mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reduce</span><span class="params">(p1 Person)</span></span> &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;step...&quot;</span>, )</span><br><span class="line"> p1.mux.Lock()</span><br><span class="line"> fmt.Println(p1)</span><br><span class="line"> <span class="keyword">defer</span> p1.mux.Unlock()</span><br><span class="line"> fmt.Println(<span class="string">&quot;over...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> p Person</span><br><span class="line"> p.mux.Lock()</span><br><span class="line"> <span class="keyword">go</span> Reduce(p)</span><br><span class="line"> p.mux.Unlock()</span><br><span class="line"> fmt.Println(<span class="number">111</span>)</span><br><span class="line"> <span class="keyword">for</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题分析：</p><ol><li>main Goroutine 已经给 p.mux 加了锁 , 这个时候 p.mux  的 state 的值是 mutexLocked。</li><li>然后将 p.mux 复制给了 Reduce Goroutine。这个时候被复制的 p1.mux 的 state 的值也是 mutexLocked。</li><li>main Goroutine 虽然已经解锁了, 但是 Reduce Goroutine 跟 main Goroutine 的 mutex 已经不是同一个 mutex 了, 所以 Reduce Goroutine 就会加锁失败, 产生死锁，关键是编译器还发现不了这个 Deadlock。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang sync 包分析</title>
      <link href="posts/8d0aa32e.html"/>
      <url>posts/8d0aa32e.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-Golang-sync-包的相关使用方法"><a href="#第一章-Golang-sync-包的相关使用方法" class="headerlink" title="第一章 Golang sync 包的相关使用方法"></a>第一章 Golang sync 包的相关使用方法</h2><h3 id="一、锁的基本概念及使用"><a href="#一、锁的基本概念及使用" class="headerlink" title="一、锁的基本概念及使用"></a>一、锁的基本概念及使用</h3><p>整个包都是实现Locker接口</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span>&#123;</span><br><span class="line">  Lock()</span><br><span class="line">  UnLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口只有两个方法，<code>Lock()</code> 和<code>UnLock()</code> 。注意：<code>该包下的对象时候过后不可进行复制</code> </p><h4 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h4><p>首先，我们都知道在<strong>并发</strong> 的情况下，多线程或者协程同时修改一个变量的时候时，可能会出现如下情况:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 100 个协程，需要足够大</span></span><br><span class="line">    <span class="comment">// var lock sync.Mutex</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// lock.Lock()</span></span><br><span class="line">            <span class="comment">// defer lock.Unlock()</span></span><br><span class="line">            a += <span class="number">1</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine %d, a=%d\n&quot;</span>, idx, a)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 1s 结束主程序</span></span><br><span class="line">    <span class="comment">// 确保所有协程执行完</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据如上的代码运行，是否会出现打印出来的a值有相同的情况？答案是肯定的，会出现a值相同的情况。</p><p>其实原因很简单，a是全局变量。多协程同时进行操作时，会出现类似于<code>脏读</code>的场景。所以<code>锁</code>的概念其实就是，我正在操作a（加锁），其他人谁都不要和我抢，我处理完了（解锁），其他人在进行相关处理。这样其实就是保证了，同时操作a的协程只有一个，这样就实现了同步。</p><div class="note success simple"><p>可以将上面的注释取消，体会一下锁的使用</p></div><h4 id="什么是互斥锁？"><a href="#什么是互斥锁？" class="headerlink" title="什么是互斥锁？"></a>什么是互斥锁？</h4><p>什么是互斥锁？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">共享资源的使用是互斥的，即一个线程获得资源的使用权后就会将该资源加锁，使用完后会将其解锁，如果在使用过程中有其他线程想要获取该资源的锁，那么它就会被阻塞陷入睡眠状态，直到该资源被解锁才会被唤醒，如果被阻塞的资源不止一个，那么它们都会被唤醒，但是获得资源使用权的是第一个被唤醒的线程，其它线程又陷入沉睡.</span><br></pre></td></tr></table></figure><p>互斥锁是锁的一种具体实现，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span><span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span><span class="title">UnLock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>注意：<strong>在首次使用后不要复制该锁，对于一个未锁定的互斥锁进行解锁会抛出运行时错误</strong> 。一个互斥锁只能同时被一个goroutine锁定，其他goroutine</p><p>会被阻塞，直到该锁被释放。如下，</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> l sync.Mutex</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        l.Lock()</span><br><span class="line">        <span class="keyword">defer</span> l.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine1: 我会锁定大概 2s&quot;</span>)</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine1: 我解锁了，你们去抢吧&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;groutine2: 等待解锁&quot;</span>)</span><br><span class="line">        l.Lock()</span><br><span class="line">        <span class="keyword">defer</span> l.Unlock()</span><br><span class="line">        fmt.Println(<span class="string">&quot;goroutine2: 哈哈，我锁定了&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待 goroutine 执行结束</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success simple"><p>注意，平时所说的锁定，其实就是去锁定互斥锁，而不是说去锁定一段代码。也就是说，当代码执行到有锁的地方时，它获取不到互斥锁的锁定，会阻塞在那里，从而达到控制同步的目的。</p></div><h4 id="什么是读写锁-RWMutex？"><a href="#什么是读写锁-RWMutex？" class="headerlink" title="什么是读写锁 RWMutex？"></a>什么是读写锁 RWMutex？</h4><p>在互斥锁中, 只有两个状态: 加锁和未加锁, 而在一些情况下对于<code>读</code>可以并发的进行而不用加锁, 对于读则需要加锁, 比如golang中map的操作。</p><p>为了让<code>读</code>操作更快的进行(不必加锁), 就诞生了<code>读写锁</code>的概念, 它有三个状态: 读模式下加锁状态, 写模式加锁状态和未加锁状态。</p><p>规则如下</p><ul><li>如果有其它协程读数据, 则允许其它协程执行读操作, 但不允许写操作</li><li>如果有其它协程写数据, 则其它协程都不允许读和写操作</li></ul><p>由于这个特性, 读写锁能在读频率更高的情况下有更好的并发性能。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>由于这里需要区分读写锁定，：</p><ul><li>读锁定（RLock），对读操作进行锁定</li><li>读解锁（RUnlock），对读锁定进行解锁 </li><li>写锁定（Lock），对写操作进行锁定</li><li>写解锁（Unlock），对写锁定进行解锁</li></ul><p>注意：<strong>在首次使用之后，不要复制该读写锁。不要混用锁定和解锁，如：Lock 和 RUnlock、RLock 和 Unlock。因为对未读锁定的读写锁进行读解锁或对未写锁定的读写锁进行写解锁将会引起运行时错误。</strong> </p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> rw sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> read(i, ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> write(i, ch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(n <span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    rw.RLock()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 进入读操作...\n&quot;</span>, n)</span><br><span class="line">    v := count</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 读取结束，值为：%d\n&quot;</span>, n, v)</span><br><span class="line">    rw.RUnlock()</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(n <span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    rw.Lock()</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 进入写操作...\n&quot;</span>, n)</span><br><span class="line">    v := rand.Intn(<span class="number">1000</span>)</span><br><span class="line">    count = v</span><br><span class="line">    fmt.Printf(<span class="string">&quot;goroutine %d 写入结束，新值为：%d\n&quot;</span>, n, v)</span><br><span class="line">    rw.Unlock()</span><br><span class="line">    ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WaitGroup-使用"><a href="#WaitGroup-使用" class="headerlink" title="WaitGroup 使用"></a>WaitGroup 使用</h4><p>WaitGroup用于等待一组goroutine结束。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>Add用来添加goroutine的数量，Done()代表一个协程处理完成，等待数量减一。Wait 用来等待结束，也即未完成goroutine数量为0。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 计数加 1</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 计数减 1</span></span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            time.Sleep(time.Second * time.Duration(i))</span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine%d 结束\n&quot;</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待执行结束</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;所有 goroutine 执行结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>wg.Add()</code>一定要在goroutine初始化前使用。</p><h4 id="Cond-条件变量"><a href="#Cond-条件变量" class="headerlink" title="Cond 条件变量"></a>Cond 条件变量</h4><p>Cond 实现一个条件变量，即等待或宣布事件发生的 goroutines 的会合点，它会保存一个通知列表。基本思想是当某中状态达成，goroutine 将会等待（Wait）在那里，当某个时刻状态改变时通过通知的方式（Broadcast，Signal）的方式通知等待的 goroutine。这样，不满足条件的 goroutine 唤醒继续向下执行，满足条件的重新进入等待序列。</p><p>结构如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// L is held while observing or changing the condition</span></span><br><span class="line">    L Locker</span><br><span class="line">  </span><br><span class="line">    notify  notifyList <span class="comment">// 通知列表</span></span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span> *<span class="title">Cond</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用该函数时，可以加锁也可以不加锁，原因为该函数没有修改操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Broadcast</span><span class="params">()</span>//广播通知，用来唤醒所有的处于等待<span class="title">c</span>状态的协程，如果没有等待的协程，该函数也不会报错。</span></span><br><span class="line"><span class="comment">//使用该函数时，可以加锁也可以不加锁，原因为该函数没有修改操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Signal</span><span class="params">()</span>//单点通知，通知单个等待<span class="title">c</span>状态的协程，让它继续执行，如果此时有多个协程处于等待状态，会从等待列表中取出最开始等待的那个协程，来接收消息。</span></span><br><span class="line"><span class="comment">//使用该函数时，必须加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span> //等待通知，该函数在被调用之后，在没有收到<span class="title">Signal</span>或者<span class="title">Broadcast</span>的通知之前，协程处于阻塞状态。</span></span><br></pre></td></tr></table></figure><h5 id="Wait-方法"><a href="#Wait-方法" class="headerlink" title="Wait 方法"></a>Wait 方法</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span> <span class="title">Wait</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)<span class="comment">//加入通知列表</span></span><br><span class="line">    c.L.Unlock()<span class="comment">//解锁 Locker</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)<span class="comment">//等待通知</span></span><br><span class="line">    c.L.Lock()<span class="comment">//对Locker加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本使用方法为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line"><span class="keyword">for</span> !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">... <span class="built_in">make</span> use of condition ...</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package main provides ...</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建 cond</span></span><br><span class="line">    <span class="keyword">var</span> l sync.Mutex</span><br><span class="line">    cond := sync.NewCond(&amp;l)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 争抢互斥锁的锁定</span></span><br><span class="line">            cond.L.Lock()</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                cond.L.Unlock()</span><br><span class="line">                ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">            &#125;()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 条件是否达成</span></span><br><span class="line">            <span class="keyword">for</span> count &gt; i &#123;</span><br><span class="line">                cond.Wait()</span><br><span class="line">                fmt.Printf(<span class="string">&quot;收到一个通知 goroutine%d\n&quot;</span>, i)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            fmt.Printf(<span class="string">&quot;goroutine%d 执行结束\n&quot;</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保所有 goroutine 启动完成</span></span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 锁定一下</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;broadcast...&quot;</span>)</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;signal...&quot;</span>)</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    count -= <span class="number">2</span></span><br><span class="line">    cond.Signal()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;broadcast...&quot;</span>)</span><br><span class="line">    cond.L.Lock()</span><br><span class="line">    count -= <span class="number">1</span></span><br><span class="line">    cond.Broadcast()</span><br><span class="line">    cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pool-临时对象池"><a href="#Pool-临时对象池" class="headerlink" title="Pool 临时对象池"></a>Pool 临时对象池</h4><p><code>sync.Pool</code> 可以作为临时对象保存和复用的集合。其结构为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line"></span><br><span class="line">    local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal</span></span><br><span class="line">    localSize <span class="keyword">uintptr</span>        <span class="comment">// size of the local array</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// New optionally specifies a function to generate</span></span><br><span class="line">    <span class="comment">// a value when Get would otherwise return nil.</span></span><br><span class="line">    <span class="comment">// It may not be changed concurrently with calls to Get.</span></span><br><span class="line">    New <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Put</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br></pre></td></tr></table></figure><p>新键 Pool 需要提供一个 New 方法，目的是当获取不到临时对象时自动创建一个（不会主动加入到 Pool 中），Get 和 Put 方法都很好理解。深入了解过 Go 的同学应该知道，Go 的重要组成结构为 M、P、G（可以通过<a href="https://shimengfei.github.io/posts/19049.html">GMP模型分析</a>了解）。Pool 实际上会为每一个操作它的 goroutine 相关联的 P 都生成一个本地池。如果从本地池 Get 对象的时候，本地池没有，则会从其它的 P 本地池获取。因此，Pool 的一个特点就是：可以把由其中的对象值产生的存储压力进行分摊。</p><p>它有着以下特点：</p><ul><li>Pool 中的对象在仅有 Pool 有着唯一索引的情况下可能会被自动删除（取决于下一次 GC 执行的时间）。</li><li>goroutines 协程安全，可以同时被多个协程使用。</li></ul><div class="note success simple"><p>GC 的执行一般会使 Pool 中的对象全部移除。</p></div><p>适用与无状态的对象的复用，而不适用与如连接池之类的。官方例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bufPool = sync.Pool&#123;</span><br><span class="line">    New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeNow</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> time.Unix(<span class="number">1136214245</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Log</span><span class="params">(w io.Writer, key, val <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取临时对象，没有的话会自动创建</span></span><br><span class="line">    b := bufPool.Get().(*bytes.Buffer)</span><br><span class="line">    b.Reset()</span><br><span class="line">    b.WriteString(timeNow().UTC().Format(time.RFC3339))</span><br><span class="line">    b.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    b.WriteString(key)</span><br><span class="line">    b.WriteByte(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    b.WriteString(val)</span><br><span class="line">    w.Write(b.Bytes())</span><br><span class="line">    <span class="comment">// 将临时对象放回到 Pool 中</span></span><br><span class="line">    bufPool.Put(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Log(os.Stdout, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;/search?q=flowers&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="number">2006</span><span class="number">-01</span><span class="number">-02</span>T15:<span class="number">04</span>:<span class="number">05</span>Z path=/search?q=flowers</span><br></pre></td></tr></table></figure><h4 id="Once-仅执行一次"><a href="#Once-仅执行一次" class="headerlink" title="Once 仅执行一次"></a>Once 仅执行一次</h4><p><code>sync.Once</code> 保证函数多次调用，只被执行一次。其结构为：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Once <span class="keyword">struct</span> &#123;</span><br><span class="line">    m    Mutex</span><br><span class="line">    done <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *Once)</span> <span class="title">Do</span><span class="params">(f <span class="keyword">func</span>()</span>)</span></span><br></pre></td></tr></table></figure><p>用 done 来记录执行次数，用 m 来保证保证仅被执行一次。只有一个 Do 方法，调用执行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> once sync.Once</span><br><span class="line">    onceBody := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Only once&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            once.Do(onceBody)</span><br><span class="line">            done &lt;- <span class="literal">true</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        &lt;-done</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 打印结果</span><br><span class="line">Only once</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本小结仅介绍了<code>sync</code>包下的方法的基本使用，下一节将进行相关源码分析。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语言GMP模型分析</title>
      <link href="posts/19049.html"/>
      <url>posts/19049.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-调度器GMP原理分析"><a href="#Golang-调度器GMP原理分析" class="headerlink" title="Golang 调度器GMP原理分析"></a>Golang 调度器GMP原理分析</h1><h2 id="Golang调度器来源"><a href="#Golang调度器来源" class="headerlink" title="Golang调度器来源"></a>Golang调度器来源</h2><h3 id="单进程时代不需要调度器"><a href="#单进程时代不需要调度器" class="headerlink" title="单进程时代不需要调度器"></a>单进程时代不需要调度器</h3><p>我们都知道，一切的软件都是跑在操作系统上。然而真正干活的其实是CPU。早期的操作系统每个程序就是一个进程，直到一个程序结束，才能进行下一个进程。这就是“单进程时代”。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/06IoYRyruP.png" alt="img"></p><p>早期的单进程操作系统，面临 2 个问题：</p><ol><li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p></li><li><p>进程阻塞所带来的 CPU 时间浪费。</p></li></ol><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：**多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程 **，这样就能尽量把 CPU 利用起来，CPU 就不浪费了。</p><h3 id="多进程-线程时代有了调度器的需求"><a href="#多进程-线程时代有了调度器的需求" class="headerlink" title="多进程/线程时代有了调度器的需求"></a>多进程/线程时代有了调度器的需求</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/sLve6TagD3.png" alt="img"></p><p>在多进程 / 多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞 cpu 可以立刻切换到其他进程中去执行，而且调度 cpu 的算法可以保证在运行的进程都可以被分配到 cpu 的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU 虽然利用起来了，但如果进程过多，CPU 有很大的一部分都被用来进行进程调度了。</p><h4 id="怎么才能提高-CPU-的利用率呢？"><a href="#怎么才能提高-CPU-的利用率呢？" class="headerlink" title="怎么才能提高 CPU 的利用率呢？"></a><strong>怎么才能提高 CPU 的利用率呢？</strong></h4><p>对于Linux系统来说，CPU对待进程和线程的态度是一样的。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/dNWd00AiEZ.png" alt="img"></p><p>很明显，CPU 调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p><h3 id="协程提高CPU利用率"><a href="#协程提高CPU利用率" class="headerlink" title="协程提高CPU利用率"></a>协程提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存 (进程虚拟内存会占用 4GB [32 位操作系统], 而线程也要大约 4MB)。</p><p>大量的进程 / 线程出现了新的问题</p><ul><li>高内存占用</li><li>调度的高消耗 CPU</li></ul><p>工程师们发现，其实一个线程分为 “内核态 “线程和” 用户态 “线程。</p><p>一个 “用户态线程” 必须要绑定一个 “内核态线程”，但是 CPU 并不知道有 “用户态线程” 的存在，它只知道它运行的是一个 “内核态线程”(Linux 的 PCB 进程控制块)。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/TfStmYsfyF.png" alt="img"></p><p>这样，我们再去细化去分类一下，内核线程依然叫 “线程 (thread)”，用户线程叫 “协程 (co-routine)”。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/vgzlKzvOUL.png" alt="img"></p><p> 看到这里，我们就要开脑洞了，既然一个协程 (co-routine) 可以绑定一个线程 (thread)，那么能不能多个协程 (co-routine) 绑定一个或者多个线程 (thread) 上呢？</p><p> 之后，我们就看到了有 3 中协程和线程的映射关系：</p><p><strong>N:1关系</strong></p><p>N 个协程绑定 1 个线程，优点就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1 个进程的所有协程都绑定在 1 个线程上。</p><p>缺点：</p><ul><li>某个程序用不了硬件的多核加速能力</li><li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/kfPbThcyRU.png" alt="img"></p><p><strong>1:1关系</strong></p><p>1 个协程绑定 1 个线程，这种最容易实现。协程的调度都由 CPU 完成了，不存在 N:1 缺点。</p><p>缺点：</p><ul><li>协程的创建、删除和切换的代价都由 CPU 完成，有点略显昂贵了。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/EhNQY2VCpk.png" alt="img"></p><p><strong>M:N关系</strong></p><p>M 个协程绑定 1 个线程，是 N:1 和 1:1 类型的结合，克服了以上 2 种模型的缺点，但实现起来最为复杂。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/ANDQLx3g9U.png" alt="img"></p><p> 协程跟线程是有区别的，线程由 CPU 调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出 CPU 后，才执行下一个协程。</p><h3 id="Go语言中的协程goroutine"><a href="#Go语言中的协程goroutine" class="headerlink" title="Go语言中的协程goroutine"></a>Go语言中的协程goroutine</h3><p><strong>Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel</strong>。goroutine 来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被 runtime 调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go 中，协程被称为 goroutine，它非常轻量，一个 goroutine 只占几 KB，并且这几 KB 就足够 goroutine 运行完，这就能在有限的内存空间内支持大量 goroutine，支持了更多的并发。虽然一个 goroutine 的栈只占几 KB，但实际是可伸缩的，如果需要更多内容，runtime 会自动为 goroutine 分配。</p><p>Goroutine 特点：</p><ul><li>占用内存更小（几 kb,默认2kb）</li><li>调度更灵活 (runtime 调度)</li></ul><h3 id="被废弃的goroutine-调度器"><a href="#被废弃的goroutine-调度器" class="headerlink" title="被废弃的goroutine 调度器"></a>被废弃的goroutine 调度器</h3><p> 好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p><p>Go 目前使用的调度器是 2012 年重新设计的，因为之前的调度器性能存在问题，所以使用 4 年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p><p><strong>大部分文章都是会用 G 来表示 Goroutine，用 M 来表示线程，那么我们也会用这种表达的对应关系。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/Af6GQ3GSlb.png" alt="img"></p><p>下面我们来看看被废弃的 golang 调度器是如何实现的？</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/uWk9pzdREk.png" alt="img"></p><p>M 想要执行、放回 G 都<strong>必须访问全局 G 队列</strong>，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的。</p><p>老调度器有几个缺点：</p><ul><li>创建、销毁、调度 G 都需要每个 M 获取锁，这就形成了激烈的锁竞争。</li><li>M 转移 G 会造成延迟和额外的系统负载。比如当 G 中包含创建新协程的时候，M 创建了 G’，为了继续执行 G，需要把 G’交给 M’执行，也造成了很差的局部性，因为 G’和 G 是相关的，最好放在 M 上执行，而不是其他 M’。</li><li>系统调用 (CPU 在 M 之间的切换) 导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ul><h2 id="Goroutine-调度器的GMP模型的设计思想"><a href="#Goroutine-调度器的GMP模型的设计思想" class="headerlink" title="Goroutine 调度器的GMP模型的设计思想"></a>Goroutine 调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go 设计了新的调度器。</p><p>在新调度器中，除了 M (thread) 和 G (goroutine)，又引进了 P (Processor)。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/zaZ4nQYcZe.png" alt="img"></p><p><strong>Processor</strong>，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</p><h3 id="GMP-模型"><a href="#GMP-模型" class="headerlink" title="GMP 模型"></a>GMP 模型</h3><p>在 Go 中，<strong>线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/Ugu3C2WSpM.png" alt="img"></p><ol><li><strong>全局队列</strong>（Global Queue）：存放等待运行的 G。</li><li><strong>P 的本地队列</strong>：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。</li><li><strong>P 列表</strong>：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。</li><li><strong>M</strong>：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。</li></ol><p><strong>Goroutine 调度器和 OS 调度器是通过 M 结合起来的，每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</strong>。</p><h4 id="有关-P-和-M-的个数问题"><a href="#有关-P-和-M-的个数问题" class="headerlink" title="有关 P 和 M 的个数问题"></a>有关 P 和 M 的个数问题</h4><ol><li>P 的数量：</li></ol><ul><li>由启动时环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有 $GOMAXPROCS 个 goroutine 在同时运行。</li></ul><ol start="2"><li>M 的数量:</li></ol><ul><li>go 语言本身的限制：go 程序启动时，会设置 M 的最大数量，默认 10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li><li>runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量</li><li>一个 M 阻塞了，会创建新的 M。</li></ul><p><strong>M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去创建或者切换另一个 M，所以，即使 P 的默认数量是 1，也有可能会创建很多个 M 出来。</strong></p><h4 id="P-和-M何时会被创建"><a href="#P-和-M何时会被创建" class="headerlink" title="P 和 M何时会被创建"></a>P 和 M何时会被创建</h4><ol><li><p>P 何时创建：在确定了 P 的最大数量 n 后，运行时系统会根据这个数量创建 n 个 P。</p></li><li><p>M 何时创建：没有足够的 M 来关联 P 并运行其中的可运行的 G。比如所有的 M 此时都阻塞住了，而 P 中还有很多就绪任务，就会去寻找空闲的 M，而没有空闲的，就会去创建新的 M。</p></li></ol><h3 id="调度器的设计策略"><a href="#调度器的设计策略" class="headerlink" title="调度器的设计策略"></a>调度器的设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p><p>1）work stealing 机制</p><p> 当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。</p><p>2）hand off 机制</p><p> 当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。</p><p><strong>利用并行</strong>：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。</p><p><strong>抢占</strong>：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。</p><p><strong>全局 G 队列</strong>：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，<strong>当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。</strong></p><h3 id="go-func-调度流程"><a href="#go-func-调度流程" class="headerlink" title="go func()调度流程"></a>go func()调度流程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/a4vWtvRWGQ.png" alt="img"></p><p>从上图我们可以分析出几个结论：</p><ol><li><p>我们通过 go func () 来创建一个 goroutine；</p></li><li><p>有两个存储 G 的队列，一个是局部调度器 P 的本地队列、一个是全局 G 队列。新创建的 G 会先保存在 P 的本地队列中，如果 P 的本地队列已经满了就会保存在全局的队列中；</p></li><li><p>G 只能运行在 M 中，一个 M 必须持有一个 P，M 与 P 是 1：1 的关系。M 会从 P 的本地队列弹出一个可执行状态的 G 来执行，如果 P 的本地队列为空，就会想其他的 MP 组合偷取一个可执行的 G 来执行；</p></li><li><p>一个 M 调度 G 执行的过程是一个循环机制；</p></li><li><p>当 M 执行某一个 G 时候如果发生了 syscall 或则其余阻塞操作，M 会阻塞，如果当前有一些 G 在执行，runtime 会把这个线程 M 从 P 中摘除 (detach)，然后再创建一个新的操作系统的线程 (如果有空闲的线程可用就复用空闲线程) 来服务于这个 P；</p></li><li><p>当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中。</p></li></ol><h3 id="调度器的生命周期"><a href="#调度器的生命周期" class="headerlink" title="调度器的生命周期"></a>调度器的生命周期</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/j37FX8nek9.png" alt="img"></p><p>特殊的 M0 和 G0</p><p><strong>M0</strong></p><ul><li>M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，M0 负责执行初始化操作和启动第一个 G， 在之后 M0 就和其他的 M 一样了。</li></ul><p><strong>G0</strong></p><ul><li>G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。</li></ul><p>我们来跟踪一段代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p><p>也会经历如上图所示的过程：</p><ol><li>runtime 创建最初的线程 m0 和 goroutine g0，并把 2 者关联。</li><li>调度器初始化：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表。</li><li>示例代码中的 main 函数是 main.main，runtime 中也有 1 个 main 函数 ——runtime.main，代码经过编译后，runtime.main 会调用 main.main，程序启动时会为 runtime.main 创建 goroutine，称它为 main goroutine 吧，然后把 main goroutine 加入到 P 的本地队列。</li><li>启动 m0，m0 已经绑定了 P，会从 P 的本地队列获取 G，获取到 main goroutine。</li><li>G 拥有栈，M 根据 G 中的栈信息和调度信息设置运行环境</li><li>M 运行 G</li><li>G 退出，再次回到 M 获取可运行的 G，这样重复下去，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序。</li></ol><p>调度器的生命周期几乎占满了一个 Go 程序的一生，runtime.main 的 goroutine 执行之前都是为调度器做准备工作，runtime.main 的 goroutine 运行，才是调度器的真正开始，直到 runtime.main 结束而结束。</p><h3 id="可视化GMP编程"><a href="#可视化GMP编程" class="headerlink" title="可视化GMP编程"></a>可视化GMP编程</h3><p>有 2 种方式可以查看一个程序的 GMP 的数据。</p><p><strong>方式 1：go tool trace</strong></p><p>trace 记录了运行时的信息，能提供可视化的 Web 页面。</p><p>简单测试代码：main 函数创建 trace，trace 会运行在单独的 goroutine 中，然后 main 打印”Hello World” 退出。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建trace文件</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;trace.out&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动trace goroutine</span></span><br><span class="line">    err = trace.Start(f)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//main</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run trace.<span class="keyword">go</span> </span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>会得到一个 <code>trace.out</code> 文件，然后我们可以用一个工具打开，来分析这个文件。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> tool trace trace.out </span><br><span class="line"><span class="number">2020</span>/<span class="number">02</span>/<span class="number">23</span> <span class="number">10</span>:<span class="number">44</span>:<span class="number">11</span> Parsing trace...</span><br><span class="line"><span class="number">2020</span>/<span class="number">02</span>/<span class="number">23</span> <span class="number">10</span>:<span class="number">44</span>:<span class="number">11</span> Splitting trace...</span><br><span class="line"><span class="number">2020</span>/<span class="number">02</span>/<span class="number">23</span> <span class="number">10</span>:<span class="number">44</span>:<span class="number">11</span> Opening browser. Trace viewer is listening on http:<span class="comment">//127.0.0.1:33479</span></span><br></pre></td></tr></table></figure><p>我们可以通过浏览器打开 <code>http://127.0.0.1:33479</code> 网址，点击 <code>view trace</code> 能够看见可视化的调度流程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/Xr9qi3emlx.png" alt="img"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/vYyO9YJmam.png" alt="img"></p><p><strong>G信息</strong></p><p>点击 Goroutines 那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/QLm0KK1hhd.png" alt="img"></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</span><br></pre></td></tr></table></figure><p>其中 G1 应该就是 main goroutine (执行 main 函数的协程)，在一段时间内处于可运行和运行的状态。</p><p><strong>M 信息</strong></p><p>点击 Threads 那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/mYYA4V17yF.png" alt="img"></p><p>一共有两个 M 在程序中，一个是特殊的 M0，用于初始化使用，这个我们不必讨论。</p><p><strong>P 信息</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/QbWwbth8uN.png" alt="img"></p><p>G1 中调用了 main.main，创建了 trace goroutine g18。G1 运行在 P1 上，G18 运行在 P0 上。</p><p>这里有两个 P，我们知道，一个 P 必须绑定一个 M 才能调度 G。</p><p>我们在来看看上面的 M 信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/5kS6NfpQAI.png" alt="img"></p><p>我们会发现，确实 G18 在 P0 上被运行的时候，确实在 Threads 行多了一个 M 的数据，点击查看如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/EN1OESafVZ.png" alt="img"></p><p>多了一个 M2 应该就是 P0 为了执行 G18 而动态创建的 M2。</p><p><strong>方式 2：Debug trace</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build trace2.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p>通过Debug的方式运行</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GODEBUG=schedtrace=<span class="number">1000</span> ./trace2 </span><br><span class="line">SCHED <span class="number">0</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">0</span> threads=<span class="number">4</span> spinningthreads=<span class="number">1</span> idlethreads=<span class="number">1</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">1003</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">2014</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">3015</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br><span class="line">SCHED <span class="number">4023</span>ms: gomaxprocs=<span class="number">2</span> idleprocs=<span class="number">2</span> threads=<span class="number">4</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">2</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><ul><li>SCHED：调试信息输出标志字符串，代表本行是 goroutine 调度器的输出；</li><li>0ms：即从程序启动到输出这行日志的时间；</li><li>gomaxprocs: P 的数量，本例有 2 个 P, 因为默认的 P 的属性是和 cpu 核心数量默认一致，当然也可以通过 GOMAXPROCS 来设置；</li><li>idleprocs: 处于 idle 状态的 P 的数量；通过 gomaxprocs 和 idleprocs 的差值，我们就可知道执行 go 代码的 P 的数量；</li><li>threads: os threads/M 的数量，包含 scheduler 使用的 m 数量，加上 runtime 自用的类似 sysmon 这样的 thread 的数量；</li><li>spinningthreads: 处于自旋状态的 os thread 数量；</li><li>idlethread: 处于 idle 状态的 os thread 的数量；</li><li>runqueue=0： Scheduler 全局队列中 G 的数量；</li><li>[0 0]: 分别为 2 个 P 的 local queue 中的 G 的数量。</li></ul><p>下一篇，我们来继续详细的分析 GMP 调度原理的一些场景问题。</p><h2 id="Go调度器调度场景全过程解析"><a href="#Go调度器调度场景全过程解析" class="headerlink" title="Go调度器调度场景全过程解析"></a>Go调度器调度场景全过程解析</h2><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>P 拥有 G1，M1 获取 P 后开始运行 G1，G1 使用 <code>go func()</code> 创建了 G2，为了局部性 G2 优先加入到 P1 的本地队列。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/Pm8LOYcsWQ.png" alt="img"></p><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>G1 运行完成后 (函数：goexit)，M 上运行的 goroutine 切换为 G0，G0 负责调度时协程的切换（函数：schedule）。从 P 的本地队列取 G2，从 G0 切换到 G2，并开始运行 G2 (函数：execute)。实现了线程 M1 的复用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/JWDtmKG3rK.png" alt="img"></p><h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><p>假设每个 P 的本地队列只能存 3 个 G。G2 要创建了 6 个 G，前 3 个 G（G3, G4, G5）已经加入 p1 的本地队列，p1 本地队列满了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/UpjRxzIBd3.png" alt="img"></p><h3 id="场景4"><a href="#场景4" class="headerlink" title="场景4"></a>场景4</h3><p>G2 在创建 G7 的时候，发现 P1 的本地队列已满，需要执行<strong>负载均衡</strong> (把 P1 中本地队列中前一半的 G，还有新创建 G <strong>转移</strong>到全局队列)</p><p><strong>（实现中并不一定是新的 G，如果 G 是 G2 之后就执行的，会被保存在本地队列，利用某个老的 G 替换新 G 加入全局队列）</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/chqTgsiuWi.png" alt="img"></p><p>这些 G 被转移到全局队列时，会被打乱顺序。所以 G3,G4,G7 被转移到全局队列。</p><h3 id="场景5"><a href="#场景5" class="headerlink" title="场景5"></a>场景5</h3><p>G2 创建 G8 时，P1 的本地队列未满，所以 G8 会被加入到 P1 的本地队列。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/nukEY92G6D.png" alt="img"></p><p>G8 加入到 P1 点本地队列的原因还是因为 P1 此时在与 M1 绑定，而 G2 此时是 M1 在执行。所以 G2 创建的新的 G 会优先放置到自己的 M 绑定的 P 上。</p><h3 id="场景6"><a href="#场景6" class="headerlink" title="场景6"></a>场景6</h3><p>规定：<strong>在创建 G 时，运行的 G 会尝试唤醒其他空闲的 P 和 M 组合去执行</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/2FWNXSuHfX.png" alt="img"></p><p>假定 G2 唤醒了 M2，M2 绑定了 P2，并运行 G0，但 P2 本地队列没有 G，M2 此时为自旋线程<strong>（没有 G 但为运行状态的线程，不断寻找 G）</strong>。</p><h3 id="场景7"><a href="#场景7" class="headerlink" title="场景7"></a>场景7</h3><p>M2 尝试从全局队列 (简称 “GQ”) 取一批 G 放到 P2 的本地队列（函数：<code>findrunnable()</code>）。M2 从全局队列取的 G 数量符合下面的公式：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n = min(<span class="built_in">len</span>(GQ)/GOMAXPROCS + <span class="number">1</span>, <span class="built_in">len</span>(GQ/<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>至少从全局队列取 1 个 g，但每次不要从全局队列移动太多的 g 到 p 本地队列，给其他 p 留点。这是<strong>从全局队列到 P 本地队列的负载均衡</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/0fn8DGqI8N.png" alt="img"></p><p>假定我们场景中一共有 4 个 P（GOMAXPROCS 设置为 4，那么我们允许最多就能用 4 个 P 来供 M 使用）。所以 M2 只从能从全局队列取 1 个 G（即 G3）移动 P2 本地队列，然后完成从 G0 到 G3 的切换，运行 G3。</p><h3 id="场景8"><a href="#场景8" class="headerlink" title="场景8"></a>场景8</h3><p>假设 G2 一直在 M1 上运行，经过 2 轮后，M2 已经把 G7、G4 从全局队列获取到了 P2 的本地队列并完成运行，全局队列和 P2 的本地队列都空了，如场景 8 图的左半部分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/qn1NRMLqnp.png" alt="img"></p><p><strong>全局队列已经没有 G，那 m 就要执行 work stealing (偷取)：从其他有 G 的 P 哪里偷取一半 G 过来，放到自己的 P 本地队列。</strong>P2 从 P1 的本地队列尾部取一半的 G，本例中一半则只有 1 个 G8，放到 P2 的本地队列并执行。</p><h3 id="场景9"><a href="#场景9" class="headerlink" title="场景9"></a>场景9</h3><p>P1 本地队列 G5、G6 已经被其他 M 偷走并运行完成，当前 M1 和 M2 分别在运行 G2 和 G8，M3 和 M4 没有 goroutine 可以运行，M3 和 M4 处于<strong>自旋状态</strong>，它们不断寻找 goroutine。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/1DjlseEGTT.png" alt="img"></p><p>为什么要让 m3 和 m4 自旋，自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，<strong>我们希望当有新 goroutine 创建时，立刻能有 M 运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 GOMAXPROCS 个自旋的线程 (当前例子中的 GOMAXPROCS=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。</p><h3 id="场景10"><a href="#场景10" class="headerlink" title="场景10"></a>场景10</h3><p> 假定当前除了 M3 和 M4 为自旋线程，还有 M5 和 M6 为空闲的线程 (没有得到 P 的绑定，注意我们这里最多就只能够存在 4 个 P，所以 P 的数量应该永远是 M&gt;=P, 大部分都是 M 在抢占需要运行的 P)，G8 创建了 G9，<strong>G8 进行了阻塞的系统调用</strong>，M2 和 P2 立即解绑，P2 会执行以下判断：如果 P2 本地队列有 G、全局队列有 G 或有空闲的 M，P2 都会立马唤醒 1 个 M 和它绑定，否则 P2 则会加入到空闲 P 列表，等待 M 来获取可用的 p。本场景中，P2 本地队列有 G9，可以和其他空闲的线程 M5 绑定。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/k3HKE9U21M.png" alt="img"></p><h3 id="场景11"><a href="#场景11" class="headerlink" title="场景11"></a>场景11</h3><p>G8 创建了 G9，假如 G8 进行了<strong>非阻塞系统调用</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/go_img/zBvpl8ENSb.png" alt="img"></p><p>M2 和 P2 会解绑，但 M2 会记住 P2，然后 G8 和 M2 进入<strong>系统调用状态</strong>。当 G8 和 M2 退出系统调用时，会尝试获取 P2，如果无法获取，则获取空闲的 P，如果依然没有，G8 会被记为可运行状态，并加入到全局队列，M2 因为没有 P 的绑定而变成休眠状态 (长时间休眠等待 GC 回收销毁)。。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结，Go 调度器很轻量也很简单，足以撑起 goroutine 的调度工作，并且让 Go 具有了原生（强大）并发的能力。<strong>Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Go语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CDC_Architecture_Analysis</title>
      <link href="posts/32752.html"/>
      <url>posts/32752.html</url>
      
        <content type="html"><![CDATA[<h2 id="CDC整体架构分析"><a href="#CDC整体架构分析" class="headerlink" title="CDC整体架构分析"></a>CDC整体架构分析</h2><h3 id="CDC-概览"><a href="#CDC-概览" class="headerlink" title="CDC 概览"></a>CDC 概览</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc-overview.png" alt="cdc-overview.png"></p><h3 id="CDC流程图"><a href="#CDC流程图" class="headerlink" title="CDC流程图"></a>CDC流程图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc-seq.png" alt="cdc-seq.png"></p><hr><h3 id="Range-Feed原理分析"><a href="#Range-Feed原理分析" class="headerlink" title="Range Feed原理分析"></a>Range Feed原理分析</h3><p><strong>RangeFeed数据来源</strong><br>下图中的步骤③当raft group leader 将raft log apply到状态机时，将raftCommand中对应的数据变更publish出来<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/raft.png" alt="raft.png"><br><strong>RangeFeed捕获变更数据流程</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/rangefeed.png" alt="rangefeed.png"><br><strong>Feed结构分析</strong><br>![cdc ca.png.png](<a href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc">https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc</a> ca.png)</p><hr><h4 id="The-Difficulty-With-Decoding-WriteBatches"><a href="#The-Difficulty-With-Decoding-WriteBatches" class="headerlink" title="The Difficulty With Decoding WriteBatches"></a>The Difficulty With Decoding WriteBatches</h4><p><strong>MVCC操作对应的WriteBatch包含的entries</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">- MVCCPut</span><br><span class="line">    - inline (never transactional)</span><br><span class="line">        + write meta key w/ inline value</span><br><span class="line">    - not inline</span><br><span class="line">        - transactional</span><br><span class="line">            - no</span><br><span class="line">                + write <span class="built_in">new</span> version</span><br><span class="line">            - yes</span><br><span class="line">                - intent exists with older timestamp</span><br><span class="line">                    + clear old version</span><br><span class="line">                    + write meta</span><br><span class="line">                    + write <span class="built_in">new</span> version</span><br><span class="line">                - <span class="keyword">else</span></span><br><span class="line">                    + write meta</span><br><span class="line">                    + write <span class="built_in">new</span> version</span><br><span class="line">- MVCCDelete</span><br><span class="line">    - inline (never transactional)</span><br><span class="line">        + clear meta key</span><br><span class="line">    - not inline</span><br><span class="line">        + same as MVCCPut but with empty value and Deleted=<span class="literal">true</span> in meta</span><br><span class="line">- MVCCDeleteRange</span><br><span class="line">    + calls MVCCDelete <span class="keyword">for</span> each key in <span class="keyword">range</span></span><br><span class="line">- MVCCMerge</span><br><span class="line">    + write merge record (never transactional)</span><br><span class="line">- MVCCResolveWriteIntent</span><br><span class="line">    - commit</span><br><span class="line">        + clear meta</span><br><span class="line">        - <span class="keyword">if</span> timestamp of intent is incorrect</span><br><span class="line">            + clear old version key</span><br><span class="line">            + write <span class="built_in">new</span> version key</span><br><span class="line">    - abort</span><br><span class="line">        + clear version key</span><br><span class="line">        + clear meta key</span><br><span class="line">    - push</span><br><span class="line">        + write meta with larger timestamp</span><br><span class="line">        + clear old version key</span><br><span class="line">        + write <span class="built_in">new</span> version key</span><br><span class="line">- MVCCGarbageCollect</span><br><span class="line">    + clear each meta key</span><br><span class="line">    + clear each version</span><br></pre></td></tr></table></figure><p>解码 <em><strong>WriteBatches</strong></em> 的过程将包括获取RocksDB批处理条目列表并对其正在执行的集体更高级别的操作进行反向工程。例如，包含对同一个逻辑键的meta键和版本键的写操作的WriteBatch将被解释为一个意向写操作;同样，删除meta键将被解释为一个成功的intent解析操作。这里不仅需要进行大量的状态转换以进行模式匹配，而且还不清楚在没有额外的引擎读取的情况下这种解码是否会变得清晰无误，也就是说，对WriteBatch本身进行解码的过程是任何方式都是无法克服的。更令人担忧的是，这正在对筏上MVCC层的实现细节造成非常严重的筏下依赖。引入这种依赖性后，我们将必须非常谨慎地对MVCC进行任何更改，这可能会导致严重的后果。诸如此类的问题促使提议者评估kv重构，因此不应掉以轻心。</p><h4 id="Logical-MVCC-Operations"><a href="#Logical-MVCC-Operations" class="headerlink" title="Logical MVCC Operations"></a>Logical MVCC Operations</h4><p>因此，我们提出了一种替代方法来对<code>WriteBatch</code>进行解码直接在Raft命令中。相反，我们建议引入一种逻辑每个Raft命令的更高级MVCC操作的列表。这些更高层次的操作将不受物理操作语义的约束描述在<code>WriteBatch</code>中，因此不会限制对其的更改将来。取而代之的是，这些操作将描述批次的更改在MVCC级别。这样可以避免以前的问题，并且更容易解码Raft下游的操作。</p><p><em><strong>LogicalOps</strong></em><br><code>RaftCommand</code> proto message:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repeated MVICLogicalOp mvcc_ops;</span><br></pre></td></tr></table></figure><p><code>MVICLogicalOp</code>定义:</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message Bytes &#123;</span><br><span class="line">    option (gogoproto.onlyone) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    bytes inline = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    message Pointer &#123;</span><br><span class="line">        <span class="keyword">int32</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int32</span> <span class="built_in">len</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Pointer pointer = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCWriteValueOp &#123;</span><br><span class="line">    bytes key = <span class="number">1</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">2</span>;</span><br><span class="line">    bytes value = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCWriteIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">    bytes txn_key = <span class="number">2</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCUpdateIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCCommitIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">    bytes key = <span class="number">2</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">3</span>;</span><br><span class="line">    bytes value = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCAbortIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVICLogicalOp &#123;</span><br><span class="line">    option (gogoproto.onlyone) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    MVCCWriteValueOp   write_value   = <span class="number">1</span>;</span><br><span class="line">    MVCCWriteIntentOp  write_intent  = <span class="number">2</span>;</span><br><span class="line">    MVCCUpdateIntentOp update_intent = <span class="number">3</span>;</span><br><span class="line">    MVCCCommitIntentOp commit_intent = <span class="number">4</span>;</span><br><span class="line">    MVCCAbortIntentOp  abort_intent  = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，所有字节切片值将可选地指向WriteBatch本身，这将有助于限制由于复制物理和逻辑操作而导致的写放大。 此优化可以逐步引入。 我们还可以探索压缩技术，这可能会导致类似的重复数据删除。在Raft之上，随着在BatchRequest中处理每个请求，MVCCOps的日志将与WriteBatch并排构造。 将Raft及其MVCC操作分开，然后分别通过以下逻辑运行它们：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> op in mvccOps &#123;</span><br><span class="line">    match op &#123;</span><br><span class="line">        WriteValue(key, ts, val) =&gt; SendValueToMatchingFeeds(key, ts, val),</span><br><span class="line">        WriteIntent(txnID, ts)   =&gt; &#123;</span><br><span class="line">            UnresolvedIntentQueue[txnID].refcount++</span><br><span class="line">            UnresolvedIntentQueue[txnID].Timestamp.Forward(ts)</span><br><span class="line">        &#125;, </span><br><span class="line">        UpdateIntent(txnID, ts) =&gt; UnresolvedIntentQueue[txnID].Timestamp.Forward(ts),</span><br><span class="line">        CommitIntent(txnID, key, ts) =&gt; &#123;</span><br><span class="line">            UnresolvedIntentQueue[txnID].refcount--</span><br><span class="line">            <span class="comment">// It&#x27;s unfortunate that we&#x27;ll need to perform an engine lookup</span></span><br><span class="line">            <span class="comment">// for this, but it&#x27;s not a huge deal. The value should almost</span></span><br><span class="line">            <span class="comment">// certainly be in RocksDB&#x27;s memtable or block cache, so there&#x27;s</span></span><br><span class="line">            <span class="comment">// not much of a reason for any extra layer of caching.</span></span><br><span class="line">            SendValueToMatchingFeeds(key, MVCCGet(key, ts), ts)</span><br><span class="line">        &#125;,</span><br><span class="line">        AbortIntent    =&gt; UnresolvedIntentQueue[txnID].refcount--,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CDC-代码时序图编写"><a href="#CDC-代码时序图编写" class="headerlink" title="CDC 代码时序图编写"></a>CDC 代码时序图编写</h2><h2 id="CDC最终一致性"><a href="#CDC最终一致性" class="headerlink" title="CDC最终一致性"></a>CDC最终一致性</h2><p>建立CockroachDB changefeed的最大挑战从一开始就很明显。我们希望我们的changefeed可以横向扩展，同时我们也希望它们保持强大的事务语义。</p><p>在单节点数据库中，比如MySQL, 它维护一个binlog记录数据的变更,因此构建changefeed的工作主要是以合理的方式公开此日志.其他的数据库也类似。但是，CockroachDB具有独特的分布式架构。它存储的数据被分解为大约64MB的“ranges”。这些ranges每个都被复制成N个“副本”以获得高可用。CockroachDB事务可以涉及任何或所有这些ranges，这意味着它可以跨越集群中的任何或所有节点。这与在水平扩展其他SQL数据库时使用的“分片”设置形成对比，其中每个分片是完全独立的复制单元，并且事务不能跨越分片。然后，分片SQL群集上的changefeed只是每个分片的changefeed，通常由分片的领导者运行,如下图所示。由于每个事务完全发生在一个分片中，因此分片之间事务的相对排序并不那么值得特别关注（或者说大家很多时候不在乎这种分片之间的事务排序）。它还意味着各个分片的feeds可以完全并行化（每个分片一个Kafka主题或分区是典型的）。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/range_database.png" alt="range_database.png"><br>图1：分片SQL数据库中的事务无法跨越分片。</p><p>由于CockroachDB事务可以使用集群中的任何range集合（考虑跨分片事务），因此事务排序要复杂得多, 如下图所示。特别是，并不总是可以将事务划分为独立的流。这里简单的答案是将每个事务放入一个流中，但我们对此并不满意。CockroachDB旨在水平扩展到大量节点，因此我们当然希望我们的changefeed也可以水平扩展。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/znbase_txn.png" alt="znbase_txn.png"></p><p>图2：CockroachDB中的事务可以跨节点。</p><h3 id="分布式事务保证事务语义"><a href="#分布式事务保证事务语义" class="headerlink" title="分布式事务保证事务语义"></a>分布式事务保证事务语义</h3><p>CockroachDB中的SQL表可以跨越多个range，但该表中的每一行始终包含在一个range内。（当range变大时系统可以移动，系统将其分成两部分以及range变小并且系统将其合并到相邻range时，但这些可以单独处理。）此外，每个range都是一个独立的raft group，因此有自己的WAL，我们可以追随这个WAL。这意味着我们可以为每个SQL行生成有序的changefeed。为了实现这一目标，我们开发了一种内部机制RangeFeed，将这些变化直接从我们的raft group中推出，而不是轮询它们。</p><p>每个Row流都是独立的，这意味着我们可以水平缩放它们。使用我们的分布式SQL框架，我们将处理器放置在正在观察的数据旁边发出行更改，从而消除不必要的网络跃点。如果一个节点完成所有观看和发送，它还可以避免我们遇到的单点故障,如下图所示。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/znbase_cdc.png" alt="znbase_cdc.png"><br>图3：CockroachDB range leader各自直接向Kafka（或其他接收器）发出changefeed。</p><p>对于许多changefeed用途，这就足够了,每条消息都可以触发移动推送通知，某些数据存储不支持事务。有序的行流对这两者都很有用。对于其他用途，这还不够; 将数据镜像到分析数据库当然不希望应用部分事务。</p><p>每个CockroachDB事务使用相同的HLC时间戳提交每一行。在每个消息中为更改的行暴露此时间戳就足以获得事务信息（按时间戳分组行集合）[1]以及总排序（按时间戳排序行）。在我们现有的事务时间戳之上构建意味着我们的changefeed与CockroachDB中的其他所有内容具有相同的可序列化保证。</p><p>那最后的问题是知道何时进行这一组或排序。如果hlc1从一个CockroachDB节点随时间发出更改的行，那么在对其进行操作之前，您需要等待多长时间才能确保其他任何节点都没有更改hlc1？</p><p>我们用一个我们称之为“resolved”的时间戳消息的概念来解决这个问题。这是一个承诺，即不会发出新的行更改，其时间戳小于或等于已解析的时间戳消息中的时间戳。这意味着上述用户可以在hlc1从每个节点[2]接收到已解决的时间戳之后进行操作&gt;= hlc1, 如下图所示。<br>![cdc resolved.png](<a href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc">https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc</a> resolved.png)</p><p>图4中为事务发出的前几条消息的一种可能排序。</p><p>在图4中，想象两个独立的流都已经通过读取X。hlc1在其中一个stream上已经“resolved”，但在另外一个stream上没有“resolved”，所以hlc1还没有“resolved。</p><p>现在想象一下，在稍后的某些时候，消息已经被读过了Y。两个stream都已“resolved”了hlc1，所以我们知道我们已收到所有已发生的变化，包括hlc1。如果我们按时间戳对消息进行分组，我们可以恢复交易。在这种情况下，只有(B-&gt;1,C-&gt;2)，承诺在hlc1。此事务现在可以发送到分析数据库。</p><p>请注意，(A-&gt;3)更改发生在hlc2，因此尚未“resolved”。这意味着changefeed用户需要继续缓存它。</p><p>我们还可以随时重建数据库的状态，包括hlc1保持每行的最新值。这甚至适用于范围和节点。在这种情况下，hlc1数据库时B=1,C=2。</p><p>最后，想象一下稍后Z读取所有消息的时间。通过相同的两个进程再次获取数据库的事务和状态。在这种情况下，交易(A-&gt;3,B-&gt;4)承诺hlc2和(C-&gt;5)承诺hlc3。在hlc3包含的数据库中A=3,B=1,C=5。请注意，hlc2如有必要，我们还可以重建数据库。</p><p>这个创新的解决方案来源于一篇论文《Naiad: A Timely Dataflow System》,其核心思想类似于TCP的接收时间窗口,CockroachDB就是基于这样的思想设计自己的CDC解决方案.</p><h4 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题:"></a>现存问题:</h4><p><strong>自动启动CDC:CockroachDB的CDC是表级别的,但是对于一般的同步任务来说需要至少在DB层面进行配置,以便简化处理,这里的挑战是对于大部分消息队列,只能保证单分片上的数据有序性,而我们在table层面需要这种有序性才能正确的将数据变更按照事务粒度重新组织。</strong></p><p><strong>事务捕获:CockroachDB的CDC并不是事务粒度,而是行级别分散的,另外CockroachDB不相干的事务的时间顺序没有严格要求,导致从消息队列中消费的事件的时间戳是混乱的,并且可能存在重复的事件,因此首先我们需要在消费端按照事务作为最小单元重新整理这些数据,这个的主要依据就是事件携带的时间戳,相同时间戳的事件被认为是属于同一个事务的(两个不重叠的事务可以使用相同的时间戳进行提交，但它们具有纳秒精度，因此在实践中这种情况很少见).然后我们按照时间大小顺序重新排序,其中需要对重复的数据进行过滤.</strong></p><hr><h2 id="代码研读"><a href="#代码研读" class="headerlink" title="代码研读"></a>代码研读</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stageRaftCommand handles the first phase of applying a command to the</span></span><br><span class="line"><span class="comment">// replica state machine.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The proposal also contains auxiliary data which needs to be verified in order</span></span><br><span class="line"><span class="comment">// to decide whether the proposal should be applied: the command&#x27;s MaxLeaseIndex</span></span><br><span class="line"><span class="comment">// must move the state machine&#x27;s LeaseAppliedIndex forward, and the proposer&#x27;s</span></span><br><span class="line"><span class="comment">// lease (or rather its sequence number) must match that of the state machine,</span></span><br><span class="line"><span class="comment">// and lastly the GCThreshold is validated. If any of the checks fail, the</span></span><br><span class="line"><span class="comment">// proposal&#x27;s content is wiped and we apply an empty log entry instead. If an</span></span><br><span class="line"><span class="comment">// error occurs and the command was proposed locally, the error will be</span></span><br><span class="line"><span class="comment">// communicated to the waiting proposer. The two typical cases in which errors</span></span><br><span class="line"><span class="comment">// occur are lease mismatch (in which case the caller tries to send the command</span></span><br><span class="line"><span class="comment">// to the actual leaseholder) and violation of the LeaseAppliedIndex (in which</span></span><br><span class="line"><span class="comment">// case the proposal is retried if it was proposed locally).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Assuming all checks were passed, the command is applied to the batch,</span></span><br><span class="line"><span class="comment">// which is done by the aptly named applyRaftCommandToBatch.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For trivial proposals this is the whole story, but some commands trigger</span></span><br><span class="line"><span class="comment">// additional code in this method in this method via a side effect (in the</span></span><br><span class="line"><span class="comment">// proposal&#x27;s ReplicatedEvalResult or, for local proposals,</span></span><br><span class="line"><span class="comment">// LocalEvalResult). These might, for example, trigger an update of the</span></span><br><span class="line"><span class="comment">// Replica&#x27;s in-memory state to match updates to the on-disk state, or pass</span></span><br><span class="line"><span class="comment">// intents to the intent resolver. Some commands don&#x27;t fit this simple schema</span></span><br><span class="line"><span class="comment">// and need to hook deeper into the code. Notably splits and merges need to</span></span><br><span class="line"><span class="comment">// acquire locks on their right-hand side Replicas and may need to add data to</span></span><br><span class="line"><span class="comment">// the WriteBatch before it is applied; similarly, changes to the disk layout of</span></span><br><span class="line"><span class="comment">// internal state typically require a migration which shows up here. Any of this</span></span><br><span class="line"><span class="comment">// logic however is deferred until after the batch has been written to the</span></span><br><span class="line"><span class="comment">// storage engine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">stageRaftCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">cmd *cmdAppCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">batch engine.Batch,</span></span></span><br><span class="line"><span class="function"><span class="params">replicaState *storagepb.ReplicaState,</span></span></span><br><span class="line"><span class="function"><span class="params">writeAppliedState <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cmd.e.Index == <span class="number">0</span> &#123;</span><br><span class="line">log.Fatalf(ctx, <span class="string">&quot;processRaftCommand requires a non-zero index&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> log.V(<span class="number">4</span>) &#123;</span><br><span class="line">log.Infof(ctx, <span class="string">&quot;processing command %x: maxLeaseIndex=%d&quot;</span>,</span><br><span class="line">cmd.idKey, cmd.raftCmd.MaxLeaseIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ts hlc.Timestamp</span><br><span class="line"><span class="keyword">if</span> cmd.idKey != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">ts = cmd.replicatedResult().Timestamp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cmd.leaseIndex, cmd.proposalRetry, cmd.forcedErr = checkForcedErr(ctx,</span><br><span class="line">cmd.idKey, cmd.raftCmd, cmd.proposal, cmd.proposedLocally(), replicaState)</span><br><span class="line"></span><br><span class="line"><span class="comment">// applyRaftCommandToBatch will return &quot;expected&quot; errors, but may also indicate</span></span><br><span class="line"><span class="comment">// replica corruption (as of now, signaled by a replicaCorruptionError).</span></span><br><span class="line"><span class="comment">// We feed its return through maybeSetCorrupt to act when that happens.</span></span><br><span class="line"><span class="keyword">if</span> cmd.forcedErr != <span class="literal">nil</span> &#123;</span><br><span class="line">log.VEventf(ctx, <span class="number">1</span>, <span class="string">&quot;applying command with forced error: %s&quot;</span>, cmd.forcedErr)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Event(ctx, <span class="string">&quot;applying command&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> splitMergeUnlock, err := r.maybeAcquireSplitMergeLock(ctx, cmd.raftCmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Eventf(ctx, <span class="string">&quot;unable to acquire split lock: %s&quot;</span>, err)</span><br><span class="line"><span class="comment">// Send a crash report because a former bug in the error handling might have</span></span><br><span class="line"><span class="comment">// been the root cause of #19172.</span></span><br><span class="line">_ = r.store.stopper.RunAsyncTask(ctx, <span class="string">&quot;crash report&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">log.SendCrashReport(</span><br><span class="line">ctx,</span><br><span class="line">&amp;r.store.cfg.Settings.SV,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// depth</span></span><br><span class="line"><span class="string">&quot;while acquiring split lock: %s&quot;</span>,</span><br><span class="line">[]<span class="keyword">interface</span>&#123;&#125;&#123;err&#125;,</span><br><span class="line">log.ReportTypeError,</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">cmd.forcedErr = roachpb.NewError(err)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> splitMergeUnlock != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Set the splitMergeUnlock on the cmdAppCtx to be called after the batch</span></span><br><span class="line"><span class="comment">// has been applied (see applyBatch).</span></span><br><span class="line">cmd.splitMergeUnlock = splitMergeUnlock</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> filter := r.store.cfg.TestingKnobs.TestingApplyFilter; cmd.forcedErr == <span class="literal">nil</span> &amp;&amp; filter != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> newPropRetry <span class="keyword">int</span></span><br><span class="line">newPropRetry, cmd.forcedErr = filter(storagebase.ApplyFilterArgs&#123;</span><br><span class="line">CmdID:                cmd.idKey,</span><br><span class="line">ReplicatedEvalResult: *cmd.replicatedResult(),</span><br><span class="line">StoreID:              r.store.StoreID(),</span><br><span class="line">RangeID:              r.RangeID,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> cmd.proposalRetry == <span class="number">0</span> &#123;</span><br><span class="line">cmd.proposalRetry = proposalReevaluationReason(newPropRetry)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cmd.forcedErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Apply an empty entry.</span></span><br><span class="line">*cmd.replicatedResult() = storagepb.ReplicatedEvalResult&#123;&#125;</span><br><span class="line">cmd.raftCmd.WriteBatch = <span class="literal">nil</span></span><br><span class="line">cmd.raftCmd.LogicalOpLog = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run any triggers that should occur before the batch is applied</span></span><br><span class="line"><span class="comment">// and before the write batch is staged in the batch.</span></span><br><span class="line"><span class="comment">//获取Batch中存储的befor value,也即处理MVICLogicalOp针对于不同的Op进行相关处理，RangeFeed目前处理WriteValue Op以及CommitOp将其对应的Value publish</span></span><br><span class="line"><span class="keyword">if</span> err := r.runPreApplyTriggersBeforeStagingWriteBatch(ctx, cmd, batch); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(ctx, <span class="string">&quot;unable to update the state machine: %+v&quot;</span>, err)</span><br><span class="line">log.Fatal(ctx, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Update the node clock with the serviced request. This maintains</span></span><br><span class="line"><span class="comment">// a high water mark for all ops serviced, so that received ops without</span></span><br><span class="line"><span class="comment">// a timestamp specified are guaranteed one higher than any op already</span></span><br><span class="line"><span class="comment">// executed for overlapping keys.</span></span><br><span class="line"><span class="comment">// TODO(ajwerner): coalesce the clock update per batch.</span></span><br><span class="line">r.store.Clock().Update(ts)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the command was using the deprecated version of the MVCCStats proto,</span></span><br><span class="line"><span class="comment">// migrate it to the new version and clear out the field.</span></span><br><span class="line"><span class="keyword">if</span> deprecatedDelta := cmd.replicatedResult().DeprecatedDelta; deprecatedDelta != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cmd.replicatedResult().Delta != (enginepb.MVCCStatsDelta&#123;&#125;) &#123;</span><br><span class="line">log.Fatalf(ctx, <span class="string">&quot;stats delta not empty but deprecated delta provided: %+v&quot;</span>, cmd)</span><br><span class="line">&#125;</span><br><span class="line">cmd.replicatedResult().Delta = deprecatedDelta.ToStatsDelta()</span><br><span class="line">cmd.replicatedResult().DeprecatedDelta = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the Raft command to the batch&#x27;s accumulated state. This may also</span></span><br><span class="line"><span class="comment">// have the effect of mutating cmd.replicatedResult().</span></span><br><span class="line">err := r.applyRaftCommandToBatch(cmd.ctx, cmd, replicaState, batch, writeAppliedState)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// applyRaftCommandToBatch returned an error, which usually indicates</span></span><br><span class="line"><span class="comment">// either a serious logic bug in CockroachDB or a disk</span></span><br><span class="line"><span class="comment">// corruption/out-of-space issue. Make sure that these fail with</span></span><br><span class="line"><span class="comment">// descriptive message so that we can differentiate the root causes.</span></span><br><span class="line">log.Errorf(ctx, <span class="string">&quot;unable to update the state machine: %+v&quot;</span>, err)</span><br><span class="line"><span class="comment">// Report the fatal error separately and only with the error, as that</span></span><br><span class="line"><span class="comment">// triggers an optimization for which we directly report the error to</span></span><br><span class="line"><span class="comment">// sentry (which in turn allows sentry to distinguish different error</span></span><br><span class="line"><span class="comment">// types).</span></span><br><span class="line">log.Fatal(ctx, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddSSTable ingestions run before the actual batch gets written to the</span></span><br><span class="line"><span class="comment">// storage engine. This makes sure that when the Raft command is applied,</span></span><br><span class="line"><span class="comment">// the ingestion has definitely succeeded. Note that we have taken</span></span><br><span class="line"><span class="comment">// precautions during command evaluation to avoid having mutations in the</span></span><br><span class="line"><span class="comment">// WriteBatch that affect the SSTable. Not doing so could result in order</span></span><br><span class="line"><span class="comment">// reversal (and missing values) here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// NB: any command which has an AddSSTable is non-trivial and will be</span></span><br><span class="line"><span class="comment">// applied in its own batch so it&#x27;s not possible that any other commands</span></span><br><span class="line"><span class="comment">// which precede this command can shadow writes from this SSTable.</span></span><br><span class="line"><span class="keyword">if</span> cmd.replicatedResult().AddSSTable != <span class="literal">nil</span> &#123;</span><br><span class="line">copied := addSSTablePreApply(</span><br><span class="line">ctx,</span><br><span class="line">r.store.cfg.Settings,</span><br><span class="line">r.store.engine,</span><br><span class="line">r.raftMu.sideloaded,</span><br><span class="line">cmd.e.Term,</span><br><span class="line">cmd.e.Index,</span><br><span class="line">*cmd.replicatedResult().AddSSTable,</span><br><span class="line">r.store.limiters.BulkIOWriteRate,</span><br><span class="line">)</span><br><span class="line">r.store.metrics.AddSSTableApplications.Inc(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> copied &#123;</span><br><span class="line">r.store.metrics.AddSSTableApplicationCopies.Inc(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">cmd.replicatedResult().AddSSTable = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cmd.replicatedResult().Split != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Splits require a new HardState to be written to the new RHS</span></span><br><span class="line"><span class="comment">// range (and this needs to be atomic with the main batch). This</span></span><br><span class="line"><span class="comment">// cannot be constructed at evaluation time because it differs</span></span><br><span class="line"><span class="comment">// on each replica (votes may have already been cast on the</span></span><br><span class="line"><span class="comment">// uninitialized replica). Write this new hardstate to the batch too.</span></span><br><span class="line"><span class="comment">// See https://github.com/cockroachdb/cockroach/issues/20629</span></span><br><span class="line">splitPreApply(ctx, batch, cmd.replicatedResult().Split.SplitTrigger)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> merge := cmd.replicatedResult().Merge; merge != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Merges require the subsumed range to be atomically deleted when the</span></span><br><span class="line"><span class="comment">// merge transaction commits.</span></span><br><span class="line">rhsRepl, err := r.store.GetReplica(merge.RightDesc.RangeID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(ctx, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> destroyData = <span class="literal">false</span></span><br><span class="line">err = rhsRepl.preDestroyRaftMuLocked(ctx, batch, batch, merge.RightDesc.NextReplicaID, destroyData)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(ctx, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide the command&#x27;s corresponding logical operations to the Replica&#x27;s</span></span><br><span class="line"><span class="comment">// rangefeed. Only do so if the WriteBatch is non-nil, in which case the</span></span><br><span class="line"><span class="comment">// rangefeed requires there to be a corresponding logical operation log or</span></span><br><span class="line"><span class="comment">// it will shut down with an error. If the WriteBatch is nil then we expect</span></span><br><span class="line"><span class="comment">// the logical operation log to also be nil. We don&#x27;t want to trigger a</span></span><br><span class="line"><span class="comment">// shutdown of the rangefeed in that situation, so we don&#x27;t pass anything to</span></span><br><span class="line"><span class="comment">// the rangefed. If no rangefeed is running at all, this call will be a noop.</span></span><br><span class="line"><span class="keyword">if</span> cmd.raftCmd.WriteBatch != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//与之前的befer处理类似，</span></span><br><span class="line"><span class="comment">//获取Batch中存储的value,也即处理MVICLogicalOp针对于不同的Op进行相关处理，RangeFeed目前处理WriteValue Op以及CommitOp将其对应的Value publish</span></span><br><span class="line">r.handleLogicalOpLogRaftMuLocked(ctx, cmd.raftCmd.LogicalOpLog, batch)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cmd.raftCmd.LogicalOpLog != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(ctx, <span class="string">&quot;non-nil logical op log with nil write batch: %v&quot;</span>, cmd.raftCmd)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// runPreApplyTriggersBeforeStagingWriteBatch runs any triggers that must fire</span></span><br><span class="line"><span class="comment">// before a command is applied to the state machine but after the command is</span></span><br><span class="line"><span class="comment">// staged in the replicaAppBatch&#x27;s write batch. It may modify the command.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">runPreApplyTriggersBeforeStagingWriteBatch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context, cmd *cmdAppCtx, batch engine.Batch,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ops := cmd.raftCmd.LogicalOpLog; ops != <span class="literal">nil</span> &#123;</span><br><span class="line">r.populatePrevValsInLogicalOpLogRaftMuLocked(ctx, ops, batch)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// populatePrevValsInLogicalOpLogRaftMuLocked updates the provided logical op</span></span><br><span class="line"><span class="comment">// log with previous values read from the reader, which is expected to reflect</span></span><br><span class="line"><span class="comment">// the state of the Replica before the operations in the logical op log are</span></span><br><span class="line"><span class="comment">// applied. No-op if a rangefeed is not active. Requires raftMu to be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">populatePrevValsInLogicalOpLogRaftMuLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context, ops *storagepb.LogicalOpLog, prevReader engine.Reader,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.raftMu.rangefeed == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ops == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read from the Reader to populate the PrevValue fields.</span></span><br><span class="line"><span class="keyword">for</span> _, op := <span class="keyword">range</span> ops.Ops &#123;</span><br><span class="line"><span class="keyword">var</span> key []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> ts hlc.Timestamp</span><br><span class="line"><span class="keyword">var</span> prevValPtr *[]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">switch</span> t := op.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCWriteValueOp:</span><br><span class="line">key, ts, prevValPtr = t.Key, t.Timestamp, &amp;t.PrevValue</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCCommitIntentOp:</span><br><span class="line">key, ts, prevValPtr = t.Key, t.Timestamp, &amp;t.PrevValue</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCWriteIntentOp,</span><br><span class="line">*enginepb.MVCCUpdateIntentOp,</span><br><span class="line">*enginepb.MVCCAbortIntentOp,</span><br><span class="line">*enginepb.MVCCAbortTxnOp:</span><br><span class="line"><span class="comment">// Nothing to do.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unknown logical op %T&quot;</span>, t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// Don&#x27;t read previous values from the reader for operations that are</span></span><br><span class="line"><span class="comment">//// not needed by any rangefeed registration.</span></span><br><span class="line"><span class="comment">//if !filter.NeedPrevVal(roachpb.Span&#123;Key: key&#125;) &#123;</span></span><br><span class="line"><span class="comment">//continue</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the previous value from the prev Reader. Unlike the new value</span></span><br><span class="line"><span class="comment">// (see handleLogicalOpLogRaftMuLocked), this one may be missing.</span></span><br><span class="line"><span class="comment">//从raft中获取对应的befer value值，将其存储到Op中</span></span><br><span class="line">prevVal, _, err := engine.MVCCGet(</span><br><span class="line">ctx, prevReader, key, ts, engine.MVCCGetOptions&#123;Tombstones: <span class="literal">true</span>, Inconsistent: <span class="literal">true</span>&#125;,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">r.disconnectRangefeedWithErrRaftMuLocked(roachpb.NewErrorf(</span><br><span class="line"><span class="string">&quot;error consuming %T for key %v @ ts %v: %v&quot;</span>, op, key, ts, err,</span><br><span class="line">))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> prevVal != <span class="literal">nil</span> &#123;</span><br><span class="line">*prevValPtr = prevVal.RawBytes</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*prevValPtr = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// handleLogicalOpLogRaftMuLocked passes the logical op log to the active</span></span><br><span class="line"><span class="comment">// rangefeed, if one is running. The method accepts a reader, which is used to</span></span><br><span class="line"><span class="comment">// look up the values associated with key-value writes in the log before handing</span></span><br><span class="line"><span class="comment">// them to the rangefeed processor. No-op if a rangefeed is not active. Requires</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">handleLogicalOpLogRaftMuLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context, ops *storagepb.LogicalOpLog, reader engine.Reader,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.raftMu.rangefeed == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ops == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Rangefeeds can&#x27;t be turned on unless RangefeedEnabled is set to true,</span></span><br><span class="line"><span class="comment">// after which point new Raft proposals will include logical op logs.</span></span><br><span class="line"><span class="comment">// However, there&#x27;s a race present where old Raft commands without a</span></span><br><span class="line"><span class="comment">// logical op log might be passed to a rangefeed. Since the effect of</span></span><br><span class="line"><span class="comment">// these commands was not included in the catch-up scan of current</span></span><br><span class="line"><span class="comment">// registrations, we&#x27;re forced to throw an error. The rangefeed clients</span></span><br><span class="line"><span class="comment">// can reconnect at a later time, at which point all new Raft commands</span></span><br><span class="line"><span class="comment">// should have logical op logs.</span></span><br><span class="line">r.disconnectRangefeedWithReasonRaftMuLocked(</span><br><span class="line">roachpb.RangeFeedRetryError_REASON_LOGICAL_OPS_MISSING,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ops.Ops) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When reading straight from the Raft log, some logical ops will not be</span></span><br><span class="line"><span class="comment">// fully populated. Read from the Reader to populate all fields.</span></span><br><span class="line"><span class="keyword">for</span> _, op := <span class="keyword">range</span> ops.Ops &#123;</span><br><span class="line"><span class="keyword">var</span> key []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> ts hlc.Timestamp</span><br><span class="line"><span class="keyword">var</span> valPtr *[]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">switch</span> t := op.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCWriteValueOp:</span><br><span class="line">key, ts, valPtr = t.Key, t.Timestamp, &amp;t.Value</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCCommitIntentOp:</span><br><span class="line">key, ts, valPtr = t.Key, t.Timestamp, &amp;t.Value</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCWriteIntentOp,</span><br><span class="line">*enginepb.MVCCUpdateIntentOp,</span><br><span class="line">*enginepb.MVCCAbortIntentOp,</span><br><span class="line">*enginepb.MVCCAbortTxnOp:</span><br><span class="line"><span class="comment">// Nothing to do.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unknown logical op %T&quot;</span>, t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the value directly from the Reader. This is performed in the</span></span><br><span class="line"><span class="comment">// same raftMu critical section that the logical op&#x27;s corresponding</span></span><br><span class="line"><span class="comment">// WriteBatch is applied, so the value should exist.</span></span><br><span class="line">val, _, err := engine.MVCCGet(ctx, reader, key, ts, engine.MVCCGetOptions&#123;Tombstones: <span class="literal">true</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.New(<span class="string">&quot;value missing in reader&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">r.disconnectRangefeedWithErrRaftMuLocked(roachpb.NewErrorf(</span><br><span class="line"><span class="string">&quot;error consuming %T for key %v @ ts %v: %v&quot;</span>, op, key, ts, err,</span><br><span class="line">))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">*valPtr = val.RawBytes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass the ops to the rangefeed processor.</span></span><br><span class="line"><span class="comment">//将opts发送到对应的rangfeed进行处理</span></span><br><span class="line"><span class="keyword">if</span> !r.raftMu.rangefeed.ConsumeLogicalOps(ops.Ops...) &#123;</span><br><span class="line"><span class="comment">// Consumption failed and the rangefeed was stopped.</span></span><br><span class="line">r.resetRangefeedRaftMuLocked()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConsumeLogicalOps informs the rangefeed processor of the set of logical</span></span><br><span class="line"><span class="comment">// operations. It returns false if consuming the operations hit a timeout, as</span></span><br><span class="line"><span class="comment">// specified by the EventChanTimeout configuration. If the method returns false,</span></span><br><span class="line"><span class="comment">// the processor will have been stopped, so calling Stop is not necessary. Safe</span></span><br><span class="line"><span class="comment">// to call on nil Processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">ConsumeLogicalOps</span><span class="params">(ops ...enginepb.MVICLogicalOp)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ops) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将opts event 发送到对应的chan中进行处理</span></span><br><span class="line"><span class="keyword">return</span> p.sendEvent(event&#123;ops: ops&#125;, p.EventChanTimeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendEvent informs the Processor of a new event. If a timeout is specified,</span></span><br><span class="line"><span class="comment">// the method will wait for no longer than that duration before giving up,</span></span><br><span class="line"><span class="comment">// shutting down the Processor, and returning false. 0 for no timeout.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">sendEvent</span><span class="params">(e event, timeout time.Duration)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> timeout == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.eventC &lt;- e:</span><br><span class="line"><span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line"><span class="comment">// Already stopped. Do nothing.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.eventC &lt;- e:</span><br><span class="line"><span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line"><span class="comment">// Already stopped. Do nothing.</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.eventC &lt;- e:</span><br><span class="line"><span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line"><span class="comment">// Already stopped. Do nothing.</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line"><span class="comment">// Sending on the eventC channel would have blocked.</span></span><br><span class="line"><span class="comment">// Instead, tear down the processor and return immediately.</span></span><br><span class="line">p.sendStop(newErrBufferCapacityExceeded())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start launches a goroutine to process rangefeed events and send them to</span></span><br><span class="line"><span class="comment">// registrations.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The provided iterator is used to initialize the rangefeed&#x27;s resolved</span></span><br><span class="line"><span class="comment">// timestamp. It must obey the contract of an iterator used for an</span></span><br><span class="line"><span class="comment">// initResolvedTSScan. The Processor promises to clean up the iterator by</span></span><br><span class="line"><span class="comment">// calling its Close method when it is finished. If the iterator is nil then</span></span><br><span class="line"><span class="comment">// no initialization scan will be performed and the resolved timestamp will</span></span><br><span class="line"><span class="comment">// immediately be considered initialized.</span></span><br><span class="line"><span class="comment">//启动对应的RangeFeed Processor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">Start</span><span class="params">(stopper *stop.Stopper, rtsIter engine.SimpleIterator)</span></span> &#123;</span><br><span class="line">ctx := p.AnnotateCtx(context.Background())</span><br><span class="line">stopper.RunWorker(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(p.stoppedC)</span><br><span class="line">ctx, cancelOutputLoops := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancelOutputLoops()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Launch an async task to scan over the resolved timestamp iterator and</span></span><br><span class="line"><span class="comment">// initialize the unresolvedIntentQueue. Ignore error if quiescing.</span></span><br><span class="line"><span class="keyword">if</span> rtsIter != <span class="literal">nil</span> &#123;</span><br><span class="line">initScan := newInitResolvedTSScan(p, rtsIter)</span><br><span class="line">err := stopper.RunAsyncTask(ctx, <span class="string">&quot;rangefeed: init resolved ts&quot;</span>, initScan.Run)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">initScan.Cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p.initResolvedTS(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// txnPushTicker periodically pushes the transaction record of all</span></span><br><span class="line"><span class="comment">// unresolved intents that are above a certain age, helping to ensure</span></span><br><span class="line"><span class="comment">// that the resolved timestamp continues to make progress.</span></span><br><span class="line"><span class="keyword">var</span> txnPushTicker *time.Ticker</span><br><span class="line"><span class="keyword">var</span> txnPushTickerC &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line"><span class="keyword">var</span> txnPushAttemptC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> p.PushTxnsInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">txnPushTicker = time.NewTicker(p.PushTxnsInterval)</span><br><span class="line">txnPushTickerC = txnPushTicker.C</span><br><span class="line"><span class="keyword">defer</span> txnPushTicker.Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle new registrations.</span></span><br><span class="line"><span class="keyword">case</span> r := &lt;-p.regC:</span><br><span class="line"><span class="keyword">if</span> !p.Span.AsRawSpanWithNoLocals().Contains(r.span) &#123;</span><br><span class="line">log.Fatalf(ctx, <span class="string">&quot;registration %s not in Processor&#x27;s key range %v&quot;</span>, r, p.Span)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the new registration to the registry.</span></span><br><span class="line">p.reg.Register(&amp;r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Immediately publish a checkpoint event to the registry. This will be</span></span><br><span class="line"><span class="comment">// the first event published to this registration after its initial</span></span><br><span class="line"><span class="comment">// catch-up scan completes.</span></span><br><span class="line">r.publish(p.newCheckpointEvent())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run an output loop for the registry.</span></span><br><span class="line">runOutputLoop := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">r.runOutputLoop(ctx)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.unregC &lt;- &amp;r:</span><br><span class="line"><span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := stopper.RunAsyncTask(ctx, <span class="string">&quot;rangefeed: output loop&quot;</span>, runOutputLoop); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.catchupIter != <span class="literal">nil</span> &#123;</span><br><span class="line">r.catchupIter.Close() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br><span class="line">r.disconnect(roachpb.NewError(err))</span><br><span class="line">p.reg.Unregister(&amp;r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Respond to unregistration requests; these come from registrations that</span></span><br><span class="line"><span class="comment">// encounter an error during their output loop.</span></span><br><span class="line"><span class="keyword">case</span> r := &lt;-p.unregC:</span><br><span class="line">p.reg.Unregister(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Respond to answers about the processor goroutine state.</span></span><br><span class="line"><span class="keyword">case</span> &lt;-p.lenReqC:</span><br><span class="line">p.lenResC &lt;- p.reg.Len()</span><br><span class="line"><span class="comment">// Respond to answers about which operations can be filtered before</span></span><br><span class="line"><span class="comment">// reaching the Processor.</span></span><br><span class="line"><span class="keyword">case</span> &lt;-p.filterReqC:</span><br><span class="line">p.filterResC &lt;- p.reg.NewFilter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform and route events.</span></span><br><span class="line"><span class="comment">//消费对应的event并进行路由</span></span><br><span class="line"><span class="keyword">case</span> e := &lt;-p.eventC:</span><br><span class="line">p.consumeEvent(ctx, e)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether any unresolved intents need a push.</span></span><br><span class="line"><span class="keyword">case</span> &lt;-txnPushTickerC:</span><br><span class="line"><span class="comment">// Don&#x27;t perform transaction push attempts until the resolved</span></span><br><span class="line"><span class="comment">// timestamp has been initialized.</span></span><br><span class="line"><span class="keyword">if</span> !p.rts.IsInit() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">now := p.Clock.Now()</span><br><span class="line">before := now.Add(-p.PushTxnsAge.Nanoseconds(), <span class="number">0</span>)</span><br><span class="line">oldTxns := p.rts.intentQ.Before(before)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(oldTxns) &gt; <span class="number">0</span> &#123;</span><br><span class="line">toPush := <span class="built_in">make</span>([]enginepb.TxnMeta, <span class="built_in">len</span>(oldTxns))</span><br><span class="line"><span class="keyword">for</span> i, txn := <span class="keyword">range</span> oldTxns &#123;</span><br><span class="line">toPush[i] = txn.asTxnMeta()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the ticker channel to nil so that it can&#x27;t trigger a</span></span><br><span class="line"><span class="comment">// second concurrent push. Create a push attempt response</span></span><br><span class="line"><span class="comment">// channel that is closed when the push attempt completes.</span></span><br><span class="line">txnPushTickerC = <span class="literal">nil</span></span><br><span class="line">txnPushAttemptC = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Launch an async transaction push attempt that pushes the</span></span><br><span class="line"><span class="comment">// timestamp of all transactions beneath the push offset.</span></span><br><span class="line"><span class="comment">// Ignore error if quiescing.</span></span><br><span class="line">pushTxns := newTxnPushAttempt(p, toPush, now, txnPushAttemptC)</span><br><span class="line">err := stopper.RunAsyncTask(ctx, <span class="string">&quot;rangefeed: pushing old txns&quot;</span>, pushTxns.Run)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">pushTxns.Cancel()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the resolved timestamp based on the push attempt.</span></span><br><span class="line"><span class="keyword">case</span> &lt;-txnPushAttemptC:</span><br><span class="line"><span class="comment">// Reset the ticker channel so that it can trigger push attempts</span></span><br><span class="line"><span class="comment">// again. Set the push attempt channel back to nil.</span></span><br><span class="line">txnPushTickerC = txnPushTicker.C</span><br><span class="line">txnPushAttemptC = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Close registrations and exit when signaled.</span></span><br><span class="line"><span class="keyword">case</span> pErr := &lt;-p.stopC:</span><br><span class="line">p.reg.DisconnectWithErr(all, pErr)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit on stopper.</span></span><br><span class="line"><span class="keyword">case</span> &lt;-stopper.ShouldQuiesce():</span><br><span class="line">p.reg.Disconnect(all)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费opts event</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">consumeEvent</span><span class="params">(ctx context.Context, e event)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="built_in">len</span>(e.ops) &gt; <span class="number">0</span>:</span><br><span class="line">p.consumeLogicalOps(ctx, e.ops)</span><br><span class="line"><span class="keyword">case</span> e.ct != hlc.Timestamp&#123;&#125;:</span><br><span class="line">p.forwardClosedTS(ctx, e.ct)</span><br><span class="line"><span class="keyword">case</span> e.initRTS:</span><br><span class="line">p.initResolvedTS(ctx)</span><br><span class="line"><span class="keyword">case</span> e.syncC != <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">if</span> e.testRegCatchupSpan.Valid() &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.reg.waitForCaughtUp(e.testRegCatchupSpan); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Errorf(</span><br><span class="line">ctx,</span><br><span class="line"><span class="string">&quot;error waiting for registries to catch up during test, results might be impacted: %s&quot;</span>,</span><br><span class="line">err,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(e.syncC)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;missing event variant&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">consumeLogicalOps</span><span class="params">(ctx context.Context, ops []enginepb.MVICLogicalOp)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line"><span class="comment">// Publish RangeFeedValue updates, if necessary.</span></span><br><span class="line"><span class="keyword">switch</span> t := op.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCWriteValueOp:</span><br><span class="line"><span class="comment">// Publish the new value directly.</span></span><br><span class="line">p.publishValue(ctx, t.Key, t.Timestamp, t.Value, t.PrevValue)</span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCWriteIntentOp:</span><br><span class="line"><span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCUpdateIntentOp:</span><br><span class="line"><span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCCommitIntentOp:</span><br><span class="line"><span class="comment">// Publish the newly committed value.</span></span><br><span class="line">p.publishValue(ctx, t.Key, t.Timestamp, t.Value, t.PrevValue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCAbortIntentOp:</span><br><span class="line"><span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> *enginepb.MVCCAbortTxnOp:</span><br><span class="line"><span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unknown logical op %T&quot;</span>, t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine whether the operation caused the resolved timestamp to</span></span><br><span class="line"><span class="comment">// move forward. If so, publish a RangeFeedCheckpoint notification.</span></span><br><span class="line"><span class="keyword">if</span> p.rts.ConsumeLogicalOp(op) &#123;</span><br><span class="line">p.publishCheckpoint(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register registers the stream over the specified span of keys.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The registration will not observe any events that were consumed before this</span></span><br><span class="line"><span class="comment">// method was called. It is undefined whether the registration will observe</span></span><br><span class="line"><span class="comment">// events that are consumed concurrently with this call. The channel will be</span></span><br><span class="line"><span class="comment">// provided an error when the registration closes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The optionally provided &quot;catch-up&quot; iterator is used to read changes from the</span></span><br><span class="line"><span class="comment">// engine which occurred after the provided start timestamp.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// NOT safe to call on nil Processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">Register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">span roachpb.RSpan,</span></span></span><br><span class="line"><span class="function"><span class="params">startTS hlc.Timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">catchupIter engine.SimpleIterator,</span></span></span><br><span class="line"><span class="function"><span class="params">withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">stream Stream,</span></span></span><br><span class="line"><span class="function"><span class="params">errC <span class="keyword">chan</span>&lt;- *roachpb.Error,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="comment">// Synchronize the event channel so that this registration doesn&#x27;t see any</span></span><br><span class="line"><span class="comment">// events that were consumed before this registration was called. Instead,</span></span><br><span class="line"><span class="comment">// it should see these events during its catch up scan.</span></span><br><span class="line">p.syncEventC()</span><br><span class="line"></span><br><span class="line">r := newRegistration(</span><br><span class="line">span.AsRawSpanWithNoLocals(), startTS, catchupIter, withDiff,</span><br><span class="line">p.Config.EventChanCap, p.Metrics, stream, errC,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.regC &lt;- r:</span><br><span class="line"><span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line"><span class="keyword">if</span> catchupIter != <span class="literal">nil</span> &#123;</span><br><span class="line">catchupIter.Close() <span class="comment">// clean up</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// errC has a capacity of 1. If it is already full, we don&#x27;t need to send</span></span><br><span class="line"><span class="comment">// another error.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> errC &lt;- roachpb.NewErrorf(<span class="string">&quot;rangefeed processor closed&quot;</span>):</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed registers a rangefeed over the specified span. It sends updates to</span></span><br><span class="line"><span class="comment">// the provided stream and returns with an optional error when the rangefeed is</span></span><br><span class="line"><span class="comment">// complete. The provided ConcurrentRequestLimiter is used to limit the number</span></span><br><span class="line"><span class="comment">// of rangefeeds using catchup iterators at the same time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">roachpb</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !RangefeedEnabled.Get(&amp;r.store.cfg.Settings.SV) &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewErrorf(<span class="string">&quot;rangefeeds require the kv.rangefeed.enabled setting. See &quot;</span> +</span><br><span class="line">base.DocsURL(<span class="string">`change-data-capture.html#enable-rangefeeds-to-reduce-latency`</span>))</span><br><span class="line">&#125;</span><br><span class="line">ctx := r.AnnotateCtx(stream.Context())</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rSpan roachpb.RSpan</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">rSpan.Key, err = keys.Addr(args.Span.Key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line">rSpan.EndKey, err = keys.Addr(args.Span.EndKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := r.ensureClosedTimestampStarted(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the RangeFeed is performing a catch-up scan then it will observe all</span></span><br><span class="line"><span class="comment">// values above args.Timestamp. If the RangeFeed is requesting previous</span></span><br><span class="line"><span class="comment">// values for every update then it will also need to look for the version</span></span><br><span class="line"><span class="comment">// proceeding each value observed during the catch-up scan timestamp. This</span></span><br><span class="line"><span class="comment">// means that the earliest value observed by the catch-up scan will be</span></span><br><span class="line"><span class="comment">// args.Timestamp.Next and the earliest timestamp used to retrieve the</span></span><br><span class="line"><span class="comment">// previous version of a value will be args.Timestamp, so this is the</span></span><br><span class="line"><span class="comment">// timestamp we must check against the GCThreshold.</span></span><br><span class="line">checkTS := args.Timestamp</span><br><span class="line"><span class="keyword">if</span> checkTS.IsEmpty() &#123;</span><br><span class="line"><span class="comment">// If no timestamp was provided then we&#x27;re not going to run a catch-up</span></span><br><span class="line"><span class="comment">// scan, so make sure the GCThreshold in requestCanProceed succeeds.</span></span><br><span class="line">checkTS = r.Clock().Now()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lockedStream := &amp;lockedRangefeedStream&#123;wrapped: stream&#125;</span><br><span class="line">errC := <span class="built_in">make</span>(<span class="keyword">chan</span> *roachpb.Error, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we will be using a catch-up iterator, wait for the limiter here before</span></span><br><span class="line"><span class="comment">// locking raftMu.</span></span><br><span class="line">usingCatchupIter := <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> iterSemRelease <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">if</span> !args.Timestamp.IsEmpty() &#123;</span><br><span class="line">usingCatchupIter = <span class="literal">true</span></span><br><span class="line">lim := &amp;r.store.limiters.ConcurrentRangefeedIters</span><br><span class="line"><span class="keyword">if</span> err := lim.Begin(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Finish the iterator limit, but only if we exit before</span></span><br><span class="line"><span class="comment">// creating the iterator itself.</span></span><br><span class="line">iterSemRelease = lim.Finish</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> iterSemRelease != <span class="literal">nil</span> &#123;</span><br><span class="line">iterSemRelease()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lock the raftMu, then register the stream as a new rangefeed registration.</span></span><br><span class="line"><span class="comment">// raftMu is held so that the catch-up iterator is captured in the same</span></span><br><span class="line"><span class="comment">// critical-section as the registration is established. This ensures that</span></span><br><span class="line"><span class="comment">// the registration doesn&#x27;t miss any events.</span></span><br><span class="line">r.raftMu.Lock()</span><br><span class="line"><span class="keyword">if</span> err := r.checkExecutionCanProceedForRangeFeed(rSpan, checkTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">r.raftMu.Unlock()</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure that the rangefeed processor is running.</span></span><br><span class="line"><span class="comment">//注册对应RangeFeed Processor</span></span><br><span class="line">p := r.maybeInitRangefeedRaftMuLocked(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the stream with a catch-up iterator.</span></span><br><span class="line"><span class="keyword">var</span> catchUpIter engine.SimpleIterator</span><br><span class="line"><span class="keyword">if</span> usingCatchupIter &#123;</span><br><span class="line">innerIter := r.Engine().NewIterator(engine.IterOptions&#123;</span><br><span class="line">UpperBound: args.Span.EndKey,</span><br><span class="line"><span class="comment">// RangeFeed originally intended to use the time-bound iterator</span></span><br><span class="line"><span class="comment">// performance optimization. However, they&#x27;ve had correctness issues in</span></span><br><span class="line"><span class="comment">// the past (#28358, #34819) and no-one has the time for the due-diligence</span></span><br><span class="line"><span class="comment">// necessary to be confidant in their correctness going forward. Not using</span></span><br><span class="line"><span class="comment">// them causes the total time spent in RangeFeed catchup on changefeed</span></span><br><span class="line"><span class="comment">// over tpcc-1000 to go from 40s -&gt; 4853s, which is quite large but still</span></span><br><span class="line"><span class="comment">// workable. See #35122 for details.</span></span><br><span class="line"><span class="comment">// MinTimestampHint: args.Timestamp,</span></span><br><span class="line">&#125;)</span><br><span class="line">catchUpIter = iteratorWithCloser&#123;</span><br><span class="line">SimpleIterator: innerIter,</span><br><span class="line"><span class="built_in">close</span>:          iterSemRelease,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Responsibility for releasing the semaphore now passes to the iterator.</span></span><br><span class="line">iterSemRelease = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注册一个registration,该registration为订阅特定范围内数据更新的示例，并通过outputLoop进行数据的流式传输</span></span><br><span class="line">p.Register(rSpan, args.Timestamp, catchUpIter, args.WithDiff, lockedStream, errC)</span><br><span class="line">r.raftMu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// When this function returns, attempt to clean up the rangefeed.</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r.raftMu.Lock()</span><br><span class="line">r.maybeDestroyRangefeedRaftMuLocked(p)</span><br><span class="line">r.raftMu.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block on the registration&#x27;s error channel. Note that the registration</span></span><br><span class="line"><span class="comment">// observes stream.Context().Done.</span></span><br><span class="line"><span class="keyword">return</span> &lt;-errC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outputLoop is the operational loop for a single registration. The behavior</span></span><br><span class="line"><span class="comment">// is as thus:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. If a catch-up scan is indicated, run one before beginning the proper</span></span><br><span class="line"><span class="comment">// output loop.</span></span><br><span class="line"><span class="comment">// 2. After catch-up is complete, begin reading from the registration buffer</span></span><br><span class="line"><span class="comment">// channel and writing to the output stream until the buffer is empty *and*</span></span><br><span class="line"><span class="comment">// the overflow flag has been set.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The loop exits with any error encountered, if the provided context is</span></span><br><span class="line"><span class="comment">// canceled, or when the buffer has overflowed and all pre-overflow entries</span></span><br><span class="line"><span class="comment">// have been emitted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registration)</span> <span class="title">outputLoop</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// If the registration has a catch-up scan,</span></span><br><span class="line"><span class="keyword">if</span> r.catchupIter != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.runCatchupScan(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = errors.Wrap(err, <span class="string">&quot;catch-up scan failed&quot;</span>)</span><br><span class="line">log.Error(ctx, err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normal buffered output loop.</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">overflowed := <span class="literal">false</span></span><br><span class="line">r.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(r.buf) == <span class="number">0</span> &#123;</span><br><span class="line">overflowed = r.mu.overflowed</span><br><span class="line">r.mu.caughtUp = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">r.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> overflowed &#123;</span><br><span class="line"><span class="keyword">return</span> newErrBufferCapacityExceeded().GoError()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> nextEvent := &lt;-r.buf:</span><br><span class="line"><span class="keyword">if</span> err := r.stream.Send(nextEvent); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> &lt;-r.stream.Context().Done():</span><br><span class="line"><span class="keyword">return</span> r.stream.Context().Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed registers a rangefeed over the specified span. It sends updates to</span></span><br><span class="line"><span class="comment">// the provided stream and returns with an optional error when the rangefeed is</span></span><br><span class="line"><span class="comment">// complete.</span></span><br><span class="line"><span class="comment">//store 上的RangeFeed接口，下发到指定Range上开启RangeFeed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">roachpb</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := verifyKeys(args.Span.Key, args.Span.EndKey, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get range and add command to the range for execution.</span></span><br><span class="line">repl, err := s.GetReplica(args.RangeID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !repl.IsInitialized() &#123;</span><br><span class="line">repl.mu.RLock()</span><br><span class="line">replicaID := repl.mu.replicaID</span><br><span class="line">repl.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we have an uninitialized copy of the range, then we are</span></span><br><span class="line"><span class="comment">// probably a valid member of the range, we&#x27;re just in the</span></span><br><span class="line"><span class="comment">// process of getting our snapshot. If we returned</span></span><br><span class="line"><span class="comment">// RangeNotFoundError, the client would invalidate its cache,</span></span><br><span class="line"><span class="comment">// but we can be smarter: the replica that caused our</span></span><br><span class="line"><span class="comment">// uninitialized replica to be created is most likely the</span></span><br><span class="line"><span class="comment">// leader.</span></span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(&amp;roachpb.NotLeaseHolderError&#123;</span><br><span class="line">RangeID:     args.RangeID,</span><br><span class="line">LeaseHolder: repl.creatingReplica,</span><br><span class="line"><span class="comment">// The replica doesn&#x27;t have a range descriptor yet, so we have to build</span></span><br><span class="line"><span class="comment">// a ReplicaDescriptor manually.</span></span><br><span class="line">Replica: roachpb.ReplicaDescriptor&#123;</span><br><span class="line">NodeID:    repl.store.nodeDesc.NodeID,</span><br><span class="line">StoreID:   repl.store.StoreID(),</span><br><span class="line">ReplicaID: replicaID,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> repl.RangeFeed(args, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed registers a rangefeed over the specified span. It sends updates to</span></span><br><span class="line"><span class="comment">// the provided stream and returns with an optional error when the rangefeed is</span></span><br><span class="line"><span class="comment">// complete.</span></span><br><span class="line"><span class="comment">//Stores级别的RangeFeed接口，将RangeFeed请求下发到对应的Store上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ls *Stores)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">roachpb</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">ctx := stream.Context()</span><br><span class="line"><span class="keyword">if</span> args.RangeID == <span class="number">0</span> &#123;</span><br><span class="line">log.Fatal(ctx, <span class="string">&quot;rangefeed request missing range ID&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Replica.StoreID == <span class="number">0</span> &#123;</span><br><span class="line">log.Fatal(ctx, <span class="string">&quot;rangefeed request missing store ID&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store, err := ls.GetStore(args.Replica.StoreID)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> store.RangeFeed(args, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed implements the roachpb.InternalServer interface.</span></span><br><span class="line"><span class="comment">//Node对应的RangeFeed接口，将请求下发到Stores</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">pErr := n.stores.RangeFeed(args, stream)</span><br><span class="line"><span class="keyword">if</span> pErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> event roachpb.RangeFeedEvent</span><br><span class="line">event.SetValue(&amp;roachpb.RangeFeedError&#123;</span><br><span class="line">Error: *pErr,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> stream.Send(&amp;event)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//grpc server RangeFeed接口，通过InternalClient调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a internalClientAdapter)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context, args *roachpb.RangeFeedRequest, _ ...grpc.CallOption,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(roachpb.Internal_RangeFeedClient, error)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">rfAdapter := rangeFeedClientAdapter&#123;</span><br><span class="line">ctx:    ctx,</span><br><span class="line">eventC: <span class="built_in">make</span>(<span class="keyword">chan</span> *roachpb.RangeFeedEvent, <span class="number">128</span>),</span><br><span class="line">errC:   <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">err := a.InternalServer.RangeFeed(args, rfAdapter)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">err = io.EOF</span><br><span class="line">&#125;</span><br><span class="line">rfAdapter.errC &lt;- err</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rfAdapter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// singleRangeFeed gathers and rearranges the replicas, and makes a RangeFeed</span></span><br><span class="line"><span class="comment">// RPC call. Results will be send on the provided channel. Returns the timestamp</span></span><br><span class="line"><span class="comment">// of the maximum rangefeed checkpoint seen, which can be used to re-establish</span></span><br><span class="line"><span class="comment">// the rangefeed with a larger starting timestamp, reflecting the fact that all</span></span><br><span class="line"><span class="comment">// values up to the last checkpoint have already been observed. Returns the</span></span><br><span class="line"><span class="comment">// request&#x27;s timestamp if not checkpoints are seen.</span></span><br><span class="line"><span class="comment">//分发层对应的RangeFeed接口，生成对应的GRPC请求。将RangeFeed请求下发到对应节点的对应store上的对应replica</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *DistSender)</span> <span class="title">singleRangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">span roachpb.Span,</span></span></span><br><span class="line"><span class="function"><span class="params">ts hlc.Timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">desc *roachpb.RangeDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">eventCh <span class="keyword">chan</span>&lt;- *roachpb.RangeFeedEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(hlc.Timestamp, *roachpb.Error)</span></span> &#123;</span><br><span class="line">args := roachpb.RangeFeedRequest&#123;</span><br><span class="line">Span: span,</span><br><span class="line">Header: roachpb.Header&#123;</span><br><span class="line">Timestamp: ts,</span><br><span class="line">RangeID:   desc.RangeID,</span><br><span class="line">&#125;,</span><br><span class="line">WithDiff: withDiff,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> latencyFn LatencyFunc</span><br><span class="line"><span class="keyword">if</span> ds.rpcContext != <span class="literal">nil</span> &#123;</span><br><span class="line">latencyFn = ds.rpcContext.RemoteClocks.Latency</span><br><span class="line">&#125;</span><br><span class="line">replicas := NewReplicaSlice(ds.gossip, desc)</span><br><span class="line"><span class="comment">//对于replicas进行排序</span></span><br><span class="line">replicas.OptimizeReplicaOrder(ds.getNodeDescriptor(), latencyFn)</span><br><span class="line"></span><br><span class="line">transport, err := ds.transportFactory(SendOptions&#123;&#125;, ds.nodeDialer, replicas)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> args.Timestamp, roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> transport.IsExhausted() &#123;</span><br><span class="line"><span class="keyword">return</span> args.Timestamp, roachpb.NewError(roachpb.NewSendError(</span><br><span class="line">fmt.Sprintf(<span class="string">&quot;sending to all %d replicas failed&quot;</span>, <span class="built_in">len</span>(replicas)),</span><br><span class="line">))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">args.Replica = transport.NextReplica()</span><br><span class="line">clientCtx, client, err := transport.NextInternalClient(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.VErrEventf(ctx, <span class="number">2</span>, <span class="string">&quot;RPC error: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用对应的GRPC接口发送RangeFeed请求</span></span><br><span class="line">stream, err := client.RangeFeed(clientCtx, &amp;args)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.VErrEventf(ctx, <span class="number">2</span>, <span class="string">&quot;RPC error: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">event, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> args.Timestamp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> args.Timestamp, roachpb.NewError(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> t := event.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *roachpb.RangeFeedCheckpoint:</span><br><span class="line"><span class="keyword">if</span> t.Span.Contains(args.Span) &#123;</span><br><span class="line">args.Timestamp.Forward(t.ResolvedTS)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> *roachpb.RangeFeedError:</span><br><span class="line">log.VErrEventf(ctx, <span class="number">2</span>, <span class="string">&quot;RangeFeedError: %s&quot;</span>, t.Error.GoError())</span><br><span class="line"><span class="keyword">return</span> args.Timestamp, &amp;t.Error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> eventCh &lt;- event:</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> args.Timestamp, roachpb.NewError(ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// partialRangeFeed establishes a RangeFeed to the range specified by desc. It</span></span><br><span class="line"><span class="comment">// manages lifecycle events of the range in order to maintain the RangeFeed</span></span><br><span class="line"><span class="comment">// connection; this may involve instructing higher-level functions to retry</span></span><br><span class="line"><span class="comment">// this rangefeed, or subdividing the range further in the event of a split.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *DistSender)</span> <span class="title">partialRangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">rangeInfo *singleRangeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">rangeCh <span class="keyword">chan</span>&lt;- singleRangeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">eventCh <span class="keyword">chan</span>&lt;- *roachpb.RangeFeedEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Bound the partial rangefeed to the partial span.</span></span><br><span class="line">span := rangeInfo.rs.AsRawSpanWithNoLocals()</span><br><span class="line">ts := rangeInfo.ts</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start a retry loop for sending the batch to the range.</span></span><br><span class="line"><span class="keyword">for</span> r := retry.StartWithCtx(ctx, ds.rpcRetryOptions); r.Next(); &#123;</span><br><span class="line"><span class="comment">// If we&#x27;ve cleared the descriptor on a send failure, re-lookup.</span></span><br><span class="line"><span class="keyword">if</span> rangeInfo.desc == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line">rangeInfo.desc, rangeInfo.token, err = ds.getDescriptor(ctx, rangeInfo.rs.Key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.VErrEventf(ctx, <span class="number">1</span>, <span class="string">&quot;range descriptor re-lookup failed: %s&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Establish a RangeFeed for a single Range.</span></span><br><span class="line">maxTS, pErr := ds.singleRangeFeed(ctx, span, ts, withDiff, rangeInfo.desc, eventCh)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Forward the timestamp in case we end up sending it again.</span></span><br><span class="line">ts.Forward(maxTS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pErr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> log.V(<span class="number">1</span>) &#123;</span><br><span class="line">log.Infof(ctx, <span class="string">&quot;RangeFeed %s disconnected with last checkpoint %s ago: %v&quot;</span>,</span><br><span class="line">span, timeutil.Since(ts.GoTime()), pErr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> t := pErr.GetDetail().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *roachpb.SendError, *roachpb.RangeNotFoundError:</span><br><span class="line"><span class="comment">// Evict the decriptor from the cache and reload on next attempt.</span></span><br><span class="line"><span class="keyword">if</span> err := rangeInfo.token.Evict(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">rangeInfo.desc = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> *roachpb.RangeKeyMismatchError:</span><br><span class="line"><span class="comment">// Evict the decriptor from the cache.</span></span><br><span class="line"><span class="keyword">if</span> err := rangeInfo.token.Evict(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出现range key范围不匹配时对RangeFeed重新进行划分并发送到各个Range上，</span></span><br><span class="line"><span class="keyword">return</span> ds.divideAndSendRangeFeedToRanges(ctx, rangeInfo.rs, ts, rangeCh)</span><br><span class="line"><span class="keyword">case</span> *roachpb.RangeFeedRetryError:</span><br><span class="line"><span class="keyword">switch</span> t.Reason &#123;</span><br><span class="line"><span class="keyword">case</span> roachpb.RangeFeedRetryError_REASON_REPLICA_REMOVED,</span><br><span class="line">roachpb.RangeFeedRetryError_REASON_RAFT_SNAPSHOT,</span><br><span class="line">roachpb.RangeFeedRetryError_REASON_LOGICAL_OPS_MISSING,</span><br><span class="line">roachpb.RangeFeedRetryError_REASON_SLOW_CONSUMER:</span><br><span class="line"><span class="comment">// Try again with same descriptor. These are transient</span></span><br><span class="line"><span class="comment">// errors that should not show up again.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> roachpb.RangeFeedRetryError_REASON_RANGE_SPLIT,</span><br><span class="line">roachpb.RangeFeedRetryError_REASON_RANGE_MERGED:</span><br><span class="line"><span class="comment">// Evict the decriptor from the cache.</span></span><br><span class="line"><span class="keyword">if</span> err := rangeInfo.token.Evict(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出现range split或者merged 对RangeFeed重新进行划分并发送到各个Range上，</span></span><br><span class="line"><span class="keyword">return</span> ds.divideAndSendRangeFeedToRanges(ctx, rangeInfo.rs, ts, rangeCh)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Fatalf(ctx, <span class="string">&quot;unexpected RangeFeedRetryError reason %v&quot;</span>, t.Reason)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DistSender 对应的RangeFeed接口</span></span><br><span class="line"><span class="comment">// RangeFeed divides a RangeFeed request on range boundaries and establishes a</span></span><br><span class="line"><span class="comment">// RangeFeed to each of the individual ranges. It streams back results on the</span></span><br><span class="line"><span class="comment">// provided channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *DistSender)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">args *roachpb.RangeFeedRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">eventCh <span class="keyword">chan</span>&lt;- *roachpb.RangeFeedEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ctx = ds.AnnotateCtx(ctx)</span><br><span class="line">ctx, sp := tracing.EnsureChildSpan(ctx, ds.AmbientContext.Tracer, <span class="string">&quot;dist sender&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> sp.Finish()</span><br><span class="line"></span><br><span class="line">startRKey, err := keys.Addr(args.Span.Key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">endRKey, err := keys.Addr(args.Span.EndKey)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">rs := roachpb.RSpan&#123;Key: startRKey, EndKey: endRKey&#125;</span><br><span class="line"></span><br><span class="line">g := ctxgroup.WithContext(ctx)</span><br><span class="line"><span class="comment">// Goroutine that processes subdivided ranges and creates a rangefeed for</span></span><br><span class="line"><span class="comment">// each.</span></span><br><span class="line">rangeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> singleRangeInfo, <span class="number">16</span>)</span><br><span class="line">g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> sri := &lt;-rangeCh:</span><br><span class="line"><span class="comment">// Spawn a child goroutine to process this feed.</span></span><br><span class="line">g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ds.partialRangeFeed(ctx, &amp;sri, withDiff, rangeCh, eventCh)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kick off the initial set of ranges.</span></span><br><span class="line">g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ds.divideAndSendRangeFeedToRanges(ctx, rs, args.Timestamp, rangeCh)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> g.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要负责rangfeed接口调用以及rangfeed推出数据的处理，回填处理等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span> <span class="title">rangefeedImplIter</span><span class="params">(ctx context.Context, i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Determine whether to request the previous value of each update from</span></span><br><span class="line"><span class="comment">// RangeFeed based on whether the `diff` option is specified.</span></span><br><span class="line">_, withDiff := p.details.Opts[optDiff]</span><br><span class="line"></span><br><span class="line">p.mu.Lock()</span><br><span class="line">lastHighwater := p.mu.highWater</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> err := p.tableHist.WaitForTS(ctx, lastHighwater); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spans, err := getSpansToProcess(ctx, p.db, p.spans)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform a full scan if necessary - either an initial scan or a backfill</span></span><br><span class="line"><span class="comment">// Full scans are still performed using an Export operation.</span></span><br><span class="line">initialScan := i == <span class="number">0</span></span><br><span class="line">backfillWithDiff := !initialScan &amp;&amp; withDiff</span><br><span class="line"><span class="keyword">var</span> scanTime hlc.Timestamp</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p.mu.scanBoundaries) &gt; <span class="number">0</span> &amp;&amp; p.mu.scanBoundaries[<span class="number">0</span>].Equal(p.mu.highWater) &#123;</span><br><span class="line"><span class="comment">// Perform a full scan of the latest value of all keys as of the</span></span><br><span class="line"><span class="comment">// boundary timestamp and consume the boundary.</span></span><br><span class="line">scanTime = p.mu.scanBoundaries[<span class="number">0</span>]</span><br><span class="line">p.mu.scanBoundaries = p.mu.scanBoundaries[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> scanTime != (hlc.Timestamp&#123;&#125;) &#123;</span><br><span class="line"><span class="comment">// TODO(dan): Now that we no longer have the poller, we should stop using</span></span><br><span class="line"><span class="comment">// ExportRequest and start using normal Scans.</span></span><br><span class="line"><span class="keyword">if</span> err := p.exportSpansParallel(ctx, spans, scanTime, backfillWithDiff); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Start rangefeeds, exit polling if we hit a resolved timestamp beyond</span></span><br><span class="line"><span class="comment">// the next scan boundary.</span></span><br><span class="line"><span class="comment">// TODO(nvanbenschoten): This is horrible.</span></span><br><span class="line">sender := p.db.NonTransactionalSender()</span><br><span class="line">ds := sender.(*client.CrossRangeTxnWrapperSender).Wrapped().(*kv.DistSender)</span><br><span class="line">g := ctxgroup.WithContext(ctx)</span><br><span class="line">eventC := <span class="built_in">make</span>(<span class="keyword">chan</span> *roachpb.RangeFeedEvent, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// To avoid blocking raft, RangeFeed puts all entries in a server side</span></span><br><span class="line"><span class="comment">// buffer. But to keep things simple, it&#x27;s a small fixed-sized buffer. This</span></span><br><span class="line"><span class="comment">// means we need to ingest everything we get back as quickly as possible, so</span></span><br><span class="line"><span class="comment">// we throw it in a buffer here to pick up the slack between RangeFeed and</span></span><br><span class="line"><span class="comment">// the sink.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// TODO(dan): Right now, there are two buffers in the changefeed flow when</span></span><br><span class="line"><span class="comment">// using RangeFeeds, one here and the usual one between the poller and the</span></span><br><span class="line"><span class="comment">// rest of the changefeed (he latter of which is implemented with an</span></span><br><span class="line"><span class="comment">// unbuffered channel, and so doesn&#x27;t actually buffer). Ideally, we&#x27;d have</span></span><br><span class="line"><span class="comment">// one, but the structure of the poller code right now makes this hard.</span></span><br><span class="line"><span class="comment">// Specifically, when a schema change happens, we need a barrier where we</span></span><br><span class="line"><span class="comment">// flush out every change before the schema change timestamp before we start</span></span><br><span class="line"><span class="comment">// emitting any changes from after the schema change. The poller&#x27;s</span></span><br><span class="line"><span class="comment">// `tableHist` is responsible for detecting and enforcing these (they queue</span></span><br><span class="line"><span class="comment">// up in `p.scanBoundaries`), but the after-poller buffer doesn&#x27;t have</span></span><br><span class="line"><span class="comment">// access to any of this state. A cleanup is in order.</span></span><br><span class="line">memBuf := makeMemBuffer(p.mm.MakeBoundAccount(), p.metrics)</span><br><span class="line"><span class="keyword">defer</span> memBuf.Close(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maintain a local spanfrontier to tell when all the component rangefeeds</span></span><br><span class="line"><span class="comment">// being watched have reached the Scan boundary.</span></span><br><span class="line"><span class="comment">// TODO(mrtracy): The alternative to this would be to maintain two</span></span><br><span class="line"><span class="comment">// goroutines for each span (the current arrangement is one goroutine per</span></span><br><span class="line"><span class="comment">// span and one multiplexing goroutine that outputs to the buffer). This</span></span><br><span class="line"><span class="comment">// alternative would allow us to stop the individual rangefeeds earlier and</span></span><br><span class="line"><span class="comment">// avoid the need for a span frontier, but would also introduce a different</span></span><br><span class="line"><span class="comment">// contention pattern and use additional goroutines. it&#x27;s not clear which</span></span><br><span class="line"><span class="comment">// solution is best without targeted performance testing, so we&#x27;re choosing</span></span><br><span class="line"><span class="comment">// the faster-to-implement solution for now.</span></span><br><span class="line">frontier := makeSpanFrontier(spans...)</span><br><span class="line"></span><br><span class="line">rangeFeedStartTS := lastHighwater</span><br><span class="line"><span class="keyword">for</span> _, span := <span class="keyword">range</span> p.spans &#123;</span><br><span class="line">req := &amp;roachpb.RangeFeedRequest&#123;</span><br><span class="line">Header: roachpb.Header&#123;</span><br><span class="line">Timestamp: lastHighwater,</span><br><span class="line">&#125;,</span><br><span class="line">Span: span,</span><br><span class="line">&#125;</span><br><span class="line">frontier.Forward(span, rangeFeedStartTS)</span><br><span class="line">g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">//调用分发层对应的RangeFeed接口</span></span><br><span class="line"><span class="keyword">return</span> ds.RangeFeed(ctx, req, withDiff, eventC)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e := &lt;-eventC:</span><br><span class="line"><span class="keyword">switch</span> t := e.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *roachpb.RangeFeedValue:</span><br><span class="line">kv := roachpb.KeyValue&#123;Key: t.Key, Value: t.Value&#125;</span><br><span class="line"><span class="keyword">var</span> prevVal roachpb.Value</span><br><span class="line"><span class="keyword">if</span> withDiff &#123;</span><br><span class="line">prevVal = t.PrevValue</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将变更信息填充到memBuf中以供接下来进行消费</span></span><br><span class="line"><span class="keyword">if</span> err := memBuf.AddKV(ctx, kv, prevVal, hlc.Timestamp&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> *roachpb.RangeFeedCheckpoint:</span><br><span class="line"><span class="keyword">if</span> !t.ResolvedTS.IsEmpty() &amp;&amp; t.ResolvedTS.Less(rangeFeedStartTS) &#123;</span><br><span class="line"><span class="comment">// RangeFeed happily forwards any closed timestamps it receives as</span></span><br><span class="line"><span class="comment">// soon as there are no outstanding intents under them.</span></span><br><span class="line"><span class="comment">// Changefeeds don&#x27;t care about these at all, so throw them out.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := memBuf.AddResolved(ctx, t.Span, t.ResolvedTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">log.Fatalf(ctx, <span class="string">&quot;unexpected RangeFeedEvent variant %v&quot;</span>, t)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//进行变更信息的消费</span></span><br><span class="line">g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">e, err := memBuf.Get(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> e.kv.Key != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.tableHist.WaitForTS(ctx, e.kv.Value.Timestamp); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">pastBoundary := <span class="literal">false</span></span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p.mu.scanBoundaries) &gt; <span class="number">0</span> &amp;&amp; p.mu.scanBoundaries[<span class="number">0</span>].Less(e.kv.Value.Timestamp) &#123;</span><br><span class="line"><span class="comment">// Ignore feed results beyond the next boundary; they will be retrieved when</span></span><br><span class="line"><span class="comment">// the feeds are restarted after the scan.</span></span><br><span class="line">pastBoundary = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> pastBoundary &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := p.buf.AddKV(ctx, e.kv, e.prevVal, e.schemaTimestamp, hlc.Timestamp&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e.resolved != <span class="literal">nil</span> &#123;</span><br><span class="line">resolvedTS := e.resolved.Timestamp</span><br><span class="line">boundaryBreak := <span class="literal">false</span></span><br><span class="line"><span class="comment">// Make sure scan boundaries less than or equal to `resolvedTS` were</span></span><br><span class="line"><span class="comment">// added to the `scanBoundaries` list before proceeding.</span></span><br><span class="line"><span class="keyword">if</span> err := p.tableHist.WaitForTS(ctx, resolvedTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(p.mu.scanBoundaries) &gt; <span class="number">0</span> &amp;&amp; !resolvedTS.Less(p.mu.scanBoundaries[<span class="number">0</span>]) &#123;</span><br><span class="line">boundaryBreak = <span class="literal">true</span></span><br><span class="line">resolvedTS = p.mu.scanBoundaries[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> boundaryBreak &#123;</span><br><span class="line"><span class="comment">// A boundary here means we&#x27;re about to do a full scan (backfill)</span></span><br><span class="line"><span class="comment">// at this timestamp, so at the changefeed level the boundary</span></span><br><span class="line"><span class="comment">// itself is not resolved. Skip emitting this resolved timestamp</span></span><br><span class="line"><span class="comment">// because we want to trigger the scan first before resolving its</span></span><br><span class="line"><span class="comment">// scan boundary timestamp.</span></span><br><span class="line">resolvedTS = resolvedTS.Prev()</span><br><span class="line">frontier.Forward(e.resolved.Span, resolvedTS)</span><br><span class="line"><span class="keyword">if</span> frontier.Frontier() == resolvedTS &#123;</span><br><span class="line"><span class="comment">// All component rangefeeds are now at the boundary.</span></span><br><span class="line"><span class="comment">// Break out of the ctxgroup by returning a sentinel error.</span></span><br><span class="line"><span class="keyword">return</span> errBoundaryReached</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.buf.AddResolved(ctx, e.resolved.Span, resolvedTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// TODO(mrtracy): We are currently tearing down the entire rangefeed set in</span></span><br><span class="line"><span class="comment">// order to perform a scan; however, given that we have an intermediate</span></span><br><span class="line"><span class="comment">// buffer, its seems that we could do this without having to destroy and</span></span><br><span class="line"><span class="comment">// recreate the rangefeeds.</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &amp;&amp; err != errBoundaryReached &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">p.mu.Lock()</span><br><span class="line">p.mu.highWater = p.mu.scanBoundaries[<span class="number">0</span>]</span><br><span class="line">p.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CDC-DDL捕获设计文档"><a href="#CDC-DDL捕获设计文档" class="headerlink" title="CDC DDL捕获设计文档"></a>CDC DDL捕获设计文档</h1><h2 id="Online-Schema-Change分析"><a href="#Online-Schema-Change分析" class="headerlink" title="Online Schema Change分析"></a>Online Schema Change分析</h2><p>关系型数据库中数据以表为单位存储，读写操作依赖表的模式(Schema)和数据(Data)。DDL 通常需要同时修改模式和数据，为了避免并发问题，早期的数据库实现会在 DDL 过程中禁止目标表上的读写操作（简称锁表）。锁表保证了对模式和数据的修改是原子操作。但某些 DDL 操作涉及复制数据（比如索引构建）执行时间可能在几分钟甚至数小时。OLTP 数据库中长时间锁表会对业务产生不可预知的影响，生产环境中不可接受，因此“能够与读写操作并行执行”是 OLTP 用户对 DDL 的核心需求，也是 Online Schema Change 要解决的问题。</p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分布式数据库通常是一个集群，出于性能考虑，每个节点需要缓存一份 Schema。如果继续采用单机数据库的 DDL 流程，则需要通过分布式锁来保证加载新版本 Schema 过程中没有读写操作进行，代价极高，并且当集群内节点不能够互相感知时将变为无法完成的任务。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/distribute.jpg" alt="distribute.jpg"></p><p>讨论解决方案之前，以 CREATE INDEX 为例，看看集群节点使用不同版本 Schema 执行读写操作，带来的具体问题。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/progrems.jpg" alt="progrems.jpg"><br>上图展示的是一个存储计算分离架构的分布式数据库，集群由 CN(计算节点) 和 DN(存储节点) 构成，每个 CN 中缓存一份 Schema。由于 CN0 和 CN1 异步加载 Schema，添加索引过程中可能存在一个时刻，CN0 认为有索引而 CN1 认为没有，此时产生两种异常</p><p>索引上有多余数据(Orphan Data Anomaly): CN0 执行了 INSERT，在表和索引上插入数据，随后 CN1 执行 DELETE。由于 CN1 认为没有索引，仅删除了表上的数据<br>索引上缺少数据(Integrity Anomaly): CN1 执行 INSERT，由于 CN1 认为没有索引，仅在表上插入数据，没有写相关的增量日志，导致索引创建完成后缺少这次 INSERT 的数据<br>可以看到，如果同一时刻存在两个 Schema 版本的情况无法避免，继续沿用单机数据库一步完成 Schema 版本切换的方案，会导致数据问题。那么如果“一步”切换不可行，“多步”能否解决问题？VLDB 2013 上 Google 工程师给出了一种新的 Schema Change 流程，通过增加两个中间状态来解决这个问题[7]。</p><h3 id="F1-Online-Schema-Change"><a href="#F1-Online-Schema-Change" class="headerlink" title="F1 Online Schema Change"></a>F1 Online Schema Change</h3><p>Google F1 的方案引入了两个中间状态，delete_only 状态的对象上仅执行删除操作，write_only 状态的对象上支持写入，但不允许读取。依然以 CREATE INDEX 为例</p><p>解决 Orphan Data Anomaly：CN0 认为索引处于 delete_only 状态，仅在表上插入数据，CN1 认为没有索引，仅在表上删除数据。最终索引和表上都没有 id = 0 的数据<br>解决 Integrity Anomaly：CN1 认为索引处于 delete_only 状态，仅在表上插入数据，没有写相关的增量日志，但由于还有节点没有更新到 V2 版本，数据回填没有开始。当所有节点都更新 V2 版本后，数据回填操作会在索引中填入这一条数据<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/f1-online-schema-change.jpg" alt="f1-online-schema-change.jpg"><br>以上两个具体场景为例，说明了方案的有效性。</p><h4 id="Google-F1-的方案，包含两个关键点："><a href="#Google-F1-的方案，包含两个关键点：" class="headerlink" title="Google F1 的方案，包含两个关键点："></a>Google F1 的方案，包含两个关键点：</h4><ul><li><p>增加两个中间状态(delete_only，write_only)，允许集群中的事务同时使用至多两个最近的元数据版本</p></li><li><p>增加租约(lease)的概念，保证在一个租约周期内，没有拿到最新版本 Schema 的节点，无法提交事务</p></li></ul><p>第一个关键点，将保证 Schema Change 正确性的条件，从“只能有一个版本”，降低为“最多可以有两个版本”。第二个关键点，给出了 F1 系统“保证最多两个版本”的实现思路。<br>简单来说，Google F1 的方案，成功将问题“在分布式数据库系统上实现 Online Schema Change”转化为“设计一种保证系统中最多有两个 Schema 版本的协议”，并且给出了一种基于租约的协议实现。<br>协议内容可以概括为，以租约周期作为时间单位，协调了三个操作的节奏</p><ul><li>Schema 刷新的间隔：每个节点需要在租约过期前，获取一次最新版本 Schema，如果无法获取，则主动退出，由托管服务重新拉起</li><li>DDL 的最小时长：每次更新 Schema 版本后，需要等待一个租约周期，保证所有节点都读到最新版本的元数据</li><li>事务的最大时长：执行时间超过一个租约周期的事务将被回滚，确保事务仅使用了一个 Schema 版本<br>原始版本的协议十分简洁，易于描述和验证，但由于将 DDL 执行的最小时长和事务执行的最大时长绑定在一起，使用体验上与单机数据库有区别。对此，业界也给出了多种改进方案，比如：</li></ul><h4 id="CockroachDB-重新设计了-schema-lease-8-，在两方面做出改进："><a href="#CockroachDB-重新设计了-schema-lease-8-，在两方面做出改进：" class="headerlink" title="CockroachDB 重新设计了 schema lease[8] ，在两方面做出改进："></a>CockroachDB 重新设计了 schema lease[8] ，在两方面做出改进：</h4><ul><li>降低 DDL 执行的最小时长：通过在事务开始时获取一个包含版本信息的租约，事务结束时释放，使得更新 Schema 版本后能够立即确认旧版本是否还在被使用，仅在有长事务或者节点异常（比如网络断开）时才需要等满一个租约周期。由于通过在存储中插入记录来获取租约，会增加事务的执行耗时。</li><li>只在 DDL 执行过程中限制事务的最大时长：具体做法是，使用 Schema 版本变更开始的时间作为边界，产生一个 [Tv,Tv+2) 的时间窗口。起始时间在窗口内，结束时间在窗口外的事务将被回滚。如果有 DDL 正在执行，则窗口最大为两个租约周期。如果没有 DDL 执行，则不存在 v+2 版本，可以认为是一个无限大的窗口[Tv,+∞)</li></ul><h2 id="CDC-DDL捕获原理"><a href="#CDC-DDL捕获原理" class="headerlink" title="CDC DDL捕获原理"></a>CDC DDL捕获原理</h2><p>总的来说，CDC DDL捕获设计与DML捕获的基本原理类似。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc-seq.png" alt="cdc-seq.png"></p><h3 id="CDC-DDL数据来源"><a href="#CDC-DDL数据来源" class="headerlink" title="CDC DDL数据来源"></a>CDC DDL数据来源</h3><p>首先，DDL捕获开启一个特殊的changeAggregator，该changeAggregator主要负责监控一个特殊的表-<em><strong>system.descriptor</strong></em>,如上述对于Online Schema Change的分析，一次Schema Change包含多不操作，也即对应的 <em><strong>system.descriptor</strong></em> 具有多次变更记录。而对于CDC DDL捕获功能来说，目前仅需要实际设置为 <em><strong>public</strong></em>  状态的变更记录。因此对 <em><strong>system.descriptor</strong></em> 触发出的数据进行相关处理操作。</p><h3 id="CDC-DDL-DML顺序问题解决"><a href="#CDC-DDL-DML顺序问题解决" class="headerlink" title="CDC DDL DML顺序问题解决"></a>CDC DDL DML顺序问题解决</h3><p>![cdc ddl.png](<a href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc">https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc</a> ddl.png)</p><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><ul><li><p>DDL阻塞条件<br>resolvedTS &lt; lastDMLTransactionCommitTime</p></li><li><p>DDL放出条件<br>resolvedTS &gt;= lastDMLTransactionCommitTime</p></li><li><p><em>变量解释：</em>*</p><ol><li>resolvedTS<br>变量含义：该表对应的已解析时间戳<br>更新位置：该表DML已经不再发送将该表对应的span标志为resolvedSpan</li><li>lastDMLTransactionCommitTime<br>变量含义：DML事务提交时间<br>更新位置：DML成功发送后，更新DML事务提交时间</li></ol></li></ul><h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><ul><li><p>DML需写入临时文件条件</p><p>  lastDDLSendTime &lt; changefeedDesc.ModificationTime</p></li><li><p>DML直接发送条件</p><p>  lastDDLSendTime &gt;= changefeedDesc.ModificationTime<br>  <strong>变量解释：</strong></p><ol><li>lastDDLSendTime<br>变量含义：DDL上次发送对应的表的ModifyTime<br>更新位置：DDL成功发送后，更新lastDDLSendTime为ModifyTime</li><li>changefeedDesc.ModificationTime<br>变量含义：该次DML对应的ModificationTime</li></ol></li></ul><h3 id="DDL-amp-DML-Model"><a href="#DDL-amp-DML-Model" class="headerlink" title="DDL&amp;DML Model"></a>DDL&amp;DML Model</h3><p>   代表俩个模式，分别负责DDL发送与DML发送。</p><ol><li>处于DDL Model:每次发送DDL后，读取临时文件，如果临时文件中的DML满足DML直接发送条件，则切换为DML Model。</li><li>处于DML Model:DML更新resolvedTS后，如果满足DDL直接发送条件，则切换为DDL Model。<h1 id="CDC-具有外键约束表数据顺序捕获分析"><a href="#CDC-具有外键约束表数据顺序捕获分析" class="headerlink" title="CDC 具有外键约束表数据顺序捕获分析"></a>CDC 具有外键约束表数据顺序捕获分析</h1></li></ol><h2 id="具有外键约束表的数据变更特点"><a href="#具有外键约束表的数据变更特点" class="headerlink" title="具有外键约束表的数据变更特点"></a>具有外键约束表的数据变更特点</h2><ul><li>数据变更为同一事务</li><li>主从表数据需要顺序发送</li></ul><h2 id="具有外键约束表的数据变更捕获方案"><a href="#具有外键约束表的数据变更捕获方案" class="headerlink" title="具有外键约束表的数据变更捕获方案"></a>具有外键约束表的数据变更捕获方案</h2><p>总的来说就是进行排序操作，按照事务的时间戳ts进行重组。然后主表先入从表后入</p><p>主要问题为：</p><ul><li>基于目前的CDC体系在数据库内部进行排序以及事务重组操作将会特别消耗数据库资源，再未进行排序时，开启CDC大概会消耗5%~15%左右的数据库性能，如果这些操作在内部进行处理时，会导致更大的性能消耗</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为ZNbase 本身使用的是混合逻辑时钟，所以两个不重叠事务的时间戳可能会相同，但是混合逻辑时钟具有纳秒级的精度。这个概率较小。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Sakura</title>
      <link href="posts/22338.html"/>
      <url>posts/22338.html</url>
      
        <content type="html"><![CDATA[<p>hexo-theme-sakura主题 <a href="https://github.com/honjun/hexo-theme-sakura/blob/master/README.md">English document</a></p><p>基于WordPress主题<a href="https://github.com/mashirozx/Sakura/">Sakura</a>修改成Hexo的主题。</p><p><a href="https://sakura.hojun.cn/">demo预览</a></p><p>正在开发中……</p><p><img src= "/img/loading.gif" data-lazy-src="https://wx3.sinaimg.cn/large/006bYVyvly1g069tuf42oj312w0m8ndq.jpg"></p><h2 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h2><p>若你是使用者，加群QQ: 801511924</p><p>若你是创作者，加群QQ: 194472590</p><h2 id="主题特性"><a href="#主题特性" class="headerlink" title="主题特性"></a>主题特性</h2><ul><li>首页大屏视频</li><li>首页随机封面</li><li>图片懒加载</li><li>valine评论</li><li>fancy-box相册</li><li>pjax支持，音乐不间断</li><li>aplayer音乐播放器</li><li>多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了）</li></ul><h2 id="赞赏作者"><a href="#赞赏作者" class="headerlink" title="赞赏作者"></a>赞赏作者</h2><p>如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！</p><p><a href="https://www.paypal.me/hojuncn">paypal</a> | <a href="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/AliPayQR.jpg">Alipay 支付宝</a> | <a href="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/donate/WeChanSQ.jpg">WeChat Pay 微信支付</a></p><h2 id="未完善的使用教程"><a href="#未完善的使用教程" class="headerlink" title="未完善的使用教程"></a>未完善的使用教程</h2><p>那啥？老实说我目前也不是很有条理233333333~</p><h2 id="1、主题下载安装"><a href="#1、主题下载安装" class="headerlink" title="1、主题下载安装"></a>1、主题下载安装</h2><p><a href="https://github.com/honjun/hexo-theme-sakura">hexo-theme-sakura</a>建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。</p><p>下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行<code>npm i</code>安装依赖。</p><h2 id="2、主题配置"><a href="#2、主题配置" class="headerlink" title="2、主题配置"></a>2、主题配置</h2><h3 id="博客根目录下的-config配置"><a href="#博客根目录下的-config配置" class="headerlink" title="博客根目录下的_config配置"></a>博客根目录下的_config配置</h3><p>站点</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">你的站点名</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">站点简介</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-cn</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">    <span class="attr">github:</span> <span class="string">你的github仓库地址</span></span><br><span class="line">    <span class="comment"># coding: 你的coding仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>备份 （使用hexo b发布备份到远程仓库）</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">backup:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">backup</span> <span class="string">my</span> <span class="string">blog</span> <span class="string">of</span> <span class="string">https://honjun.github.io/</span></span><br><span class="line">  <span class="attr">repository:</span></span><br><span class="line">    <span class="comment"># 你的github仓库地址,备份分支名  （建议新建backup分支）</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://github.com/honjun/honjun.github.io.git,backup</span></span><br><span class="line">    <span class="comment"># coding: https://git.coding.net/hojun/hojun.git,backup</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主题目录下的-config配置"><a href="#主题目录下的-config配置" class="headerlink" title="主题目录下的_config配置"></a>主题目录下的_config配置</h3><p>其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># site name</span></span><br><span class="line"><span class="comment"># 站点名 【改】</span></span><br><span class="line"><span class="attr">prefixName:</span> <span class="string">さくら荘その</span></span><br><span class="line"><span class="attr">siteName:</span> <span class="string">hojun</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># favicon and site master avatar</span></span><br><span class="line"><span class="comment"># 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/images/favicon.ico</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/img/custom/avatar.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点url 【改】</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://sakura.hojun.cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点介绍（或者说是个人签名）【改】</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Live</span> <span class="string">your</span> <span class="string">life</span> <span class="string">with</span> <span class="string">passion!</span> <span class="string">With</span> <span class="string">some</span> <span class="string">drive!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点cdn，没有就为空 【改】  若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg</span></span><br><span class="line"><span class="attr">cdn:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/cdn@1.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启pjax 【选】</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点首页的公告信息 【改】</span></span><br><span class="line"><span class="attr">notice:</span> <span class="string">hexo-Sakura主题已经开源，目前正在开发中...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 懒加载的加载中图片 【选】</span></span><br><span class="line"><span class="attr">lazyloadImg:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点菜单配置 【选】</span></span><br><span class="line"><span class="attr">menus:</span></span><br><span class="line">  <span class="string">首页:</span> &#123; <span class="attr">path:</span> <span class="string">/</span>, <span class="attr">fa:</span> <span class="string">fa-fort-awesome</span> <span class="string">faa-shake</span> &#125;</span><br><span class="line">  <span class="string">归档:</span> &#123; <span class="attr">path:</span> <span class="string">/archives</span>, <span class="attr">fa:</span> <span class="string">fa-archive</span> <span class="string">faa-shake</span>, <span class="attr">submenus:</span> &#123; </span><br><span class="line">    <span class="string">技术:</span> &#123;<span class="attr">path:</span> <span class="string">/categories/技术/</span>, <span class="attr">fa:</span> <span class="string">fa-code</span> &#125;, </span><br><span class="line">    <span class="string">生活:</span> &#123;<span class="attr">path:</span> <span class="string">/categories/生活/</span>, <span class="attr">fa:</span> <span class="string">fa-file-text-o</span> &#125;, </span><br><span class="line">    <span class="string">资源:</span> &#123;<span class="attr">path:</span> <span class="string">/categories/资源/</span>, <span class="attr">fa:</span> <span class="string">fa-cloud-download</span> &#125;, </span><br><span class="line">    <span class="string">随想:</span> &#123;<span class="attr">path:</span> <span class="string">/categories/随想/</span>, <span class="attr">fa:</span> <span class="string">fa-commenting-o</span> &#125;,</span><br><span class="line">    <span class="string">转载:</span> &#123;<span class="attr">path:</span> <span class="string">/categories/转载/</span>, <span class="attr">fa:</span> <span class="string">fa-book</span> &#125;</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  <span class="string">清单:</span> &#123; <span class="attr">path:</span> <span class="string">javascript:;</span>, <span class="attr">fa:</span> <span class="string">fa-list-ul</span> <span class="string">faa-vertical</span>, <span class="attr">submenus:</span> &#123; </span><br><span class="line">    <span class="string">书单:</span> &#123;<span class="attr">path:</span> <span class="string">/tags/悦读/</span>, <span class="attr">fa:</span> <span class="string">fa-th-list</span> <span class="string">faa-bounce</span> &#125;, </span><br><span class="line">    <span class="string">番组:</span> &#123;<span class="attr">path:</span> <span class="string">/bangumi/</span>, <span class="attr">fa:</span> <span class="string">fa-film</span> <span class="string">faa-vertical</span> &#125;, </span><br><span class="line">    <span class="string">歌单:</span> &#123;<span class="attr">path:</span> <span class="string">/music/</span>, <span class="attr">fa:</span> <span class="string">fa-headphones</span> &#125;,</span><br><span class="line">    <span class="string">图集:</span> &#123;<span class="attr">path:</span> <span class="string">/tags/图集/</span>, <span class="attr">fa:</span> <span class="string">fa-photo</span> &#125;</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  <span class="string">留言板:</span> &#123; <span class="attr">path:</span> <span class="string">/comment/</span>, <span class="attr">fa:</span> <span class="string">fa-pencil-square-o</span> <span class="string">faa-tada</span> &#125;</span><br><span class="line">  <span class="string">友人帐:</span> &#123; <span class="attr">path:</span> <span class="string">/links/</span>, <span class="attr">fa:</span> <span class="string">fa-link</span> <span class="string">faa-shake</span> &#125;</span><br><span class="line">  <span class="string">赞赏:</span> &#123; <span class="attr">path:</span> <span class="string">/donate/</span>, <span class="attr">fa:</span> <span class="string">fa-heart</span> <span class="string">faa-pulse</span> &#125;</span><br><span class="line">  <span class="string">关于:</span> &#123; <span class="attr">path:</span> <span class="string">/</span>, <span class="attr">fa:</span> <span class="string">fa-leaf</span> <span class="string">faa-wrench</span> , <span class="attr">submenus:</span> &#123; </span><br><span class="line">    <span class="string">我？:</span> &#123;<span class="attr">path:</span> <span class="string">/about/</span>, <span class="attr">fa:</span> <span class="string">fa-meetup</span>&#125;, </span><br><span class="line">    <span class="string">主题:</span> &#123;<span class="attr">path:</span> <span class="string">/theme-sakura/</span>, <span class="attr">fa:</span> <span class="string">iconfont</span> <span class="string">icon-sakura</span> &#125;,</span><br><span class="line">    <span class="attr">Lab:</span> &#123;<span class="attr">path:</span> <span class="string">/lab/</span>, <span class="attr">fa:</span> <span class="string">fa-cogs</span> &#125;,</span><br><span class="line">  &#125; &#125;</span><br><span class="line">  <span class="string">客户端:</span> &#123; <span class="attr">path:</span> <span class="string">/client/</span>, <span class="attr">fa:</span> <span class="string">fa-android</span> <span class="string">faa-vertical</span> &#125;</span><br><span class="line">  <span class="attr">RSS:</span> &#123; <span class="attr">path:</span> <span class="string">/atom.xml</span>, <span class="attr">fa:</span> <span class="string">fa-rss</span> <span class="string">faa-pulse</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page sort type: -1: newer first，1: older first. 【非】</span></span><br><span class="line"><span class="attr">homePageSortType:</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Home page article shown number) 【非】</span></span><br><span class="line"><span class="attr">homeArticleShown:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 背景图片 【选】</span></span><br><span class="line"><span class="attr">bgn:</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># startdash面板 url, title, desc img 【改】</span></span><br><span class="line"><span class="attr">startdash:</span> </span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">url:</span> <span class="string">/theme-sakura/</span>, <span class="attr">title:</span> <span class="string">Sakura</span>, <span class="attr">desc:</span> <span class="string">本站</span> <span class="string">hexo</span> <span class="string">主题</span>, <span class="attr">img:</span> <span class="string">/img/startdash/sakura.md.png</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">url:</span> <span class="string">http://space.bilibili.com/271849279</span>, <span class="attr">title:</span> <span class="string">Bilibili</span>, <span class="attr">desc:</span> <span class="string">博主的b站视频</span>, <span class="attr">img:</span> <span class="string">/img/startdash/bilibili.jpg</span>&#125;</span><br><span class="line">  <span class="bullet">-</span> &#123;<span class="attr">url:</span> <span class="string">/</span>, <span class="attr">title:</span> <span class="string">hojun的万事屋</span>, <span class="attr">desc:</span> <span class="string">技术服务</span>, <span class="attr">img:</span> <span class="string">/img/startdash/wangshiwu.jpg</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># your site build time or founded date</span></span><br><span class="line"><span class="comment"># 你的站点建立日期 【改】</span></span><br><span class="line"><span class="attr">siteBuildingTime:</span> <span class="number">07</span><span class="string">/17/2018</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 社交按钮(social)  url, img PC端配置 【改】</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">github:</span> &#123;<span class="attr">url:</span> <span class="string">http://github.com/honjun</span>, <span class="attr">img:</span> <span class="string">/img/social/github.png</span>&#125;</span><br><span class="line">  <span class="attr">sina:</span> &#123;<span class="attr">url:</span> <span class="string">http://weibo.com/mashirozx?is_all=1</span>, <span class="attr">img:</span> <span class="string">/img/social/sina.png</span>&#125;</span><br><span class="line">  <span class="attr">wangyiyun:</span> &#123;<span class="attr">url:</span> <span class="string">http://weibo.com/mashirozx?is_all=1</span>, <span class="attr">img:</span> <span class="string">/img/social/wangyiyun.png</span>&#125;</span><br><span class="line">  <span class="attr">zhihu:</span> &#123;<span class="attr">url:</span> <span class="string">http://weibo.com/mashirozx?is_all=1</span>, <span class="attr">img:</span> <span class="string">/img/social/zhihu.png</span>&#125;</span><br><span class="line">  <span class="attr">email:</span> &#123;<span class="attr">url:</span> <span class="string">http://weibo.com/mashirozx?is_all=1</span>, <span class="attr">img:</span> <span class="string">/img/social/email.svg</span>&#125;</span><br><span class="line">  <span class="attr">wechat:</span> &#123;<span class="attr">url:</span> <span class="string">/#</span>, <span class="attr">qrcode:</span> <span class="string">/img/custom/wechat.jpg</span>, <span class="attr">img:</span> <span class="string">/img/social/wechat.png</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 社交按钮(msocial)  url, img 移动端配置 【改】</span></span><br><span class="line"><span class="attr">msocial:</span></span><br><span class="line">  <span class="attr">github:</span> &#123;<span class="attr">url:</span> <span class="string">http://github.com/honjun</span>, <span class="attr">fa:</span> <span class="string">fa-github</span>, <span class="attr">color:</span> <span class="number">333</span>&#125;</span><br><span class="line">  <span class="attr">weibo:</span> &#123;<span class="attr">url:</span> <span class="string">http://weibo.com/mashirozx?is_all=1</span>, <span class="attr">fa:</span> <span class="string">fa-weibo</span>, <span class="attr">color:</span> <span class="string">dd4b39</span>&#125;</span><br><span class="line">  <span class="attr">qq:</span> &#123;<span class="attr">url:</span> <span class="string">https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes</span>, <span class="attr">fa:</span> <span class="string">fa-qq</span>, <span class="attr">color:</span> <span class="string">25c6fe</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】</span></span><br><span class="line"><span class="attr">donate:</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/img/custom/donate/AliPayQR.jpg</span></span><br><span class="line">  <span class="attr">wechat:</span> <span class="string">/img/custom/donate/WeChanQR.jpg</span></span><br><span class="line">  <span class="attr">wechatSQ:</span> <span class="string">/img/custom/donate/WeChanSQ.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】</span></span><br><span class="line"><span class="attr">movies:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/hojun@1.2</span></span><br><span class="line">  <span class="comment"># 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Unbroken.mp4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】</span></span><br><span class="line"><span class="attr">aplayer:</span> </span><br><span class="line">  <span class="attr">id:</span> <span class="number">2660651585</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">netease</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">playlist</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mini:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">autoplay:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">order:</span> <span class="string">random</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">volume:</span> <span class="number">0.7</span></span><br><span class="line">  <span class="attr">mutex:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine评论配置【改】</span></span><br><span class="line"><span class="attr">valine:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">v_appId:</span> <span class="string">GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz</span></span><br><span class="line"><span class="attr">v_appKey:</span> <span class="string">mgOpfzbkHYqU92CV4IDlAUHQ</span></span><br></pre></td></tr></table></figure><h2 id="分类页和标签页配置"><a href="#分类页和标签页配置" class="headerlink" title="分类页和标签页配置"></a>分类页和标签页配置</h2><h3 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h3><p><img src= "/img/loading.gif" data-lazy-src="https://ws3.sinaimg.cn/large/006bYVyvly1g07b0gucy9j31060jih76.jpg"></p><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><p><img src= "/img/loading.gif" data-lazy-src="https://wx2.sinaimg.cn/large/006bYVyvly1g07azb2399j31040jgazs.jpg"></p><p>配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#category</span></span><br><span class="line"><span class="comment"># 按分类名创建</span></span><br><span class="line"><span class="string">技术:</span></span><br><span class="line">    <span class="comment">#中文标题</span></span><br><span class="line">    <span class="attr">zh:</span> <span class="string">野生技术协会</span> </span><br><span class="line">    <span class="comment"># 英文标题</span></span><br><span class="line">    <span class="attr">en:</span> <span class="string">Geek</span> <span class="string">–</span> <span class="string">Only</span> <span class="string">for</span> <span class="string">Love</span></span><br><span class="line">    <span class="comment"># 封面图片</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg</span></span><br><span class="line"><span class="string">生活:</span></span><br><span class="line">    <span class="attr">zh:</span> <span class="string">生活</span></span><br><span class="line">    <span class="attr">en:</span> <span class="string">live</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tag</span></span><br><span class="line"><span class="comment"># 标签名即是标题</span></span><br><span class="line"><span class="string">悦读:</span></span><br><span class="line">    <span class="comment"># 封面图片</span></span><br><span class="line">    <span class="attr">img:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg</span></span><br></pre></td></tr></table></figure><h2 id="单页面封面配置"><a href="#单页面封面配置" class="headerlink" title="单页面封面配置"></a>单页面封面配置</h2><p><img src= "/img/loading.gif" data-lazy-src="https://ws3.sinaimg.cn/large/006bYVyvly1g07b1pi619j31080jge4u.jpg"><br>如留言板页面页面，位于source下的comment下，打开index.md如下：</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: comment</span><br><span class="line">date: 2018-12-20 23:13:48</span><br><span class="line">keywords: 留言板</span><br><span class="line">description: </span><br><span class="line">comments: true</span><br><span class="line"><span class="section"># 在这里配置单页面头部图片，自定义替换哦~</span></span><br><span class="line">photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="单页面配置"><a href="#单页面配置" class="headerlink" title="单页面配置"></a>单页面配置</h2><h3 id="番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"><a href="#番组计划页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）" class="headerlink" title="番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"></a>番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://wx2.sinaimg.cn/large/006bYVyvly1g07b2gyx60j31090jjahj.jpg"></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">bangumi</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">bangumi</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-02-10 21:32:48</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">description:</span></span><br><span class="line"><span class="attr">bangumis:</span></span><br><span class="line">  <span class="comment"># 番组图片</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg</span></span><br><span class="line">  <span class="comment"># 番组名</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">朝花夕誓——于离别之朝束起约定之花</span></span><br><span class="line">  <span class="comment"># 追番状态 （追番ing/已追完）</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">已追完</span></span><br><span class="line">  <span class="comment"># 追番进度</span></span><br><span class="line">    <span class="attr">progress:</span> <span class="number">100</span></span><br><span class="line">  <span class="comment"># 番剧日文名称</span></span><br><span class="line">    <span class="attr">jp:</span> <span class="string">さよならの朝に約束の花をかざろう</span></span><br><span class="line">  <span class="comment"># 放送时间</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">放送时间:</span> <span class="number">2018-02-24 </span><span class="string">SUN.</span></span><br><span class="line">  <span class="comment"># 番剧介绍</span></span><br><span class="line">    <span class="attr">desc:</span>  <span class="string">住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">朝花夕誓——于离别之朝束起约定之花</span></span><br><span class="line">    <span class="attr">status:</span> <span class="string">已追完</span></span><br><span class="line">    <span class="attr">progress:</span> <span class="number">50</span></span><br><span class="line">    <span class="attr">jp:</span> <span class="string">さよならの朝に約束の花をかざろう</span></span><br><span class="line">    <span class="attr">time:</span> <span class="string">放送时间:</span> <span class="number">2018-02-24 </span><span class="string">SUN.</span></span><br><span class="line">    <span class="attr">desc:</span> <span class="string">住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"><a href="#友链页-（请直接在下载后的文件中改，下面的添加了注释可能会有些影响）" class="headerlink" title="友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）"></a>友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://ws3.sinaimg.cn/large/006bYVyvly1g07b39tleej31080jhjv1.jpg"></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">links</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">links</span></span><br><span class="line"><span class="comment"># 创建日期，可以改下</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-12-19 23:11:06</span> </span><br><span class="line"><span class="comment"># 图片上的标题，自定义修改</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">友人帐</span> </span><br><span class="line"><span class="attr">description:</span> </span><br><span class="line"><span class="comment"># true/false 开启/关闭评论</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span> </span><br><span class="line"><span class="comment"># 页面头部图片，自定义修改</span></span><br><span class="line"><span class="attr">photos:</span> <span class="string">https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg</span> </span><br><span class="line"><span class="comment"># 友链配置</span></span><br><span class="line"><span class="attr">links:</span> </span><br><span class="line">  <span class="comment"># 类型分组</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">group:</span> <span class="string">个人项目</span></span><br><span class="line">    <span class="comment"># 类型简介</span></span><br><span class="line">    <span class="attr">desc:</span> <span class="string">充分说明这家伙是条咸鱼</span> <span class="string">&lt;</span> <span class="string">(￣︶￣)&gt;</span></span><br><span class="line">    <span class="attr">items:</span></span><br><span class="line">    <span class="comment"># 友链链接</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">https://shino.cc/fgvf</span></span><br><span class="line">    <span class="comment"># 友链头像</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cloud.moezx.cc/Picture/svg/landscape/fields.svg</span></span><br><span class="line">    <span class="comment"># 友链站点名</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Google</span></span><br><span class="line">    <span class="comment"># 友链介绍  下面雷同</span></span><br><span class="line">      <span class="attr">desc:</span> <span class="string">Google</span> <span class="string">镜像</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">https://shino.cc/fgvf</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cloud.moezx.cc/Picture/svg/landscape/fields.svg</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Google</span></span><br><span class="line">      <span class="attr">desc:</span> <span class="string">Google</span> <span class="string">镜像</span></span><br><span class="line">  <span class="comment"># 类型分组...</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">group:</span> <span class="string">小伙伴们</span></span><br><span class="line">    <span class="attr">desc:</span> <span class="string">欢迎交换友链</span> <span class="string">ꉂ(ˊᗜˋ)</span></span><br><span class="line">    <span class="attr">items:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">https://shino.cc/fgvf</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cloud.moezx.cc/Picture/svg/landscape/fields.svg</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Google</span></span><br><span class="line">      <span class="attr">desc:</span> <span class="string">Google</span> <span class="string">镜像</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">url:</span> <span class="string">https://shino.cc/fgvf</span></span><br><span class="line">      <span class="attr">img:</span> <span class="string">https://cloud.moezx.cc/Picture/svg/landscape/fields.svg</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Google</span></span><br><span class="line">      <span class="attr">desc:</span> <span class="string">Google</span> <span class="string">镜像</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="写文章配置"><a href="#写文章配置" class="headerlink" title="写文章配置"></a>写文章配置</h2><p>主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下：</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% bili video<span class="emphasis">_id [page] %&#125;</span></span><br></pre></td></tr></table></figure><p>详细使用教程详见<a href="https://github.com/honjun/hexo-tag-bili/blob/master/README-zh_cn.md">hexo-tag-bili</a>。</p><p>hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下：</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% fb<span class="emphasis">_img src [caption] %&#125;</span></span><br></pre></td></tr></table></figure><p>详细使用教程详见<a href="https://github.com/honjun/hexo-tag-fancybox_img/blob/master/README-zh_cn.md">hexo-tag-fancybox_img</a></p><h2 id="还有啥，一时想不起来……"><a href="#还有啥，一时想不起来……" class="headerlink" title="还有啥，一时想不起来……"></a>还有啥，一时想不起来……</h2><p>To be continued…</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 悦读 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
