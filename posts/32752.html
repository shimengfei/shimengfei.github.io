<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>CDC_Architecture_Analysis | 飞飞 ❤️ 晨晨</title><meta name="author" content="shimengfei"><meta name="copyright" content="shimengfei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="CDC整体架构分析CDC 概览 CDC流程图  Range Feed原理分析RangeFeed数据来源下图中的步骤③当raft group leader 将raft log apply到状态机时，将raftCommand中对应的数据变更publish出来RangeFeed捕获变更数据流程Feed结构分析![cdc ca.png.png](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;sh">
<meta property="og:type" content="article">
<meta property="og:title" content="CDC_Architecture_Analysis">
<meta property="og:url" content="https://shimengfei.github.io/posts/32752.html">
<meta property="og:site_name" content="飞飞 ❤️ 晨晨">
<meta property="og:description" content="CDC整体架构分析CDC 概览 CDC流程图  Range Feed原理分析RangeFeed数据来源下图中的步骤③当raft group leader 将raft log apply到状态机时，将raftCommand中对应的数据变更publish出来RangeFeed捕获变更数据流程Feed结构分析![cdc ca.png.png](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;sh">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/8.png">
<meta property="article:published_time" content="2021-03-08T12:45:35.000Z">
<meta property="article:modified_time" content="2023-12-19T15:08:23.641Z">
<meta property="article:author" content="shimengfei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/8.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/(0).jpg.webp"><link rel="canonical" href="https://shimengfei.github.io/posts/32752"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?ad46175d21aa084eb0fe1012619fd025";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: shimengfei","link":"链接: ","source":"来源: 飞飞 ❤️ 晨晨","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-19 23:08:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/(0).jpg.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/8.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">飞飞 ❤️ 晨晨</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CDC_Architecture_Analysis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-08T12:45:35.000Z" title="发表于 2021-03-08 20:45:35">2021-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-19T15:08:23.641Z" title="更新于 2023-12-19 23:08:23">2023-12-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/32752.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/32752.html" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="CDC整体架构分析"><a href="#CDC整体架构分析" class="headerlink" title="CDC整体架构分析"></a>CDC整体架构分析</h2><h3 id="CDC-概览"><a href="#CDC-概览" class="headerlink" title="CDC 概览"></a>CDC 概览</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc-overview.png" alt="cdc-overview.png"></p>
<h3 id="CDC流程图"><a href="#CDC流程图" class="headerlink" title="CDC流程图"></a>CDC流程图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc-seq.png" alt="cdc-seq.png"></p>
<hr>
<h3 id="Range-Feed原理分析"><a href="#Range-Feed原理分析" class="headerlink" title="Range Feed原理分析"></a>Range Feed原理分析</h3><p><strong>RangeFeed数据来源</strong><br>下图中的步骤③当raft group leader 将raft log apply到状态机时，将raftCommand中对应的数据变更publish出来<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/raft.png" alt="raft.png"><br><strong>RangeFeed捕获变更数据流程</strong><br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/rangefeed.png" alt="rangefeed.png"><br><strong>Feed结构分析</strong><br>![cdc ca.png.png](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc">https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc</a> ca.png)</p>
<hr>
<h4 id="The-Difficulty-With-Decoding-WriteBatches"><a href="#The-Difficulty-With-Decoding-WriteBatches" class="headerlink" title="The Difficulty With Decoding WriteBatches"></a>The Difficulty With Decoding WriteBatches</h4><p><strong>MVCC操作对应的WriteBatch包含的entries</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">- MVCCPut</span><br><span class="line">    - inline (never transactional)</span><br><span class="line">        + write meta key w/ inline value</span><br><span class="line">    - not inline</span><br><span class="line">        - transactional</span><br><span class="line">            - no</span><br><span class="line">                + write <span class="built_in">new</span> version</span><br><span class="line">            - yes</span><br><span class="line">                - intent exists with older timestamp</span><br><span class="line">                    + clear old version</span><br><span class="line">                    + write meta</span><br><span class="line">                    + write <span class="built_in">new</span> version</span><br><span class="line">                - <span class="keyword">else</span></span><br><span class="line">                    + write meta</span><br><span class="line">                    + write <span class="built_in">new</span> version</span><br><span class="line">- MVCCDelete</span><br><span class="line">    - inline (never transactional)</span><br><span class="line">        + clear meta key</span><br><span class="line">    - not inline</span><br><span class="line">        + same as MVCCPut but with empty value and Deleted=<span class="literal">true</span> in meta</span><br><span class="line">- MVCCDeleteRange</span><br><span class="line">    + calls MVCCDelete <span class="keyword">for</span> each key in <span class="keyword">range</span></span><br><span class="line">- MVCCMerge</span><br><span class="line">    + write merge record (never transactional)</span><br><span class="line">- MVCCResolveWriteIntent</span><br><span class="line">    - commit</span><br><span class="line">        + clear meta</span><br><span class="line">        - <span class="keyword">if</span> timestamp of intent is incorrect</span><br><span class="line">            + clear old version key</span><br><span class="line">            + write <span class="built_in">new</span> version key</span><br><span class="line">    - abort</span><br><span class="line">        + clear version key</span><br><span class="line">        + clear meta key</span><br><span class="line">    - push</span><br><span class="line">        + write meta with larger timestamp</span><br><span class="line">        + clear old version key</span><br><span class="line">        + write <span class="built_in">new</span> version key</span><br><span class="line">- MVCCGarbageCollect</span><br><span class="line">    + clear each meta key</span><br><span class="line">    + clear each version</span><br></pre></td></tr></table></figure>
<p>解码 <em><strong>WriteBatches</strong></em> 的过程将包括获取RocksDB批处理条目列表并对其正在执行的集体更高级别的操作进行反向工程。例如，包含对同一个逻辑键的meta键和版本键的写操作的WriteBatch将被解释为一个意向写操作;同样，删除meta键将被解释为一个成功的intent解析操作。这里不仅需要进行大量的状态转换以进行模式匹配，而且还不清楚在没有额外的引擎读取的情况下这种解码是否会变得清晰无误，也就是说，对WriteBatch本身进行解码的过程是任何方式都是无法克服的。更令人担忧的是，这正在对筏上MVCC层的实现细节造成非常严重的筏下依赖。引入这种依赖性后，我们将必须非常谨慎地对MVCC进行任何更改，这可能会导致严重的后果。诸如此类的问题促使提议者评估kv重构，因此不应掉以轻心。</p>
<h4 id="Logical-MVCC-Operations"><a href="#Logical-MVCC-Operations" class="headerlink" title="Logical MVCC Operations"></a>Logical MVCC Operations</h4><p>因此，我们提出了一种替代方法来对<code>WriteBatch</code>进行解码直接在Raft命令中。相反，我们建议引入一种逻辑每个Raft命令的更高级MVCC操作的列表。这些更高层次的操作将不受物理操作语义的约束描述在<code>WriteBatch</code>中，因此不会限制对其的更改将来。取而代之的是，这些操作将描述批次的更改在MVCC级别。这样可以避免以前的问题，并且更容易解码Raft下游的操作。</p>
<p><em><strong>LogicalOps</strong></em><br><code>RaftCommand</code> proto message:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">repeated MVICLogicalOp mvcc_ops;</span><br></pre></td></tr></table></figure>

<p><code>MVICLogicalOp</code>定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">message Bytes &#123;</span><br><span class="line">    option (gogoproto.onlyone) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    bytes inline = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    message Pointer &#123;</span><br><span class="line">        <span class="keyword">int32</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int32</span> <span class="built_in">len</span> = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Pointer pointer = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCWriteValueOp &#123;</span><br><span class="line">    bytes key = <span class="number">1</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">2</span>;</span><br><span class="line">    bytes value = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCWriteIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">    bytes txn_key = <span class="number">2</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCUpdateIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCCommitIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">    bytes key = <span class="number">2</span>;</span><br><span class="line">    util.hlc.Timestamp timestamp = <span class="number">3</span>;</span><br><span class="line">    bytes value = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVCCAbortIntentOp &#123;</span><br><span class="line">    bytes txn_id = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message MVICLogicalOp &#123;</span><br><span class="line">    option (gogoproto.onlyone) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    MVCCWriteValueOp   write_value   = <span class="number">1</span>;</span><br><span class="line">    MVCCWriteIntentOp  write_intent  = <span class="number">2</span>;</span><br><span class="line">    MVCCUpdateIntentOp update_intent = <span class="number">3</span>;</span><br><span class="line">    MVCCCommitIntentOp commit_intent = <span class="number">4</span>;</span><br><span class="line">    MVCCAbortIntentOp  abort_intent  = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，所有字节切片值将可选地指向WriteBatch本身，这将有助于限制由于复制物理和逻辑操作而导致的写放大。 此优化可以逐步引入。 我们还可以探索压缩技术，这可能会导致类似的重复数据删除。在Raft之上，随着在BatchRequest中处理每个请求，MVCCOps的日志将与WriteBatch并排构造。 将Raft及其MVCC操作分开，然后分别通过以下逻辑运行它们：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> op in mvccOps &#123;</span><br><span class="line">    match op &#123;</span><br><span class="line">        WriteValue(key, ts, val) =&gt; SendValueToMatchingFeeds(key, ts, val),</span><br><span class="line">        WriteIntent(txnID, ts)   =&gt; &#123;</span><br><span class="line">            UnresolvedIntentQueue[txnID].refcount++</span><br><span class="line">            UnresolvedIntentQueue[txnID].Timestamp.Forward(ts)</span><br><span class="line">        &#125;, </span><br><span class="line">        UpdateIntent(txnID, ts) =&gt; UnresolvedIntentQueue[txnID].Timestamp.Forward(ts),</span><br><span class="line">        CommitIntent(txnID, key, ts) =&gt; &#123;</span><br><span class="line">            UnresolvedIntentQueue[txnID].refcount--</span><br><span class="line">            <span class="comment">// It&#x27;s unfortunate that we&#x27;ll need to perform an engine lookup</span></span><br><span class="line">            <span class="comment">// for this, but it&#x27;s not a huge deal. The value should almost</span></span><br><span class="line">            <span class="comment">// certainly be in RocksDB&#x27;s memtable or block cache, so there&#x27;s</span></span><br><span class="line">            <span class="comment">// not much of a reason for any extra layer of caching.</span></span><br><span class="line">            SendValueToMatchingFeeds(key, MVCCGet(key, ts), ts)</span><br><span class="line">        &#125;,</span><br><span class="line">        AbortIntent    =&gt; UnresolvedIntentQueue[txnID].refcount--,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="CDC-代码时序图编写"><a href="#CDC-代码时序图编写" class="headerlink" title="CDC 代码时序图编写"></a>CDC 代码时序图编写</h2><h2 id="CDC最终一致性"><a href="#CDC最终一致性" class="headerlink" title="CDC最终一致性"></a>CDC最终一致性</h2><p>建立CockroachDB changefeed的最大挑战从一开始就很明显。我们希望我们的changefeed可以横向扩展，同时我们也希望它们保持强大的事务语义。</p>
<p>在单节点数据库中，比如MySQL, 它维护一个binlog记录数据的变更,因此构建changefeed的工作主要是以合理的方式公开此日志.其他的数据库也类似。但是，CockroachDB具有独特的分布式架构。它存储的数据被分解为大约64MB的“ranges”。这些ranges每个都被复制成N个“副本”以获得高可用。CockroachDB事务可以涉及任何或所有这些ranges，这意味着它可以跨越集群中的任何或所有节点。这与在水平扩展其他SQL数据库时使用的“分片”设置形成对比，其中每个分片是完全独立的复制单元，并且事务不能跨越分片。然后，分片SQL群集上的changefeed只是每个分片的changefeed，通常由分片的领导者运行,如下图所示。由于每个事务完全发生在一个分片中，因此分片之间事务的相对排序并不那么值得特别关注（或者说大家很多时候不在乎这种分片之间的事务排序）。它还意味着各个分片的feeds可以完全并行化（每个分片一个Kafka主题或分区是典型的）。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/range_database.png" alt="range_database.png"><br>图1：分片SQL数据库中的事务无法跨越分片。</p>
<p>由于CockroachDB事务可以使用集群中的任何range集合（考虑跨分片事务），因此事务排序要复杂得多, 如下图所示。特别是，并不总是可以将事务划分为独立的流。这里简单的答案是将每个事务放入一个流中，但我们对此并不满意。CockroachDB旨在水平扩展到大量节点，因此我们当然希望我们的changefeed也可以水平扩展。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/znbase_txn.png" alt="znbase_txn.png"></p>
<p>图2：CockroachDB中的事务可以跨节点。</p>
<h3 id="分布式事务保证事务语义"><a href="#分布式事务保证事务语义" class="headerlink" title="分布式事务保证事务语义"></a>分布式事务保证事务语义</h3><p>CockroachDB中的SQL表可以跨越多个range，但该表中的每一行始终包含在一个range内。（当range变大时系统可以移动，系统将其分成两部分以及range变小并且系统将其合并到相邻range时，但这些可以单独处理。）此外，每个range都是一个独立的raft group，因此有自己的WAL，我们可以追随这个WAL。这意味着我们可以为每个SQL行生成有序的changefeed。为了实现这一目标，我们开发了一种内部机制RangeFeed，将这些变化直接从我们的raft group中推出，而不是轮询它们。</p>
<p>每个Row流都是独立的，这意味着我们可以水平缩放它们。使用我们的分布式SQL框架，我们将处理器放置在正在观察的数据旁边发出行更改，从而消除不必要的网络跃点。如果一个节点完成所有观看和发送，它还可以避免我们遇到的单点故障,如下图所示。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/znbase_cdc.png" alt="znbase_cdc.png"><br>图3：CockroachDB range leader各自直接向Kafka（或其他接收器）发出changefeed。</p>
<p>对于许多changefeed用途，这就足够了,每条消息都可以触发移动推送通知，某些数据存储不支持事务。有序的行流对这两者都很有用。对于其他用途，这还不够; 将数据镜像到分析数据库当然不希望应用部分事务。</p>
<p>每个CockroachDB事务使用相同的HLC时间戳提交每一行。在每个消息中为更改的行暴露此时间戳就足以获得事务信息（按时间戳分组行集合）[1]以及总排序（按时间戳排序行）。在我们现有的事务时间戳之上构建意味着我们的changefeed与CockroachDB中的其他所有内容具有相同的可序列化保证。</p>
<p>那最后的问题是知道何时进行这一组或排序。如果hlc1从一个CockroachDB节点随时间发出更改的行，那么在对其进行操作之前，您需要等待多长时间才能确保其他任何节点都没有更改hlc1？</p>
<p>我们用一个我们称之为“resolved”的时间戳消息的概念来解决这个问题。这是一个承诺，即不会发出新的行更改，其时间戳小于或等于已解析的时间戳消息中的时间戳。这意味着上述用户可以在hlc1从每个节点[2]接收到已解决的时间戳之后进行操作&gt;= hlc1, 如下图所示。<br>![cdc resolved.png](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc">https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc</a> resolved.png)</p>
<p>图4中为事务发出的前几条消息的一种可能排序。</p>
<p>在图4中，想象两个独立的流都已经通过读取X。hlc1在其中一个stream上已经“resolved”，但在另外一个stream上没有“resolved”，所以hlc1还没有“resolved。</p>
<p>现在想象一下，在稍后的某些时候，消息已经被读过了Y。两个stream都已“resolved”了hlc1，所以我们知道我们已收到所有已发生的变化，包括hlc1。如果我们按时间戳对消息进行分组，我们可以恢复交易。在这种情况下，只有(B-&gt;1,C-&gt;2)，承诺在hlc1。此事务现在可以发送到分析数据库。</p>
<p>请注意，(A-&gt;3)更改发生在hlc2，因此尚未“resolved”。这意味着changefeed用户需要继续缓存它。</p>
<p>我们还可以随时重建数据库的状态，包括hlc1保持每行的最新值。这甚至适用于范围和节点。在这种情况下，hlc1数据库时B=1,C=2。</p>
<p>最后，想象一下稍后Z读取所有消息的时间。通过相同的两个进程再次获取数据库的事务和状态。在这种情况下，交易(A-&gt;3,B-&gt;4)承诺hlc2和(C-&gt;5)承诺hlc3。在hlc3包含的数据库中A=3,B=1,C=5。请注意，hlc2如有必要，我们还可以重建数据库。</p>
<p>这个创新的解决方案来源于一篇论文《Naiad: A Timely Dataflow System》,其核心思想类似于TCP的接收时间窗口,CockroachDB就是基于这样的思想设计自己的CDC解决方案.</p>
<h4 id="现存问题"><a href="#现存问题" class="headerlink" title="现存问题:"></a>现存问题:</h4><p><strong>自动启动CDC:CockroachDB的CDC是表级别的,但是对于一般的同步任务来说需要至少在DB层面进行配置,以便简化处理,这里的挑战是对于大部分消息队列,只能保证单分片上的数据有序性,而我们在table层面需要这种有序性才能正确的将数据变更按照事务粒度重新组织。</strong></p>
<p><strong>事务捕获:CockroachDB的CDC并不是事务粒度,而是行级别分散的,另外CockroachDB不相干的事务的时间顺序没有严格要求,导致从消息队列中消费的事件的时间戳是混乱的,并且可能存在重复的事件,因此首先我们需要在消费端按照事务作为最小单元重新整理这些数据,这个的主要依据就是事件携带的时间戳,相同时间戳的事件被认为是属于同一个事务的(两个不重叠的事务可以使用相同的时间戳进行提交，但它们具有纳秒精度，因此在实践中这种情况很少见).然后我们按照时间大小顺序重新排序,其中需要对重复的数据进行过滤.</strong></p>
<hr>
<h2 id="代码研读"><a href="#代码研读" class="headerlink" title="代码研读"></a>代码研读</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stageRaftCommand handles the first phase of applying a command to the</span></span><br><span class="line"><span class="comment">// replica state machine.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The proposal also contains auxiliary data which needs to be verified in order</span></span><br><span class="line"><span class="comment">// to decide whether the proposal should be applied: the command&#x27;s MaxLeaseIndex</span></span><br><span class="line"><span class="comment">// must move the state machine&#x27;s LeaseAppliedIndex forward, and the proposer&#x27;s</span></span><br><span class="line"><span class="comment">// lease (or rather its sequence number) must match that of the state machine,</span></span><br><span class="line"><span class="comment">// and lastly the GCThreshold is validated. If any of the checks fail, the</span></span><br><span class="line"><span class="comment">// proposal&#x27;s content is wiped and we apply an empty log entry instead. If an</span></span><br><span class="line"><span class="comment">// error occurs and the command was proposed locally, the error will be</span></span><br><span class="line"><span class="comment">// communicated to the waiting proposer. The two typical cases in which errors</span></span><br><span class="line"><span class="comment">// occur are lease mismatch (in which case the caller tries to send the command</span></span><br><span class="line"><span class="comment">// to the actual leaseholder) and violation of the LeaseAppliedIndex (in which</span></span><br><span class="line"><span class="comment">// case the proposal is retried if it was proposed locally).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Assuming all checks were passed, the command is applied to the batch,</span></span><br><span class="line"><span class="comment">// which is done by the aptly named applyRaftCommandToBatch.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For trivial proposals this is the whole story, but some commands trigger</span></span><br><span class="line"><span class="comment">// additional code in this method in this method via a side effect (in the</span></span><br><span class="line"><span class="comment">// proposal&#x27;s ReplicatedEvalResult or, for local proposals,</span></span><br><span class="line"><span class="comment">// LocalEvalResult). These might, for example, trigger an update of the</span></span><br><span class="line"><span class="comment">// Replica&#x27;s in-memory state to match updates to the on-disk state, or pass</span></span><br><span class="line"><span class="comment">// intents to the intent resolver. Some commands don&#x27;t fit this simple schema</span></span><br><span class="line"><span class="comment">// and need to hook deeper into the code. Notably splits and merges need to</span></span><br><span class="line"><span class="comment">// acquire locks on their right-hand side Replicas and may need to add data to</span></span><br><span class="line"><span class="comment">// the WriteBatch before it is applied; similarly, changes to the disk layout of</span></span><br><span class="line"><span class="comment">// internal state typically require a migration which shows up here. Any of this</span></span><br><span class="line"><span class="comment">// logic however is deferred until after the batch has been written to the</span></span><br><span class="line"><span class="comment">// storage engine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">stageRaftCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	cmd *cmdAppCtx,</span></span></span><br><span class="line"><span class="function"><span class="params">	batch engine.Batch,</span></span></span><br><span class="line"><span class="function"><span class="params">	replicaState *storagepb.ReplicaState,</span></span></span><br><span class="line"><span class="function"><span class="params">	writeAppliedState <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> cmd.e.Index == <span class="number">0</span> &#123;</span><br><span class="line">		log.Fatalf(ctx, <span class="string">&quot;processRaftCommand requires a non-zero index&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> log.V(<span class="number">4</span>) &#123;</span><br><span class="line">		log.Infof(ctx, <span class="string">&quot;processing command %x: maxLeaseIndex=%d&quot;</span>,</span><br><span class="line">			cmd.idKey, cmd.raftCmd.MaxLeaseIndex)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ts hlc.Timestamp</span><br><span class="line">	<span class="keyword">if</span> cmd.idKey != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		ts = cmd.replicatedResult().Timestamp</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd.leaseIndex, cmd.proposalRetry, cmd.forcedErr = checkForcedErr(ctx,</span><br><span class="line">		cmd.idKey, cmd.raftCmd, cmd.proposal, cmd.proposedLocally(), replicaState)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// applyRaftCommandToBatch will return &quot;expected&quot; errors, but may also indicate</span></span><br><span class="line">	<span class="comment">// replica corruption (as of now, signaled by a replicaCorruptionError).</span></span><br><span class="line">	<span class="comment">// We feed its return through maybeSetCorrupt to act when that happens.</span></span><br><span class="line">	<span class="keyword">if</span> cmd.forcedErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.VEventf(ctx, <span class="number">1</span>, <span class="string">&quot;applying command with forced error: %s&quot;</span>, cmd.forcedErr)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Event(ctx, <span class="string">&quot;applying command&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> splitMergeUnlock, err := r.maybeAcquireSplitMergeLock(ctx, cmd.raftCmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Eventf(ctx, <span class="string">&quot;unable to acquire split lock: %s&quot;</span>, err)</span><br><span class="line">			<span class="comment">// Send a crash report because a former bug in the error handling might have</span></span><br><span class="line">			<span class="comment">// been the root cause of #19172.</span></span><br><span class="line">			_ = r.store.stopper.RunAsyncTask(ctx, <span class="string">&quot;crash report&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">				log.SendCrashReport(</span><br><span class="line">					ctx,</span><br><span class="line">					&amp;r.store.cfg.Settings.SV,</span><br><span class="line">					<span class="number">0</span>, <span class="comment">// depth</span></span><br><span class="line">					<span class="string">&quot;while acquiring split lock: %s&quot;</span>,</span><br><span class="line">					[]<span class="keyword">interface</span>&#123;&#125;&#123;err&#125;,</span><br><span class="line">					log.ReportTypeError,</span><br><span class="line">				)</span><br><span class="line">			&#125;)</span><br><span class="line"></span><br><span class="line">			cmd.forcedErr = roachpb.NewError(err)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> splitMergeUnlock != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Set the splitMergeUnlock on the cmdAppCtx to be called after the batch</span></span><br><span class="line">			<span class="comment">// has been applied (see applyBatch).</span></span><br><span class="line">			cmd.splitMergeUnlock = splitMergeUnlock</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> filter := r.store.cfg.TestingKnobs.TestingApplyFilter; cmd.forcedErr == <span class="literal">nil</span> &amp;&amp; filter != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> newPropRetry <span class="keyword">int</span></span><br><span class="line">		newPropRetry, cmd.forcedErr = filter(storagebase.ApplyFilterArgs&#123;</span><br><span class="line">			CmdID:                cmd.idKey,</span><br><span class="line">			ReplicatedEvalResult: *cmd.replicatedResult(),</span><br><span class="line">			StoreID:              r.store.StoreID(),</span><br><span class="line">			RangeID:              r.RangeID,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> cmd.proposalRetry == <span class="number">0</span> &#123;</span><br><span class="line">			cmd.proposalRetry = proposalReevaluationReason(newPropRetry)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cmd.forcedErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Apply an empty entry.</span></span><br><span class="line">		*cmd.replicatedResult() = storagepb.ReplicatedEvalResult&#123;&#125;</span><br><span class="line">		cmd.raftCmd.WriteBatch = <span class="literal">nil</span></span><br><span class="line">		cmd.raftCmd.LogicalOpLog = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run any triggers that should occur before the batch is applied</span></span><br><span class="line">	<span class="comment">// and before the write batch is staged in the batch.</span></span><br><span class="line">	<span class="comment">//获取Batch中存储的befor value,也即处理MVICLogicalOp针对于不同的Op进行相关处理，RangeFeed目前处理WriteValue Op以及CommitOp将其对应的Value publish</span></span><br><span class="line">	<span class="keyword">if</span> err := r.runPreApplyTriggersBeforeStagingWriteBatch(ctx, cmd, batch); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Errorf(ctx, <span class="string">&quot;unable to update the state machine: %+v&quot;</span>, err)</span><br><span class="line">		log.Fatal(ctx, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Update the node clock with the serviced request. This maintains</span></span><br><span class="line">	<span class="comment">// a high water mark for all ops serviced, so that received ops without</span></span><br><span class="line">	<span class="comment">// a timestamp specified are guaranteed one higher than any op already</span></span><br><span class="line">	<span class="comment">// executed for overlapping keys.</span></span><br><span class="line">	<span class="comment">// TODO(ajwerner): coalesce the clock update per batch.</span></span><br><span class="line">	r.store.Clock().Update(ts)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the command was using the deprecated version of the MVCCStats proto,</span></span><br><span class="line">	<span class="comment">// migrate it to the new version and clear out the field.</span></span><br><span class="line">	<span class="keyword">if</span> deprecatedDelta := cmd.replicatedResult().DeprecatedDelta; deprecatedDelta != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> cmd.replicatedResult().Delta != (enginepb.MVCCStatsDelta&#123;&#125;) &#123;</span><br><span class="line">			log.Fatalf(ctx, <span class="string">&quot;stats delta not empty but deprecated delta provided: %+v&quot;</span>, cmd)</span><br><span class="line">		&#125;</span><br><span class="line">		cmd.replicatedResult().Delta = deprecatedDelta.ToStatsDelta()</span><br><span class="line">		cmd.replicatedResult().DeprecatedDelta = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply the Raft command to the batch&#x27;s accumulated state. This may also</span></span><br><span class="line">	<span class="comment">// have the effect of mutating cmd.replicatedResult().</span></span><br><span class="line">	err := r.applyRaftCommandToBatch(cmd.ctx, cmd, replicaState, batch, writeAppliedState)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// applyRaftCommandToBatch returned an error, which usually indicates</span></span><br><span class="line">		<span class="comment">// either a serious logic bug in CockroachDB or a disk</span></span><br><span class="line">		<span class="comment">// corruption/out-of-space issue. Make sure that these fail with</span></span><br><span class="line">		<span class="comment">// descriptive message so that we can differentiate the root causes.</span></span><br><span class="line">		log.Errorf(ctx, <span class="string">&quot;unable to update the state machine: %+v&quot;</span>, err)</span><br><span class="line">		<span class="comment">// Report the fatal error separately and only with the error, as that</span></span><br><span class="line">		<span class="comment">// triggers an optimization for which we directly report the error to</span></span><br><span class="line">		<span class="comment">// sentry (which in turn allows sentry to distinguish different error</span></span><br><span class="line">		<span class="comment">// types).</span></span><br><span class="line">		log.Fatal(ctx, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// AddSSTable ingestions run before the actual batch gets written to the</span></span><br><span class="line">	<span class="comment">// storage engine. This makes sure that when the Raft command is applied,</span></span><br><span class="line">	<span class="comment">// the ingestion has definitely succeeded. Note that we have taken</span></span><br><span class="line">	<span class="comment">// precautions during command evaluation to avoid having mutations in the</span></span><br><span class="line">	<span class="comment">// WriteBatch that affect the SSTable. Not doing so could result in order</span></span><br><span class="line">	<span class="comment">// reversal (and missing values) here.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// NB: any command which has an AddSSTable is non-trivial and will be</span></span><br><span class="line">	<span class="comment">// applied in its own batch so it&#x27;s not possible that any other commands</span></span><br><span class="line">	<span class="comment">// which precede this command can shadow writes from this SSTable.</span></span><br><span class="line">	<span class="keyword">if</span> cmd.replicatedResult().AddSSTable != <span class="literal">nil</span> &#123;</span><br><span class="line">		copied := addSSTablePreApply(</span><br><span class="line">			ctx,</span><br><span class="line">			r.store.cfg.Settings,</span><br><span class="line">			r.store.engine,</span><br><span class="line">			r.raftMu.sideloaded,</span><br><span class="line">			cmd.e.Term,</span><br><span class="line">			cmd.e.Index,</span><br><span class="line">			*cmd.replicatedResult().AddSSTable,</span><br><span class="line">			r.store.limiters.BulkIOWriteRate,</span><br><span class="line">		)</span><br><span class="line">		r.store.metrics.AddSSTableApplications.Inc(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span> copied &#123;</span><br><span class="line">			r.store.metrics.AddSSTableApplicationCopies.Inc(<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cmd.replicatedResult().AddSSTable = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cmd.replicatedResult().Split != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Splits require a new HardState to be written to the new RHS</span></span><br><span class="line">		<span class="comment">// range (and this needs to be atomic with the main batch). This</span></span><br><span class="line">		<span class="comment">// cannot be constructed at evaluation time because it differs</span></span><br><span class="line">		<span class="comment">// on each replica (votes may have already been cast on the</span></span><br><span class="line">		<span class="comment">// uninitialized replica). Write this new hardstate to the batch too.</span></span><br><span class="line">		<span class="comment">// See https://github.com/cockroachdb/cockroach/issues/20629</span></span><br><span class="line">		splitPreApply(ctx, batch, cmd.replicatedResult().Split.SplitTrigger)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> merge := cmd.replicatedResult().Merge; merge != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Merges require the subsumed range to be atomically deleted when the</span></span><br><span class="line">		<span class="comment">// merge transaction commits.</span></span><br><span class="line">		rhsRepl, err := r.store.GetReplica(merge.RightDesc.RangeID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(ctx, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">const</span> destroyData = <span class="literal">false</span></span><br><span class="line">		err = rhsRepl.preDestroyRaftMuLocked(ctx, batch, batch, merge.RightDesc.NextReplicaID, destroyData)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(ctx, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Provide the command&#x27;s corresponding logical operations to the Replica&#x27;s</span></span><br><span class="line">	<span class="comment">// rangefeed. Only do so if the WriteBatch is non-nil, in which case the</span></span><br><span class="line">	<span class="comment">// rangefeed requires there to be a corresponding logical operation log or</span></span><br><span class="line">	<span class="comment">// it will shut down with an error. If the WriteBatch is nil then we expect</span></span><br><span class="line">	<span class="comment">// the logical operation log to also be nil. We don&#x27;t want to trigger a</span></span><br><span class="line">	<span class="comment">// shutdown of the rangefeed in that situation, so we don&#x27;t pass anything to</span></span><br><span class="line">	<span class="comment">// the rangefed. If no rangefeed is running at all, this call will be a noop.</span></span><br><span class="line">	<span class="keyword">if</span> cmd.raftCmd.WriteBatch != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">//与之前的befer处理类似，	</span></span><br><span class="line">	<span class="comment">//获取Batch中存储的value,也即处理MVICLogicalOp针对于不同的Op进行相关处理，RangeFeed目前处理WriteValue Op以及CommitOp将其对应的Value publish</span></span><br><span class="line">		r.handleLogicalOpLogRaftMuLocked(ctx, cmd.raftCmd.LogicalOpLog, batch)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> cmd.raftCmd.LogicalOpLog != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(ctx, <span class="string">&quot;non-nil logical op log with nil write batch: %v&quot;</span>, cmd.raftCmd)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// runPreApplyTriggersBeforeStagingWriteBatch runs any triggers that must fire</span></span><br><span class="line"><span class="comment">// before a command is applied to the state machine but after the command is</span></span><br><span class="line"><span class="comment">// staged in the replicaAppBatch&#x27;s write batch. It may modify the command.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">runPreApplyTriggersBeforeStagingWriteBatch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context, cmd *cmdAppCtx, batch engine.Batch,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ops := cmd.raftCmd.LogicalOpLog; ops != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.populatePrevValsInLogicalOpLogRaftMuLocked(ctx, ops, batch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// populatePrevValsInLogicalOpLogRaftMuLocked updates the provided logical op</span></span><br><span class="line"><span class="comment">// log with previous values read from the reader, which is expected to reflect</span></span><br><span class="line"><span class="comment">// the state of the Replica before the operations in the logical op log are</span></span><br><span class="line"><span class="comment">// applied. No-op if a rangefeed is not active. Requires raftMu to be locked.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">populatePrevValsInLogicalOpLogRaftMuLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context, ops *storagepb.LogicalOpLog, prevReader engine.Reader,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.raftMu.rangefeed == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ops == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read from the Reader to populate the PrevValue fields.</span></span><br><span class="line">	<span class="keyword">for</span> _, op := <span class="keyword">range</span> ops.Ops &#123;</span><br><span class="line">		<span class="keyword">var</span> key []<span class="keyword">byte</span></span><br><span class="line">		<span class="keyword">var</span> ts hlc.Timestamp</span><br><span class="line">		<span class="keyword">var</span> prevValPtr *[]<span class="keyword">byte</span></span><br><span class="line">		<span class="keyword">switch</span> t := op.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCWriteValueOp:</span><br><span class="line">			key, ts, prevValPtr = t.Key, t.Timestamp, &amp;t.PrevValue</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCCommitIntentOp:</span><br><span class="line">			key, ts, prevValPtr = t.Key, t.Timestamp, &amp;t.PrevValue</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCWriteIntentOp,</span><br><span class="line">			*enginepb.MVCCUpdateIntentOp,</span><br><span class="line">			*enginepb.MVCCAbortIntentOp,</span><br><span class="line">			*enginepb.MVCCAbortTxnOp:</span><br><span class="line">			<span class="comment">// Nothing to do.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unknown logical op %T&quot;</span>, t))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//// Don&#x27;t read previous values from the reader for operations that are</span></span><br><span class="line">		<span class="comment">//// not needed by any rangefeed registration.</span></span><br><span class="line">		<span class="comment">//if !filter.NeedPrevVal(roachpb.Span&#123;Key: key&#125;) &#123;</span></span><br><span class="line">		<span class="comment">//	continue</span></span><br><span class="line">		<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read the previous value from the prev Reader. Unlike the new value</span></span><br><span class="line">		<span class="comment">// (see handleLogicalOpLogRaftMuLocked), this one may be missing.</span></span><br><span class="line">		<span class="comment">//从raft中获取对应的befer value值，将其存储到Op中</span></span><br><span class="line">		prevVal, _, err := engine.MVCCGet(</span><br><span class="line">			ctx, prevReader, key, ts, engine.MVCCGetOptions&#123;Tombstones: <span class="literal">true</span>, Inconsistent: <span class="literal">true</span>&#125;,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			r.disconnectRangefeedWithErrRaftMuLocked(roachpb.NewErrorf(</span><br><span class="line">				<span class="string">&quot;error consuming %T for key %v @ ts %v: %v&quot;</span>, op, key, ts, err,</span><br><span class="line">			))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> prevVal != <span class="literal">nil</span> &#123;</span><br><span class="line">			*prevValPtr = prevVal.RawBytes</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			*prevValPtr = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// handleLogicalOpLogRaftMuLocked passes the logical op log to the active</span></span><br><span class="line"><span class="comment">// rangefeed, if one is running. The method accepts a reader, which is used to</span></span><br><span class="line"><span class="comment">// look up the values associated with key-value writes in the log before handing</span></span><br><span class="line"><span class="comment">// them to the rangefeed processor. No-op if a rangefeed is not active. Requires</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">handleLogicalOpLogRaftMuLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context, ops *storagepb.LogicalOpLog, reader engine.Reader,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.raftMu.rangefeed == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ops == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Rangefeeds can&#x27;t be turned on unless RangefeedEnabled is set to true,</span></span><br><span class="line">		<span class="comment">// after which point new Raft proposals will include logical op logs.</span></span><br><span class="line">		<span class="comment">// However, there&#x27;s a race present where old Raft commands without a</span></span><br><span class="line">		<span class="comment">// logical op log might be passed to a rangefeed. Since the effect of</span></span><br><span class="line">		<span class="comment">// these commands was not included in the catch-up scan of current</span></span><br><span class="line">		<span class="comment">// registrations, we&#x27;re forced to throw an error. The rangefeed clients</span></span><br><span class="line">		<span class="comment">// can reconnect at a later time, at which point all new Raft commands</span></span><br><span class="line">		<span class="comment">// should have logical op logs.</span></span><br><span class="line">		r.disconnectRangefeedWithReasonRaftMuLocked(</span><br><span class="line">			roachpb.RangeFeedRetryError_REASON_LOGICAL_OPS_MISSING,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ops.Ops) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When reading straight from the Raft log, some logical ops will not be</span></span><br><span class="line">	<span class="comment">// fully populated. Read from the Reader to populate all fields.</span></span><br><span class="line">	<span class="keyword">for</span> _, op := <span class="keyword">range</span> ops.Ops &#123;</span><br><span class="line">		<span class="keyword">var</span> key []<span class="keyword">byte</span></span><br><span class="line">		<span class="keyword">var</span> ts hlc.Timestamp</span><br><span class="line">		<span class="keyword">var</span> valPtr *[]<span class="keyword">byte</span></span><br><span class="line">		<span class="keyword">switch</span> t := op.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCWriteValueOp:</span><br><span class="line">			key, ts, valPtr = t.Key, t.Timestamp, &amp;t.Value</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCCommitIntentOp:</span><br><span class="line">			key, ts, valPtr = t.Key, t.Timestamp, &amp;t.Value</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCWriteIntentOp,</span><br><span class="line">			*enginepb.MVCCUpdateIntentOp,</span><br><span class="line">			*enginepb.MVCCAbortIntentOp,</span><br><span class="line">			*enginepb.MVCCAbortTxnOp:</span><br><span class="line">			<span class="comment">// Nothing to do.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unknown logical op %T&quot;</span>, t))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read the value directly from the Reader. This is performed in the</span></span><br><span class="line">		<span class="comment">// same raftMu critical section that the logical op&#x27;s corresponding</span></span><br><span class="line">		<span class="comment">// WriteBatch is applied, so the value should exist.</span></span><br><span class="line">		val, _, err := engine.MVCCGet(ctx, reader, key, ts, engine.MVCCGetOptions&#123;Tombstones: <span class="literal">true</span>&#125;)</span><br><span class="line">		<span class="keyword">if</span> val == <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">			err = errors.New(<span class="string">&quot;value missing in reader&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			r.disconnectRangefeedWithErrRaftMuLocked(roachpb.NewErrorf(</span><br><span class="line">				<span class="string">&quot;error consuming %T for key %v @ ts %v: %v&quot;</span>, op, key, ts, err,</span><br><span class="line">			))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		*valPtr = val.RawBytes</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pass the ops to the rangefeed processor.</span></span><br><span class="line">	<span class="comment">//将opts发送到对应的rangfeed进行处理</span></span><br><span class="line">	<span class="keyword">if</span> !r.raftMu.rangefeed.ConsumeLogicalOps(ops.Ops...) &#123;</span><br><span class="line">		<span class="comment">// Consumption failed and the rangefeed was stopped.</span></span><br><span class="line">		r.resetRangefeedRaftMuLocked()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ConsumeLogicalOps informs the rangefeed processor of the set of logical</span></span><br><span class="line"><span class="comment">// operations. It returns false if consuming the operations hit a timeout, as</span></span><br><span class="line"><span class="comment">// specified by the EventChanTimeout configuration. If the method returns false,</span></span><br><span class="line"><span class="comment">// the processor will have been stopped, so calling Stop is not necessary. Safe</span></span><br><span class="line"><span class="comment">// to call on nil Processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">ConsumeLogicalOps</span><span class="params">(ops ...enginepb.MVICLogicalOp)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ops) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//将opts event 发送到对应的chan中进行处理</span></span><br><span class="line">	<span class="keyword">return</span> p.sendEvent(event&#123;ops: ops&#125;, p.EventChanTimeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendEvent informs the Processor of a new event. If a timeout is specified,</span></span><br><span class="line"><span class="comment">// the method will wait for no longer than that duration before giving up,</span></span><br><span class="line"><span class="comment">// shutting down the Processor, and returning false. 0 for no timeout.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">sendEvent</span><span class="params">(e event, timeout time.Duration)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> timeout == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> p.eventC &lt;- e:</span><br><span class="line">		<span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line">			<span class="comment">// Already stopped. Do nothing.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> p.eventC &lt;- e:</span><br><span class="line">		<span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line">			<span class="comment">// Already stopped. Do nothing.</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> p.eventC &lt;- e:</span><br><span class="line">			<span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line">				<span class="comment">// Already stopped. Do nothing.</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">				<span class="comment">// Sending on the eventC channel would have blocked.</span></span><br><span class="line">				<span class="comment">// Instead, tear down the processor and return immediately.</span></span><br><span class="line">				p.sendStop(newErrBufferCapacityExceeded())</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start launches a goroutine to process rangefeed events and send them to</span></span><br><span class="line"><span class="comment">// registrations.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The provided iterator is used to initialize the rangefeed&#x27;s resolved</span></span><br><span class="line"><span class="comment">// timestamp. It must obey the contract of an iterator used for an</span></span><br><span class="line"><span class="comment">// initResolvedTSScan. The Processor promises to clean up the iterator by</span></span><br><span class="line"><span class="comment">// calling its Close method when it is finished. If the iterator is nil then</span></span><br><span class="line"><span class="comment">// no initialization scan will be performed and the resolved timestamp will</span></span><br><span class="line"><span class="comment">// immediately be considered initialized.</span></span><br><span class="line"><span class="comment">//启动对应的RangeFeed Processor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">Start</span><span class="params">(stopper *stop.Stopper, rtsIter engine.SimpleIterator)</span></span> &#123;</span><br><span class="line">	ctx := p.AnnotateCtx(context.Background())</span><br><span class="line">	stopper.RunWorker(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="built_in">close</span>(p.stoppedC)</span><br><span class="line">		ctx, cancelOutputLoops := context.WithCancel(ctx)</span><br><span class="line">		<span class="keyword">defer</span> cancelOutputLoops()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Launch an async task to scan over the resolved timestamp iterator and</span></span><br><span class="line">		<span class="comment">// initialize the unresolvedIntentQueue. Ignore error if quiescing.</span></span><br><span class="line">		<span class="keyword">if</span> rtsIter != <span class="literal">nil</span> &#123;</span><br><span class="line">			initScan := newInitResolvedTSScan(p, rtsIter)</span><br><span class="line">			err := stopper.RunAsyncTask(ctx, <span class="string">&quot;rangefeed: init resolved ts&quot;</span>, initScan.Run)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				initScan.Cancel()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p.initResolvedTS(ctx)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// txnPushTicker periodically pushes the transaction record of all</span></span><br><span class="line">		<span class="comment">// unresolved intents that are above a certain age, helping to ensure</span></span><br><span class="line">		<span class="comment">// that the resolved timestamp continues to make progress.</span></span><br><span class="line">		<span class="keyword">var</span> txnPushTicker *time.Ticker</span><br><span class="line">		<span class="keyword">var</span> txnPushTickerC &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">		<span class="keyword">var</span> txnPushAttemptC <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> p.PushTxnsInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">			txnPushTicker = time.NewTicker(p.PushTxnsInterval)</span><br><span class="line">			txnPushTickerC = txnPushTicker.C</span><br><span class="line">			<span class="keyword">defer</span> txnPushTicker.Stop()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Handle new registrations.</span></span><br><span class="line">			<span class="keyword">case</span> r := &lt;-p.regC:</span><br><span class="line">				<span class="keyword">if</span> !p.Span.AsRawSpanWithNoLocals().Contains(r.span) &#123;</span><br><span class="line">					log.Fatalf(ctx, <span class="string">&quot;registration %s not in Processor&#x27;s key range %v&quot;</span>, r, p.Span)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Add the new registration to the registry.</span></span><br><span class="line">				p.reg.Register(&amp;r)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Immediately publish a checkpoint event to the registry. This will be</span></span><br><span class="line">				<span class="comment">// the first event published to this registration after its initial</span></span><br><span class="line">				<span class="comment">// catch-up scan completes.</span></span><br><span class="line">				r.publish(p.newCheckpointEvent())</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Run an output loop for the registry.</span></span><br><span class="line">				runOutputLoop := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">					r.runOutputLoop(ctx)</span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> p.unregC &lt;- &amp;r:</span><br><span class="line">					<span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err := stopper.RunAsyncTask(ctx, <span class="string">&quot;rangefeed: output loop&quot;</span>, runOutputLoop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> r.catchupIter != <span class="literal">nil</span> &#123;</span><br><span class="line">						r.catchupIter.Close() <span class="comment">// clean up</span></span><br><span class="line">					&#125;</span><br><span class="line">					r.disconnect(roachpb.NewError(err))</span><br><span class="line">					p.reg.Unregister(&amp;r)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Respond to unregistration requests; these come from registrations that</span></span><br><span class="line">			<span class="comment">// encounter an error during their output loop.</span></span><br><span class="line">			<span class="keyword">case</span> r := &lt;-p.unregC:</span><br><span class="line">				p.reg.Unregister(r)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Respond to answers about the processor goroutine state.</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-p.lenReqC:</span><br><span class="line">				p.lenResC &lt;- p.reg.Len()</span><br><span class="line">			<span class="comment">// Respond to answers about which operations can be filtered before</span></span><br><span class="line">			<span class="comment">// reaching the Processor.</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-p.filterReqC:</span><br><span class="line">				p.filterResC &lt;- p.reg.NewFilter()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Transform and route events.</span></span><br><span class="line">			<span class="comment">//消费对应的event并进行路由</span></span><br><span class="line">			<span class="keyword">case</span> e := &lt;-p.eventC:</span><br><span class="line">				p.consumeEvent(ctx, e)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Check whether any unresolved intents need a push.</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-txnPushTickerC:</span><br><span class="line">				<span class="comment">// Don&#x27;t perform transaction push attempts until the resolved</span></span><br><span class="line">				<span class="comment">// timestamp has been initialized.</span></span><br><span class="line">				<span class="keyword">if</span> !p.rts.IsInit() &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				now := p.Clock.Now()</span><br><span class="line">				before := now.Add(-p.PushTxnsAge.Nanoseconds(), <span class="number">0</span>)</span><br><span class="line">				oldTxns := p.rts.intentQ.Before(before)</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(oldTxns) &gt; <span class="number">0</span> &#123;</span><br><span class="line">					toPush := <span class="built_in">make</span>([]enginepb.TxnMeta, <span class="built_in">len</span>(oldTxns))</span><br><span class="line">					<span class="keyword">for</span> i, txn := <span class="keyword">range</span> oldTxns &#123;</span><br><span class="line">						toPush[i] = txn.asTxnMeta()</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Set the ticker channel to nil so that it can&#x27;t trigger a</span></span><br><span class="line">					<span class="comment">// second concurrent push. Create a push attempt response</span></span><br><span class="line">					<span class="comment">// channel that is closed when the push attempt completes.</span></span><br><span class="line">					txnPushTickerC = <span class="literal">nil</span></span><br><span class="line">					txnPushAttemptC = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Launch an async transaction push attempt that pushes the</span></span><br><span class="line">					<span class="comment">// timestamp of all transactions beneath the push offset.</span></span><br><span class="line">					<span class="comment">// Ignore error if quiescing.</span></span><br><span class="line">					pushTxns := newTxnPushAttempt(p, toPush, now, txnPushAttemptC)</span><br><span class="line">					err := stopper.RunAsyncTask(ctx, <span class="string">&quot;rangefeed: pushing old txns&quot;</span>, pushTxns.Run)</span><br><span class="line">					<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">						pushTxns.Cancel()</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update the resolved timestamp based on the push attempt.</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-txnPushAttemptC:</span><br><span class="line">				<span class="comment">// Reset the ticker channel so that it can trigger push attempts</span></span><br><span class="line">				<span class="comment">// again. Set the push attempt channel back to nil.</span></span><br><span class="line">				txnPushTickerC = txnPushTicker.C</span><br><span class="line">				txnPushAttemptC = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Close registrations and exit when signaled.</span></span><br><span class="line">			<span class="keyword">case</span> pErr := &lt;-p.stopC:</span><br><span class="line">				p.reg.DisconnectWithErr(all, pErr)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Exit on stopper.</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-stopper.ShouldQuiesce():</span><br><span class="line">				p.reg.Disconnect(all)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消费opts event</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">consumeEvent</span><span class="params">(ctx context.Context, e event)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="built_in">len</span>(e.ops) &gt; <span class="number">0</span>:</span><br><span class="line">		p.consumeLogicalOps(ctx, e.ops)</span><br><span class="line">	<span class="keyword">case</span> e.ct != hlc.Timestamp&#123;&#125;:</span><br><span class="line">		p.forwardClosedTS(ctx, e.ct)</span><br><span class="line">	<span class="keyword">case</span> e.initRTS:</span><br><span class="line">		p.initResolvedTS(ctx)</span><br><span class="line">	<span class="keyword">case</span> e.syncC != <span class="literal">nil</span>:</span><br><span class="line">		<span class="keyword">if</span> e.testRegCatchupSpan.Valid() &#123;</span><br><span class="line">			<span class="keyword">if</span> err := p.reg.waitForCaughtUp(e.testRegCatchupSpan); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Errorf(</span><br><span class="line">					ctx,</span><br><span class="line">					<span class="string">&quot;error waiting for registries to catch up during test, results might be impacted: %s&quot;</span>,</span><br><span class="line">					err,</span><br><span class="line">				)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(e.syncC)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;missing event variant&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">consumeLogicalOps</span><span class="params">(ctx context.Context, ops []enginepb.MVICLogicalOp)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line">		<span class="comment">// Publish RangeFeedValue updates, if necessary.</span></span><br><span class="line">		<span class="keyword">switch</span> t := op.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCWriteValueOp:</span><br><span class="line">			<span class="comment">// Publish the new value directly.</span></span><br><span class="line">			p.publishValue(ctx, t.Key, t.Timestamp, t.Value, t.PrevValue)</span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCWriteIntentOp:</span><br><span class="line">			<span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCUpdateIntentOp:</span><br><span class="line">			<span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCCommitIntentOp:</span><br><span class="line">			<span class="comment">// Publish the newly committed value.</span></span><br><span class="line">			p.publishValue(ctx, t.Key, t.Timestamp, t.Value, t.PrevValue)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCAbortIntentOp:</span><br><span class="line">			<span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> *enginepb.MVCCAbortTxnOp:</span><br><span class="line">			<span class="comment">// No updates to publish.</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;unknown logical op %T&quot;</span>, t))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Determine whether the operation caused the resolved timestamp to</span></span><br><span class="line">		<span class="comment">// move forward. If so, publish a RangeFeedCheckpoint notification.</span></span><br><span class="line">		<span class="keyword">if</span> p.rts.ConsumeLogicalOp(op) &#123;</span><br><span class="line">			p.publishCheckpoint(ctx)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Register registers the stream over the specified span of keys.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The registration will not observe any events that were consumed before this</span></span><br><span class="line"><span class="comment">// method was called. It is undefined whether the registration will observe</span></span><br><span class="line"><span class="comment">// events that are consumed concurrently with this call. The channel will be</span></span><br><span class="line"><span class="comment">// provided an error when the registration closes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The optionally provided &quot;catch-up&quot; iterator is used to read changes from the</span></span><br><span class="line"><span class="comment">// engine which occurred after the provided start timestamp.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// NOT safe to call on nil Processor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Processor)</span> <span class="title">Register</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	span roachpb.RSpan,</span></span></span><br><span class="line"><span class="function"><span class="params">	startTS hlc.Timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">	catchupIter engine.SimpleIterator,</span></span></span><br><span class="line"><span class="function"><span class="params">	withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	stream Stream,</span></span></span><br><span class="line"><span class="function"><span class="params">	errC <span class="keyword">chan</span>&lt;- *roachpb.Error,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Synchronize the event channel so that this registration doesn&#x27;t see any</span></span><br><span class="line">	<span class="comment">// events that were consumed before this registration was called. Instead,</span></span><br><span class="line">	<span class="comment">// it should see these events during its catch up scan.</span></span><br><span class="line">	p.syncEventC()</span><br><span class="line"></span><br><span class="line">	r := newRegistration(</span><br><span class="line">		span.AsRawSpanWithNoLocals(), startTS, catchupIter, withDiff,</span><br><span class="line">		p.Config.EventChanCap, p.Metrics, stream, errC,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> p.regC &lt;- r:</span><br><span class="line">	<span class="keyword">case</span> &lt;-p.stoppedC:</span><br><span class="line">		<span class="keyword">if</span> catchupIter != <span class="literal">nil</span> &#123;</span><br><span class="line">			catchupIter.Close() <span class="comment">// clean up</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// errC has a capacity of 1. If it is already full, we don&#x27;t need to send</span></span><br><span class="line">		<span class="comment">// another error.</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> errC &lt;- roachpb.NewErrorf(<span class="string">&quot;rangefeed processor closed&quot;</span>):</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed registers a rangefeed over the specified span. It sends updates to</span></span><br><span class="line"><span class="comment">// the provided stream and returns with an optional error when the rangefeed is</span></span><br><span class="line"><span class="comment">// complete. The provided ConcurrentRequestLimiter is used to limit the number</span></span><br><span class="line"><span class="comment">// of rangefeeds using catchup iterators at the same time.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Replica)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">roachpb</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !RangefeedEnabled.Get(&amp;r.store.cfg.Settings.SV) &#123;</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewErrorf(<span class="string">&quot;rangefeeds require the kv.rangefeed.enabled setting. See &quot;</span> +</span><br><span class="line">			base.DocsURL(<span class="string">`change-data-capture.html#enable-rangefeeds-to-reduce-latency`</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	ctx := r.AnnotateCtx(stream.Context())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> rSpan roachpb.RSpan</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	rSpan.Key, err = keys.Addr(args.Span.Key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	rSpan.EndKey, err = keys.Addr(args.Span.EndKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.ensureClosedTimestampStarted(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the RangeFeed is performing a catch-up scan then it will observe all</span></span><br><span class="line">	<span class="comment">// values above args.Timestamp. If the RangeFeed is requesting previous</span></span><br><span class="line">	<span class="comment">// values for every update then it will also need to look for the version</span></span><br><span class="line">	<span class="comment">// proceeding each value observed during the catch-up scan timestamp. This</span></span><br><span class="line">	<span class="comment">// means that the earliest value observed by the catch-up scan will be</span></span><br><span class="line">	<span class="comment">// args.Timestamp.Next and the earliest timestamp used to retrieve the</span></span><br><span class="line">	<span class="comment">// previous version of a value will be args.Timestamp, so this is the</span></span><br><span class="line">	<span class="comment">// timestamp we must check against the GCThreshold.</span></span><br><span class="line">	checkTS := args.Timestamp</span><br><span class="line">	<span class="keyword">if</span> checkTS.IsEmpty() &#123;</span><br><span class="line">		<span class="comment">// If no timestamp was provided then we&#x27;re not going to run a catch-up</span></span><br><span class="line">		<span class="comment">// scan, so make sure the GCThreshold in requestCanProceed succeeds.</span></span><br><span class="line">		checkTS = r.Clock().Now()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lockedStream := &amp;lockedRangefeedStream&#123;wrapped: stream&#125;</span><br><span class="line">	errC := <span class="built_in">make</span>(<span class="keyword">chan</span> *roachpb.Error, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we will be using a catch-up iterator, wait for the limiter here before</span></span><br><span class="line">	<span class="comment">// locking raftMu.</span></span><br><span class="line">	usingCatchupIter := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> iterSemRelease <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="keyword">if</span> !args.Timestamp.IsEmpty() &#123;</span><br><span class="line">		usingCatchupIter = <span class="literal">true</span></span><br><span class="line">		lim := &amp;r.store.limiters.ConcurrentRangefeedIters</span><br><span class="line">		<span class="keyword">if</span> err := lim.Begin(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Finish the iterator limit, but only if we exit before</span></span><br><span class="line">		<span class="comment">// creating the iterator itself.</span></span><br><span class="line">		iterSemRelease = lim.Finish</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> iterSemRelease != <span class="literal">nil</span> &#123;</span><br><span class="line">				iterSemRelease()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lock the raftMu, then register the stream as a new rangefeed registration.</span></span><br><span class="line">	<span class="comment">// raftMu is held so that the catch-up iterator is captured in the same</span></span><br><span class="line">	<span class="comment">// critical-section as the registration is established. This ensures that</span></span><br><span class="line">	<span class="comment">// the registration doesn&#x27;t miss any events.</span></span><br><span class="line">	r.raftMu.Lock()</span><br><span class="line">	<span class="keyword">if</span> err := r.checkExecutionCanProceedForRangeFeed(rSpan, checkTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		r.raftMu.Unlock()</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure that the rangefeed processor is running.</span></span><br><span class="line">	<span class="comment">//注册对应RangeFeed Processor</span></span><br><span class="line">	p := r.maybeInitRangefeedRaftMuLocked(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register the stream with a catch-up iterator.</span></span><br><span class="line">	<span class="keyword">var</span> catchUpIter engine.SimpleIterator</span><br><span class="line">	<span class="keyword">if</span> usingCatchupIter &#123;</span><br><span class="line">		innerIter := r.Engine().NewIterator(engine.IterOptions&#123;</span><br><span class="line">			UpperBound: args.Span.EndKey,</span><br><span class="line">			<span class="comment">// RangeFeed originally intended to use the time-bound iterator</span></span><br><span class="line">			<span class="comment">// performance optimization. However, they&#x27;ve had correctness issues in</span></span><br><span class="line">			<span class="comment">// the past (#28358, #34819) and no-one has the time for the due-diligence</span></span><br><span class="line">			<span class="comment">// necessary to be confidant in their correctness going forward. Not using</span></span><br><span class="line">			<span class="comment">// them causes the total time spent in RangeFeed catchup on changefeed</span></span><br><span class="line">			<span class="comment">// over tpcc-1000 to go from 40s -&gt; 4853s, which is quite large but still</span></span><br><span class="line">			<span class="comment">// workable. See #35122 for details.</span></span><br><span class="line">			<span class="comment">// MinTimestampHint: args.Timestamp,</span></span><br><span class="line">		&#125;)</span><br><span class="line">		catchUpIter = iteratorWithCloser&#123;</span><br><span class="line">			SimpleIterator: innerIter,</span><br><span class="line">			<span class="built_in">close</span>:          iterSemRelease,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Responsibility for releasing the semaphore now passes to the iterator.</span></span><br><span class="line">		iterSemRelease = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注册一个registration,该registration为订阅特定范围内数据更新的示例，并通过outputLoop进行数据的流式传输</span></span><br><span class="line">	p.Register(rSpan, args.Timestamp, catchUpIter, args.WithDiff, lockedStream, errC)</span><br><span class="line">	r.raftMu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When this function returns, attempt to clean up the rangefeed.</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		r.raftMu.Lock()</span><br><span class="line">		r.maybeDestroyRangefeedRaftMuLocked(p)</span><br><span class="line">		r.raftMu.Unlock()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block on the registration&#x27;s error channel. Note that the registration</span></span><br><span class="line">	<span class="comment">// observes stream.Context().Done.</span></span><br><span class="line">	<span class="keyword">return</span> &lt;-errC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outputLoop is the operational loop for a single registration. The behavior</span></span><br><span class="line"><span class="comment">// is as thus:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. If a catch-up scan is indicated, run one before beginning the proper</span></span><br><span class="line"><span class="comment">// output loop.</span></span><br><span class="line"><span class="comment">// 2. After catch-up is complete, begin reading from the registration buffer</span></span><br><span class="line"><span class="comment">// channel and writing to the output stream until the buffer is empty *and*</span></span><br><span class="line"><span class="comment">// the overflow flag has been set.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The loop exits with any error encountered, if the provided context is</span></span><br><span class="line"><span class="comment">// canceled, or when the buffer has overflowed and all pre-overflow entries</span></span><br><span class="line"><span class="comment">// have been emitted.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *registration)</span> <span class="title">outputLoop</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// If the registration has a catch-up scan,</span></span><br><span class="line">	<span class="keyword">if</span> r.catchupIter != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := r.runCatchupScan(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = errors.Wrap(err, <span class="string">&quot;catch-up scan failed&quot;</span>)</span><br><span class="line">			log.Error(ctx, err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Normal buffered output loop.</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		overflowed := <span class="literal">false</span></span><br><span class="line">		r.mu.Lock()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(r.buf) == <span class="number">0</span> &#123;</span><br><span class="line">			overflowed = r.mu.overflowed</span><br><span class="line">			r.mu.caughtUp = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		r.mu.Unlock()</span><br><span class="line">		<span class="keyword">if</span> overflowed &#123;</span><br><span class="line">			<span class="keyword">return</span> newErrBufferCapacityExceeded().GoError()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> nextEvent := &lt;-r.buf:</span><br><span class="line">			<span class="keyword">if</span> err := r.stream.Send(nextEvent); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span> ctx.Err()</span><br><span class="line">		<span class="keyword">case</span> &lt;-r.stream.Context().Done():</span><br><span class="line">			<span class="keyword">return</span> r.stream.Context().Err()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed registers a rangefeed over the specified span. It sends updates to</span></span><br><span class="line"><span class="comment">// the provided stream and returns with an optional error when the rangefeed is</span></span><br><span class="line"><span class="comment">// complete.</span></span><br><span class="line"><span class="comment">//store 上的RangeFeed接口，下发到指定Range上开启RangeFeed</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">roachpb</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := verifyKeys(args.Span.Key, args.Span.EndKey, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get range and add command to the range for execution.</span></span><br><span class="line">	repl, err := s.GetReplica(args.RangeID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !repl.IsInitialized() &#123;</span><br><span class="line">		repl.mu.RLock()</span><br><span class="line">		replicaID := repl.mu.replicaID</span><br><span class="line">		repl.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we have an uninitialized copy of the range, then we are</span></span><br><span class="line">		<span class="comment">// probably a valid member of the range, we&#x27;re just in the</span></span><br><span class="line">		<span class="comment">// process of getting our snapshot. If we returned</span></span><br><span class="line">		<span class="comment">// RangeNotFoundError, the client would invalidate its cache,</span></span><br><span class="line">		<span class="comment">// but we can be smarter: the replica that caused our</span></span><br><span class="line">		<span class="comment">// uninitialized replica to be created is most likely the</span></span><br><span class="line">		<span class="comment">// leader.</span></span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(&amp;roachpb.NotLeaseHolderError&#123;</span><br><span class="line">			RangeID:     args.RangeID,</span><br><span class="line">			LeaseHolder: repl.creatingReplica,</span><br><span class="line">			<span class="comment">// The replica doesn&#x27;t have a range descriptor yet, so we have to build</span></span><br><span class="line">			<span class="comment">// a ReplicaDescriptor manually.</span></span><br><span class="line">			Replica: roachpb.ReplicaDescriptor&#123;</span><br><span class="line">				NodeID:    repl.store.nodeDesc.NodeID,</span><br><span class="line">				StoreID:   repl.store.StoreID(),</span><br><span class="line">				ReplicaID: replicaID,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> repl.RangeFeed(args, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed registers a rangefeed over the specified span. It sends updates to</span></span><br><span class="line"><span class="comment">// the provided stream and returns with an optional error when the rangefeed is</span></span><br><span class="line"><span class="comment">// complete.</span></span><br><span class="line"><span class="comment">//Stores级别的RangeFeed接口，将RangeFeed请求下发到对应的Store上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ls *Stores)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> *<span class="title">roachpb</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">	ctx := stream.Context()</span><br><span class="line">	<span class="keyword">if</span> args.RangeID == <span class="number">0</span> &#123;</span><br><span class="line">		log.Fatal(ctx, <span class="string">&quot;rangefeed request missing range ID&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.Replica.StoreID == <span class="number">0</span> &#123;</span><br><span class="line">		log.Fatal(ctx, <span class="string">&quot;rangefeed request missing store ID&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	store, err := ls.GetStore(args.Replica.StoreID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> store.RangeFeed(args, stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RangeFeed implements the roachpb.InternalServer interface.</span></span><br><span class="line"><span class="comment">//Node对应的RangeFeed接口，将请求下发到Stores</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	args *roachpb.RangeFeedRequest, stream roachpb.Internal_RangeFeedServer,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	pErr := n.stores.RangeFeed(args, stream)</span><br><span class="line">	<span class="keyword">if</span> pErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> event roachpb.RangeFeedEvent</span><br><span class="line">		event.SetValue(&amp;roachpb.RangeFeedError&#123;</span><br><span class="line">			Error: *pErr,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> stream.Send(&amp;event)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//grpc server RangeFeed接口，通过InternalClient调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a internalClientAdapter)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context, args *roachpb.RangeFeedRequest, _ ...grpc.CallOption,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(roachpb.Internal_RangeFeedClient, error)</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	rfAdapter := rangeFeedClientAdapter&#123;</span><br><span class="line">		ctx:    ctx,</span><br><span class="line">		eventC: <span class="built_in">make</span>(<span class="keyword">chan</span> *roachpb.RangeFeedEvent, <span class="number">128</span>),</span><br><span class="line">		errC:   <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> cancel()</span><br><span class="line">		err := a.InternalServer.RangeFeed(args, rfAdapter)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			err = io.EOF</span><br><span class="line">		&#125;</span><br><span class="line">		rfAdapter.errC &lt;- err</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rfAdapter, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// singleRangeFeed gathers and rearranges the replicas, and makes a RangeFeed</span></span><br><span class="line"><span class="comment">// RPC call. Results will be send on the provided channel. Returns the timestamp</span></span><br><span class="line"><span class="comment">// of the maximum rangefeed checkpoint seen, which can be used to re-establish</span></span><br><span class="line"><span class="comment">// the rangefeed with a larger starting timestamp, reflecting the fact that all</span></span><br><span class="line"><span class="comment">// values up to the last checkpoint have already been observed. Returns the</span></span><br><span class="line"><span class="comment">// request&#x27;s timestamp if not checkpoints are seen.</span></span><br><span class="line"><span class="comment">//分发层对应的RangeFeed接口，生成对应的GRPC请求。将RangeFeed请求下发到对应节点的对应store上的对应replica</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *DistSender)</span> <span class="title">singleRangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	span roachpb.Span,</span></span></span><br><span class="line"><span class="function"><span class="params">	ts hlc.Timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">	withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	desc *roachpb.RangeDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">	eventCh <span class="keyword">chan</span>&lt;- *roachpb.RangeFeedEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="params">(hlc.Timestamp, *roachpb.Error)</span></span> &#123;</span><br><span class="line">	args := roachpb.RangeFeedRequest&#123;</span><br><span class="line">		Span: span,</span><br><span class="line">		Header: roachpb.Header&#123;</span><br><span class="line">			Timestamp: ts,</span><br><span class="line">			RangeID:   desc.RangeID,</span><br><span class="line">		&#125;,</span><br><span class="line">		WithDiff: withDiff,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> latencyFn LatencyFunc</span><br><span class="line">	<span class="keyword">if</span> ds.rpcContext != <span class="literal">nil</span> &#123;</span><br><span class="line">		latencyFn = ds.rpcContext.RemoteClocks.Latency</span><br><span class="line">	&#125;</span><br><span class="line">	replicas := NewReplicaSlice(ds.gossip, desc)</span><br><span class="line">	<span class="comment">//对于replicas进行排序</span></span><br><span class="line">	replicas.OptimizeReplicaOrder(ds.getNodeDescriptor(), latencyFn)</span><br><span class="line"></span><br><span class="line">	transport, err := ds.transportFactory(SendOptions&#123;&#125;, ds.nodeDialer, replicas)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> args.Timestamp, roachpb.NewError(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> transport.IsExhausted() &#123;</span><br><span class="line">			<span class="keyword">return</span> args.Timestamp, roachpb.NewError(roachpb.NewSendError(</span><br><span class="line">				fmt.Sprintf(<span class="string">&quot;sending to all %d replicas failed&quot;</span>, <span class="built_in">len</span>(replicas)),</span><br><span class="line">			))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		args.Replica = transport.NextReplica()</span><br><span class="line">		clientCtx, client, err := transport.NextInternalClient(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.VErrEventf(ctx, <span class="number">2</span>, <span class="string">&quot;RPC error: %s&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用对应的GRPC接口发送RangeFeed请求</span></span><br><span class="line">		stream, err := client.RangeFeed(clientCtx, &amp;args)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.VErrEventf(ctx, <span class="number">2</span>, <span class="string">&quot;RPC error: %s&quot;</span>, err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			event, err := stream.Recv()</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> args.Timestamp, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> args.Timestamp, roachpb.NewError(err)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">switch</span> t := event.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *roachpb.RangeFeedCheckpoint:</span><br><span class="line">				<span class="keyword">if</span> t.Span.Contains(args.Span) &#123;</span><br><span class="line">					args.Timestamp.Forward(t.ResolvedTS)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> *roachpb.RangeFeedError:</span><br><span class="line">				log.VErrEventf(ctx, <span class="number">2</span>, <span class="string">&quot;RangeFeedError: %s&quot;</span>, t.Error.GoError())</span><br><span class="line">				<span class="keyword">return</span> args.Timestamp, &amp;t.Error</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> eventCh &lt;- event:</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span> args.Timestamp, roachpb.NewError(ctx.Err())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// partialRangeFeed establishes a RangeFeed to the range specified by desc. It</span></span><br><span class="line"><span class="comment">// manages lifecycle events of the range in order to maintain the RangeFeed</span></span><br><span class="line"><span class="comment">// connection; this may involve instructing higher-level functions to retry</span></span><br><span class="line"><span class="comment">// this rangefeed, or subdividing the range further in the event of a split.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *DistSender)</span> <span class="title">partialRangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	rangeInfo *singleRangeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">	withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	rangeCh <span class="keyword">chan</span>&lt;- singleRangeInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">	eventCh <span class="keyword">chan</span>&lt;- *roachpb.RangeFeedEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Bound the partial rangefeed to the partial span.</span></span><br><span class="line">	span := rangeInfo.rs.AsRawSpanWithNoLocals()</span><br><span class="line">	ts := rangeInfo.ts</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start a retry loop for sending the batch to the range.</span></span><br><span class="line">	<span class="keyword">for</span> r := retry.StartWithCtx(ctx, ds.rpcRetryOptions); r.Next(); &#123;</span><br><span class="line">		<span class="comment">// If we&#x27;ve cleared the descriptor on a send failure, re-lookup.</span></span><br><span class="line">		<span class="keyword">if</span> rangeInfo.desc == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> err error</span><br><span class="line">			rangeInfo.desc, rangeInfo.token, err = ds.getDescriptor(ctx, rangeInfo.rs.Key, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.VErrEventf(ctx, <span class="number">1</span>, <span class="string">&quot;range descriptor re-lookup failed: %s&quot;</span>, err)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Establish a RangeFeed for a single Range.</span></span><br><span class="line">		maxTS, pErr := ds.singleRangeFeed(ctx, span, ts, withDiff, rangeInfo.desc, eventCh)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Forward the timestamp in case we end up sending it again.</span></span><br><span class="line">		ts.Forward(maxTS)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> pErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> log.V(<span class="number">1</span>) &#123;</span><br><span class="line">				log.Infof(ctx, <span class="string">&quot;RangeFeed %s disconnected with last checkpoint %s ago: %v&quot;</span>,</span><br><span class="line">					span, timeutil.Since(ts.GoTime()), pErr)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">switch</span> t := pErr.GetDetail().(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> *roachpb.SendError, *roachpb.RangeNotFoundError:</span><br><span class="line">				<span class="comment">// Evict the decriptor from the cache and reload on next attempt.</span></span><br><span class="line">				<span class="keyword">if</span> err := rangeInfo.token.Evict(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				rangeInfo.desc = <span class="literal">nil</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">case</span> *roachpb.RangeKeyMismatchError:</span><br><span class="line">				<span class="comment">// Evict the decriptor from the cache.</span></span><br><span class="line">				<span class="keyword">if</span> err := rangeInfo.token.Evict(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//出现range key范围不匹配时对RangeFeed重新进行划分并发送到各个Range上，</span></span><br><span class="line">				<span class="keyword">return</span> ds.divideAndSendRangeFeedToRanges(ctx, rangeInfo.rs, ts, rangeCh)</span><br><span class="line">			<span class="keyword">case</span> *roachpb.RangeFeedRetryError:</span><br><span class="line">				<span class="keyword">switch</span> t.Reason &#123;</span><br><span class="line">				<span class="keyword">case</span> roachpb.RangeFeedRetryError_REASON_REPLICA_REMOVED,</span><br><span class="line">					roachpb.RangeFeedRetryError_REASON_RAFT_SNAPSHOT,</span><br><span class="line">					roachpb.RangeFeedRetryError_REASON_LOGICAL_OPS_MISSING,</span><br><span class="line">					roachpb.RangeFeedRetryError_REASON_SLOW_CONSUMER:</span><br><span class="line">					<span class="comment">// Try again with same descriptor. These are transient</span></span><br><span class="line">					<span class="comment">// errors that should not show up again.</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">case</span> roachpb.RangeFeedRetryError_REASON_RANGE_SPLIT,</span><br><span class="line">					roachpb.RangeFeedRetryError_REASON_RANGE_MERGED:</span><br><span class="line">					<span class="comment">// Evict the decriptor from the cache.</span></span><br><span class="line">					<span class="keyword">if</span> err := rangeInfo.token.Evict(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//出现range split或者merged 对RangeFeed重新进行划分并发送到各个Range上，</span></span><br><span class="line">					<span class="keyword">return</span> ds.divideAndSendRangeFeedToRanges(ctx, rangeInfo.rs, ts, rangeCh)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					log.Fatalf(ctx, <span class="string">&quot;unexpected RangeFeedRetryError reason %v&quot;</span>, t.Reason)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> t</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DistSender 对应的RangeFeed接口</span></span><br><span class="line"><span class="comment">// RangeFeed divides a RangeFeed request on range boundaries and establishes a</span></span><br><span class="line"><span class="comment">// RangeFeed to each of the individual ranges. It streams back results on the</span></span><br><span class="line"><span class="comment">// provided channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ds *DistSender)</span> <span class="title">RangeFeed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	ctx context.Context,</span></span></span><br><span class="line"><span class="function"><span class="params">	args *roachpb.RangeFeedRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">	withDiff <span class="keyword">bool</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">	eventCh <span class="keyword">chan</span>&lt;- *roachpb.RangeFeedEvent,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ctx = ds.AnnotateCtx(ctx)</span><br><span class="line">	ctx, sp := tracing.EnsureChildSpan(ctx, ds.AmbientContext.Tracer, <span class="string">&quot;dist sender&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> sp.Finish()</span><br><span class="line"></span><br><span class="line">	startRKey, err := keys.Addr(args.Span.Key)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	endRKey, err := keys.Addr(args.Span.EndKey)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	rs := roachpb.RSpan&#123;Key: startRKey, EndKey: endRKey&#125;</span><br><span class="line"></span><br><span class="line">	g := ctxgroup.WithContext(ctx)</span><br><span class="line">	<span class="comment">// Goroutine that processes subdivided ranges and creates a rangefeed for</span></span><br><span class="line">	<span class="comment">// each.</span></span><br><span class="line">	rangeCh := <span class="built_in">make</span>(<span class="keyword">chan</span> singleRangeInfo, <span class="number">16</span>)</span><br><span class="line">	g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> sri := &lt;-rangeCh:</span><br><span class="line">				<span class="comment">// Spawn a child goroutine to process this feed.</span></span><br><span class="line">				g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">					<span class="keyword">return</span> ds.partialRangeFeed(ctx, &amp;sri, withDiff, rangeCh, eventCh)</span><br><span class="line">				&#125;)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span> ctx.Err()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Kick off the initial set of ranges.</span></span><br><span class="line">	g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ds.divideAndSendRangeFeedToRanges(ctx, rs, args.Timestamp, rangeCh)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要负责rangfeed接口调用以及rangfeed推出数据的处理，回填处理等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *poller)</span> <span class="title">rangefeedImplIter</span><span class="params">(ctx context.Context, i <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Determine whether to request the previous value of each update from</span></span><br><span class="line">	<span class="comment">// RangeFeed based on whether the `diff` option is specified.</span></span><br><span class="line">	_, withDiff := p.details.Opts[optDiff]</span><br><span class="line"></span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	lastHighwater := p.mu.highWater</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> err := p.tableHist.WaitForTS(ctx, lastHighwater); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spans, err := getSpansToProcess(ctx, p.db, p.spans)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Perform a full scan if necessary - either an initial scan or a backfill</span></span><br><span class="line">	<span class="comment">// Full scans are still performed using an Export operation.</span></span><br><span class="line">	initialScan := i == <span class="number">0</span></span><br><span class="line">	backfillWithDiff := !initialScan &amp;&amp; withDiff</span><br><span class="line">	<span class="keyword">var</span> scanTime hlc.Timestamp</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(p.mu.scanBoundaries) &gt; <span class="number">0</span> &amp;&amp; p.mu.scanBoundaries[<span class="number">0</span>].Equal(p.mu.highWater) &#123;</span><br><span class="line">		<span class="comment">// Perform a full scan of the latest value of all keys as of the</span></span><br><span class="line">		<span class="comment">// boundary timestamp and consume the boundary.</span></span><br><span class="line">		scanTime = p.mu.scanBoundaries[<span class="number">0</span>]</span><br><span class="line">		p.mu.scanBoundaries = p.mu.scanBoundaries[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> scanTime != (hlc.Timestamp&#123;&#125;) &#123;</span><br><span class="line">		<span class="comment">// TODO(dan): Now that we no longer have the poller, we should stop using</span></span><br><span class="line">		<span class="comment">// ExportRequest and start using normal Scans.</span></span><br><span class="line">		<span class="keyword">if</span> err := p.exportSpansParallel(ctx, spans, scanTime, backfillWithDiff); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Start rangefeeds, exit polling if we hit a resolved timestamp beyond</span></span><br><span class="line">	<span class="comment">// the next scan boundary.</span></span><br><span class="line">	<span class="comment">// TODO(nvanbenschoten): This is horrible.</span></span><br><span class="line">	sender := p.db.NonTransactionalSender()</span><br><span class="line">	ds := sender.(*client.CrossRangeTxnWrapperSender).Wrapped().(*kv.DistSender)</span><br><span class="line">	g := ctxgroup.WithContext(ctx)</span><br><span class="line">	eventC := <span class="built_in">make</span>(<span class="keyword">chan</span> *roachpb.RangeFeedEvent, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// To avoid blocking raft, RangeFeed puts all entries in a server side</span></span><br><span class="line">	<span class="comment">// buffer. But to keep things simple, it&#x27;s a small fixed-sized buffer. This</span></span><br><span class="line">	<span class="comment">// means we need to ingest everything we get back as quickly as possible, so</span></span><br><span class="line">	<span class="comment">// we throw it in a buffer here to pick up the slack between RangeFeed and</span></span><br><span class="line">	<span class="comment">// the sink.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// TODO(dan): Right now, there are two buffers in the changefeed flow when</span></span><br><span class="line">	<span class="comment">// using RangeFeeds, one here and the usual one between the poller and the</span></span><br><span class="line">	<span class="comment">// rest of the changefeed (he latter of which is implemented with an</span></span><br><span class="line">	<span class="comment">// unbuffered channel, and so doesn&#x27;t actually buffer). Ideally, we&#x27;d have</span></span><br><span class="line">	<span class="comment">// one, but the structure of the poller code right now makes this hard.</span></span><br><span class="line">	<span class="comment">// Specifically, when a schema change happens, we need a barrier where we</span></span><br><span class="line">	<span class="comment">// flush out every change before the schema change timestamp before we start</span></span><br><span class="line">	<span class="comment">// emitting any changes from after the schema change. The poller&#x27;s</span></span><br><span class="line">	<span class="comment">// `tableHist` is responsible for detecting and enforcing these (they queue</span></span><br><span class="line">	<span class="comment">// up in `p.scanBoundaries`), but the after-poller buffer doesn&#x27;t have</span></span><br><span class="line">	<span class="comment">// access to any of this state. A cleanup is in order.</span></span><br><span class="line">	memBuf := makeMemBuffer(p.mm.MakeBoundAccount(), p.metrics)</span><br><span class="line">	<span class="keyword">defer</span> memBuf.Close(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Maintain a local spanfrontier to tell when all the component rangefeeds</span></span><br><span class="line">	<span class="comment">// being watched have reached the Scan boundary.</span></span><br><span class="line">	<span class="comment">// TODO(mrtracy): The alternative to this would be to maintain two</span></span><br><span class="line">	<span class="comment">// goroutines for each span (the current arrangement is one goroutine per</span></span><br><span class="line">	<span class="comment">// span and one multiplexing goroutine that outputs to the buffer). This</span></span><br><span class="line">	<span class="comment">// alternative would allow us to stop the individual rangefeeds earlier and</span></span><br><span class="line">	<span class="comment">// avoid the need for a span frontier, but would also introduce a different</span></span><br><span class="line">	<span class="comment">// contention pattern and use additional goroutines. it&#x27;s not clear which</span></span><br><span class="line">	<span class="comment">// solution is best without targeted performance testing, so we&#x27;re choosing</span></span><br><span class="line">	<span class="comment">// the faster-to-implement solution for now.</span></span><br><span class="line">	frontier := makeSpanFrontier(spans...)</span><br><span class="line"></span><br><span class="line">	rangeFeedStartTS := lastHighwater</span><br><span class="line">	<span class="keyword">for</span> _, span := <span class="keyword">range</span> p.spans &#123;</span><br><span class="line">		req := &amp;roachpb.RangeFeedRequest&#123;</span><br><span class="line">			Header: roachpb.Header&#123;</span><br><span class="line">				Timestamp: lastHighwater,</span><br><span class="line">			&#125;,</span><br><span class="line">			Span: span,</span><br><span class="line">		&#125;</span><br><span class="line">		frontier.Forward(span, rangeFeedStartTS)</span><br><span class="line">		g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		    <span class="comment">//调用分发层对应的RangeFeed接口</span></span><br><span class="line">			<span class="keyword">return</span> ds.RangeFeed(ctx, req, withDiff, eventC)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> e := &lt;-eventC:</span><br><span class="line">				<span class="keyword">switch</span> t := e.GetValue().(<span class="keyword">type</span>) &#123;</span><br><span class="line">				<span class="keyword">case</span> *roachpb.RangeFeedValue:</span><br><span class="line">					kv := roachpb.KeyValue&#123;Key: t.Key, Value: t.Value&#125;</span><br><span class="line">					<span class="keyword">var</span> prevVal roachpb.Value</span><br><span class="line">					<span class="keyword">if</span> withDiff &#123;</span><br><span class="line">						prevVal = t.PrevValue</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">//将变更信息填充到memBuf中以供接下来进行消费</span></span><br><span class="line">					<span class="keyword">if</span> err := memBuf.AddKV(ctx, kv, prevVal, hlc.Timestamp&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">case</span> *roachpb.RangeFeedCheckpoint:</span><br><span class="line">					<span class="keyword">if</span> !t.ResolvedTS.IsEmpty() &amp;&amp; t.ResolvedTS.Less(rangeFeedStartTS) &#123;</span><br><span class="line">						<span class="comment">// RangeFeed happily forwards any closed timestamps it receives as</span></span><br><span class="line">						<span class="comment">// soon as there are no outstanding intents under them.</span></span><br><span class="line">						<span class="comment">// Changefeeds don&#x27;t care about these at all, so throw them out.</span></span><br><span class="line">						<span class="keyword">continue</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> err := memBuf.AddResolved(ctx, t.Span, t.ResolvedTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line">					&#125;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					log.Fatalf(ctx, <span class="string">&quot;unexpected RangeFeedEvent variant %v&quot;</span>, t)</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span> ctx.Err()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">//进行变更信息的消费</span></span><br><span class="line">	g.GoCtx(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			e, err := memBuf.Get(ctx)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> e.kv.Key != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> err := p.tableHist.WaitForTS(ctx, e.kv.Value.Timestamp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				pastBoundary := <span class="literal">false</span></span><br><span class="line">				p.mu.Lock()</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(p.mu.scanBoundaries) &gt; <span class="number">0</span> &amp;&amp; p.mu.scanBoundaries[<span class="number">0</span>].Less(e.kv.Value.Timestamp) &#123;</span><br><span class="line">					<span class="comment">// Ignore feed results beyond the next boundary; they will be retrieved when</span></span><br><span class="line">					<span class="comment">// the feeds are restarted after the scan.</span></span><br><span class="line">					pastBoundary = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">				p.mu.Unlock()</span><br><span class="line">				<span class="keyword">if</span> pastBoundary &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> err := p.buf.AddKV(ctx, e.kv, e.prevVal, e.schemaTimestamp, hlc.Timestamp&#123;&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> e.resolved != <span class="literal">nil</span> &#123;</span><br><span class="line">				resolvedTS := e.resolved.Timestamp</span><br><span class="line">				boundaryBreak := <span class="literal">false</span></span><br><span class="line">				<span class="comment">// Make sure scan boundaries less than or equal to `resolvedTS` were</span></span><br><span class="line">				<span class="comment">// added to the `scanBoundaries` list before proceeding.</span></span><br><span class="line">				<span class="keyword">if</span> err := p.tableHist.WaitForTS(ctx, resolvedTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> err</span><br><span class="line">				&#125;</span><br><span class="line">				p.mu.Lock()</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(p.mu.scanBoundaries) &gt; <span class="number">0</span> &amp;&amp; !resolvedTS.Less(p.mu.scanBoundaries[<span class="number">0</span>]) &#123;</span><br><span class="line">					boundaryBreak = <span class="literal">true</span></span><br><span class="line">					resolvedTS = p.mu.scanBoundaries[<span class="number">0</span>]</span><br><span class="line">				&#125;</span><br><span class="line">				p.mu.Unlock()</span><br><span class="line">				<span class="keyword">if</span> boundaryBreak &#123;</span><br><span class="line">					<span class="comment">// A boundary here means we&#x27;re about to do a full scan (backfill)</span></span><br><span class="line">					<span class="comment">// at this timestamp, so at the changefeed level the boundary</span></span><br><span class="line">					<span class="comment">// itself is not resolved. Skip emitting this resolved timestamp</span></span><br><span class="line">					<span class="comment">// because we want to trigger the scan first before resolving its</span></span><br><span class="line">					<span class="comment">// scan boundary timestamp.</span></span><br><span class="line">					resolvedTS = resolvedTS.Prev()</span><br><span class="line">					frontier.Forward(e.resolved.Span, resolvedTS)</span><br><span class="line">					<span class="keyword">if</span> frontier.Frontier() == resolvedTS &#123;</span><br><span class="line">						<span class="comment">// All component rangefeeds are now at the boundary.</span></span><br><span class="line">						<span class="comment">// Break out of the ctxgroup by returning a sentinel error.</span></span><br><span class="line">						<span class="keyword">return</span> errBoundaryReached</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> err := p.buf.AddResolved(ctx, e.resolved.Span, resolvedTS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> err</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// TODO(mrtracy): We are currently tearing down the entire rangefeed set in</span></span><br><span class="line">	<span class="comment">// order to perform a scan; however, given that we have an intermediate</span></span><br><span class="line">	<span class="comment">// buffer, its seems that we could do this without having to destroy and</span></span><br><span class="line">	<span class="comment">// recreate the rangefeeds.</span></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &amp;&amp; err != errBoundaryReached &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	p.mu.Lock()</span><br><span class="line">	p.mu.highWater = p.mu.scanBoundaries[<span class="number">0</span>]</span><br><span class="line">	p.mu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="CDC-DDL捕获设计文档"><a href="#CDC-DDL捕获设计文档" class="headerlink" title="CDC DDL捕获设计文档"></a>CDC DDL捕获设计文档</h1><h2 id="Online-Schema-Change分析"><a href="#Online-Schema-Change分析" class="headerlink" title="Online Schema Change分析"></a>Online Schema Change分析</h2><p>关系型数据库中数据以表为单位存储，读写操作依赖表的模式(Schema)和数据(Data)。DDL 通常需要同时修改模式和数据，为了避免并发问题，早期的数据库实现会在 DDL 过程中禁止目标表上的读写操作（简称锁表）。锁表保证了对模式和数据的修改是原子操作。但某些 DDL 操作涉及复制数据（比如索引构建）执行时间可能在几分钟甚至数小时。OLTP 数据库中长时间锁表会对业务产生不可预知的影响，生产环境中不可接受，因此“能够与读写操作并行执行”是 OLTP 用户对 DDL 的核心需求，也是 Online Schema Change 要解决的问题。</p>
<h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分布式数据库通常是一个集群，出于性能考虑，每个节点需要缓存一份 Schema。如果继续采用单机数据库的 DDL 流程，则需要通过分布式锁来保证加载新版本 Schema 过程中没有读写操作进行，代价极高，并且当集群内节点不能够互相感知时将变为无法完成的任务。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/distribute.jpg" alt="distribute.jpg"></p>
<p>讨论解决方案之前，以 CREATE INDEX 为例，看看集群节点使用不同版本 Schema 执行读写操作，带来的具体问题。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/progrems.jpg" alt="progrems.jpg"><br>上图展示的是一个存储计算分离架构的分布式数据库，集群由 CN(计算节点) 和 DN(存储节点) 构成，每个 CN 中缓存一份 Schema。由于 CN0 和 CN1 异步加载 Schema，添加索引过程中可能存在一个时刻，CN0 认为有索引而 CN1 认为没有，此时产生两种异常</p>
<p>索引上有多余数据(Orphan Data Anomaly): CN0 执行了 INSERT，在表和索引上插入数据，随后 CN1 执行 DELETE。由于 CN1 认为没有索引，仅删除了表上的数据<br>索引上缺少数据(Integrity Anomaly): CN1 执行 INSERT，由于 CN1 认为没有索引，仅在表上插入数据，没有写相关的增量日志，导致索引创建完成后缺少这次 INSERT 的数据<br>可以看到，如果同一时刻存在两个 Schema 版本的情况无法避免，继续沿用单机数据库一步完成 Schema 版本切换的方案，会导致数据问题。那么如果“一步”切换不可行，“多步”能否解决问题？VLDB 2013 上 Google 工程师给出了一种新的 Schema Change 流程，通过增加两个中间状态来解决这个问题[7]。</p>
<h3 id="F1-Online-Schema-Change"><a href="#F1-Online-Schema-Change" class="headerlink" title="F1 Online Schema Change"></a>F1 Online Schema Change</h3><p>Google F1 的方案引入了两个中间状态，delete_only 状态的对象上仅执行删除操作，write_only 状态的对象上支持写入，但不允许读取。依然以 CREATE INDEX 为例</p>
<p>解决 Orphan Data Anomaly：CN0 认为索引处于 delete_only 状态，仅在表上插入数据，CN1 认为没有索引，仅在表上删除数据。最终索引和表上都没有 id = 0 的数据<br>解决 Integrity Anomaly：CN1 认为索引处于 delete_only 状态，仅在表上插入数据，没有写相关的增量日志，但由于还有节点没有更新到 V2 版本，数据回填没有开始。当所有节点都更新 V2 版本后，数据回填操作会在索引中填入这一条数据<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/f1-online-schema-change.jpg" alt="f1-online-schema-change.jpg"><br>以上两个具体场景为例，说明了方案的有效性。</p>
<h4 id="Google-F1-的方案，包含两个关键点："><a href="#Google-F1-的方案，包含两个关键点：" class="headerlink" title="Google F1 的方案，包含两个关键点："></a>Google F1 的方案，包含两个关键点：</h4><ul>
<li><p>增加两个中间状态(delete_only，write_only)，允许集群中的事务同时使用至多两个最近的元数据版本</p>
</li>
<li><p>增加租约(lease)的概念，保证在一个租约周期内，没有拿到最新版本 Schema 的节点，无法提交事务</p>
</li>
</ul>
<p>第一个关键点，将保证 Schema Change 正确性的条件，从“只能有一个版本”，降低为“最多可以有两个版本”。第二个关键点，给出了 F1 系统“保证最多两个版本”的实现思路。<br>简单来说，Google F1 的方案，成功将问题“在分布式数据库系统上实现 Online Schema Change”转化为“设计一种保证系统中最多有两个 Schema 版本的协议”，并且给出了一种基于租约的协议实现。<br>协议内容可以概括为，以租约周期作为时间单位，协调了三个操作的节奏</p>
<ul>
<li>Schema 刷新的间隔：每个节点需要在租约过期前，获取一次最新版本 Schema，如果无法获取，则主动退出，由托管服务重新拉起</li>
<li>DDL 的最小时长：每次更新 Schema 版本后，需要等待一个租约周期，保证所有节点都读到最新版本的元数据</li>
<li>事务的最大时长：执行时间超过一个租约周期的事务将被回滚，确保事务仅使用了一个 Schema 版本<br>原始版本的协议十分简洁，易于描述和验证，但由于将 DDL 执行的最小时长和事务执行的最大时长绑定在一起，使用体验上与单机数据库有区别。对此，业界也给出了多种改进方案，比如：</li>
</ul>
<h4 id="CockroachDB-重新设计了-schema-lease-8-，在两方面做出改进："><a href="#CockroachDB-重新设计了-schema-lease-8-，在两方面做出改进：" class="headerlink" title="CockroachDB 重新设计了 schema lease[8] ，在两方面做出改进："></a>CockroachDB 重新设计了 schema lease[8] ，在两方面做出改进：</h4><ul>
<li>降低 DDL 执行的最小时长：通过在事务开始时获取一个包含版本信息的租约，事务结束时释放，使得更新 Schema 版本后能够立即确认旧版本是否还在被使用，仅在有长事务或者节点异常（比如网络断开）时才需要等满一个租约周期。由于通过在存储中插入记录来获取租约，会增加事务的执行耗时。</li>
<li>只在 DDL 执行过程中限制事务的最大时长：具体做法是，使用 Schema 版本变更开始的时间作为边界，产生一个 [Tv,Tv+2) 的时间窗口。起始时间在窗口内，结束时间在窗口外的事务将被回滚。如果有 DDL 正在执行，则窗口最大为两个租约周期。如果没有 DDL 执行，则不存在 v+2 版本，可以认为是一个无限大的窗口[Tv,+∞)</li>
</ul>
<h2 id="CDC-DDL捕获原理"><a href="#CDC-DDL捕获原理" class="headerlink" title="CDC DDL捕获原理"></a>CDC DDL捕获原理</h2><p>总的来说，CDC DDL捕获设计与DML捕获的基本原理类似。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc-seq.png" alt="cdc-seq.png"></p>
<h3 id="CDC-DDL数据来源"><a href="#CDC-DDL数据来源" class="headerlink" title="CDC DDL数据来源"></a>CDC DDL数据来源</h3><p>首先，DDL捕获开启一个特殊的changeAggregator，该changeAggregator主要负责监控一个特殊的表-<em><strong>system.descriptor</strong></em>,如上述对于Online Schema Change的分析，一次Schema Change包含多不操作，也即对应的 <em><strong>system.descriptor</strong></em> 具有多次变更记录。而对于CDC DDL捕获功能来说，目前仅需要实际设置为 <em><strong>public</strong></em>  状态的变更记录。因此对 <em><strong>system.descriptor</strong></em> 触发出的数据进行相关处理操作。</p>
<h3 id="CDC-DDL-DML顺序问题解决"><a href="#CDC-DDL-DML顺序问题解决" class="headerlink" title="CDC DDL DML顺序问题解决"></a>CDC DDL DML顺序问题解决</h3><p>![cdc ddl.png](<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc">https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/cdc</a> ddl.png)</p>
<h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><ul>
<li><p>DDL阻塞条件<br>resolvedTS &lt; lastDMLTransactionCommitTime</p>
</li>
<li><p>DDL放出条件<br>resolvedTS &gt;= lastDMLTransactionCommitTime</p>
</li>
<li><p><em>变量解释：</em>*</p>
<ol>
<li>resolvedTS<br>变量含义：该表对应的已解析时间戳<br>更新位置：该表DML已经不再发送将该表对应的span标志为resolvedSpan</li>
<li>lastDMLTransactionCommitTime<br>变量含义：DML事务提交时间<br>更新位置：DML成功发送后，更新DML事务提交时间</li>
</ol>
</li>
</ul>
<h4 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h4><ul>
<li><p>DML需写入临时文件条件</p>
<p>  lastDDLSendTime &lt; changefeedDesc.ModificationTime</p>
</li>
<li><p>DML直接发送条件</p>
<p>  lastDDLSendTime &gt;= changefeedDesc.ModificationTime<br>  <strong>变量解释：</strong></p>
<ol>
<li>lastDDLSendTime<br>变量含义：DDL上次发送对应的表的ModifyTime<br>更新位置：DDL成功发送后，更新lastDDLSendTime为ModifyTime</li>
<li>changefeedDesc.ModificationTime<br>变量含义：该次DML对应的ModificationTime</li>
</ol>
</li>
</ul>
<h3 id="DDL-amp-DML-Model"><a href="#DDL-amp-DML-Model" class="headerlink" title="DDL&amp;DML Model"></a>DDL&amp;DML Model</h3><p>   代表俩个模式，分别负责DDL发送与DML发送。</p>
<ol>
<li>处于DDL Model:每次发送DDL后，读取临时文件，如果临时文件中的DML满足DML直接发送条件，则切换为DML Model。</li>
<li>处于DML Model:DML更新resolvedTS后，如果满足DDL直接发送条件，则切换为DDL Model。<h1 id="CDC-具有外键约束表数据顺序捕获分析"><a href="#CDC-具有外键约束表数据顺序捕获分析" class="headerlink" title="CDC 具有外键约束表数据顺序捕获分析"></a>CDC 具有外键约束表数据顺序捕获分析</h1></li>
</ol>
<h2 id="具有外键约束表的数据变更特点"><a href="#具有外键约束表的数据变更特点" class="headerlink" title="具有外键约束表的数据变更特点"></a>具有外键约束表的数据变更特点</h2><ul>
<li>数据变更为同一事务</li>
<li>主从表数据需要顺序发送</li>
</ul>
<h2 id="具有外键约束表的数据变更捕获方案"><a href="#具有外键约束表的数据变更捕获方案" class="headerlink" title="具有外键约束表的数据变更捕获方案"></a>具有外键约束表的数据变更捕获方案</h2><p>总的来说就是进行排序操作，按照事务的时间戳ts进行重组。然后主表先入从表后入</p>
<p>主要问题为：</p>
<ul>
<li>基于目前的CDC体系在数据库内部进行排序以及事务重组操作将会特别消耗数据库资源，再未进行排序时，开启CDC大概会消耗5%~15%左右的数据库性能，如果这些操作在内部进行处理时，会导致更大的性能消耗</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为ZNbase 本身使用的是混合逻辑时钟，所以两个不重叠事务的时间戳可能会相同，但是混合逻辑时钟具有纳秒级的精度。这个概率较小。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">shimengfei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shimengfei.github.io/posts/32752.html">https://shimengfei.github.io/posts/32752.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shimengfei.github.io" target="_blank">飞飞 ❤️ 晨晨</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/8.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/19049.html"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go语言GMP模型分析</div></div></a></div><div class="next-post pull-right"><a href="/posts/22338.html"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/10.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo-Theme-Sakura</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/img/(0).jpg.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">shimengfei</div><div class="author-info__description">飞飞 ❤️ 晨晨</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/shimengfei"><i class="fab fa-github"></i><span>Github 主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/shimengfei" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:13001306383@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">当下的奋进与堕落，皆是一种积淀，它们会默默为你铺路</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CDC%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">CDC整体架构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CDC-%E6%A6%82%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">CDC 概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDC%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">CDC流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range-Feed%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">Range Feed原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Difficulty-With-Decoding-WriteBatches"><span class="toc-number">1.3.1.</span> <span class="toc-text">The Difficulty With Decoding WriteBatches</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Logical-MVCC-Operations"><span class="toc-number">1.3.2.</span> <span class="toc-text">Logical MVCC Operations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDC-%E4%BB%A3%E7%A0%81%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%BC%96%E5%86%99"><span class="toc-number">2.</span> <span class="toc-text">CDC 代码时序图编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDC%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">CDC最终一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E8%AF%AD%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">分布式事务保证事务语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.1.</span> <span class="toc-text">现存问题:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A0%94%E8%AF%BB"><span class="toc-number">4.</span> <span class="toc-text">代码研读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CDC-DDL%E6%8D%95%E8%8E%B7%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3"><span class="toc-number"></span> <span class="toc-text">CDC DDL捕获设计文档</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Online-Schema-Change%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Online Schema Change分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">分布式数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F1-Online-Schema-Change"><span class="toc-number">1.2.</span> <span class="toc-text">F1 Online Schema Change</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Google-F1-%E7%9A%84%E6%96%B9%E6%A1%88%EF%BC%8C%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">Google F1 的方案，包含两个关键点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CockroachDB-%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%E4%BA%86-schema-lease-8-%EF%BC%8C%E5%9C%A8%E4%B8%A4%E6%96%B9%E9%9D%A2%E5%81%9A%E5%87%BA%E6%94%B9%E8%BF%9B%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">CockroachDB 重新设计了 schema lease[8] ，在两方面做出改进：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDC-DDL%E6%8D%95%E8%8E%B7%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">CDC DDL捕获原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CDC-DDL%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90"><span class="toc-number">2.1.</span> <span class="toc-text">CDC DDL数据来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CDC-DDL-DML%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">2.2.</span> <span class="toc-text">CDC DDL DML顺序问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DDL"><span class="toc-number">2.2.1.</span> <span class="toc-text">DDL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DML"><span class="toc-number">2.2.2.</span> <span class="toc-text">DML</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL-amp-DML-Model"><span class="toc-number">2.3.</span> <span class="toc-text">DDL&amp;DML Model</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CDC-%E5%85%B7%E6%9C%89%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E8%A1%A8%E6%95%B0%E6%8D%AE%E9%A1%BA%E5%BA%8F%E6%8D%95%E8%8E%B7%E5%88%86%E6%9E%90"><span class="toc-number"></span> <span class="toc-text">CDC 具有外键约束表数据顺序捕获分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">具有外键约束表的数据变更特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4%E6%8D%95%E8%8E%B7%E6%96%B9%E6%A1%88"><span class="toc-number">2.</span> <span class="toc-text">具有外键约束表的数据变更捕获方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/99a0d2d3.html" title="MySQL Online DDL 原理"><img data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MySQL Online DDL 原理"/></a><div class="content"><a class="title" href="/posts/99a0d2d3.html" title="MySQL Online DDL 原理">MySQL Online DDL 原理</a><time datetime="2024-11-27T15:14:24.000Z" title="发表于 2024-11-27 23:14:24">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/80ca231b.html" title="追源索骥：透过源码看懂Flink核心框架的执行流程"><img data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="追源索骥：透过源码看懂Flink核心框架的执行流程"/></a><div class="content"><a class="title" href="/posts/80ca231b.html" title="追源索骥：透过源码看懂Flink核心框架的执行流程">追源索骥：透过源码看懂Flink核心框架的执行流程</a><time datetime="2024-11-24T15:14:24.000Z" title="发表于 2024-11-24 23:14:24">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9458b181.html" title="CockroachDB分布式事务解析"><img data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/20.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CockroachDB分布式事务解析"/></a><div class="content"><a class="title" href="/posts/9458b181.html" title="CockroachDB分布式事务解析">CockroachDB分布式事务解析</a><time datetime="2021-06-28T14:13:18.000Z" title="发表于 2021-06-28 22:13:18">2021-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4040ef7a.html" title="Java资源大全"><img data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java资源大全"/></a><div class="content"><a class="title" href="/posts/4040ef7a.html" title="Java资源大全">Java资源大全</a><time datetime="2021-06-28T13:29:00.000Z" title="发表于 2021-06-28 21:29:00">2021-06-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fb8ee9c8.html" title="技术资料合集"><img data-lazy-src="https://cdn.jsdelivr.net/gh/shimengfei/cdn/guidao/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术资料合集"/></a><div class="content"><a class="title" href="/posts/fb8ee9c8.html" title="技术资料合集">技术资料合集</a><time datetime="2021-06-25T17:00:41.000Z" title="发表于 2021-06-26 01:00:41">2021-06-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By shimengfei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '664TGLdx3PsteAFf3ovNvEqY-gzGzoHsz',
      appKey: 'U7a1xIuFlp4o9Nn2OkwnfYNp',
      placeholder: '大家文明留言哈~',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/f46f7ebf.js","daovoice")
</script><script>var isChatBtn = false
daovoice('init', {
  app_id: 'f46f7ebf',},{
  launcher: { 
     disableLauncherIcon: isChatBtn // 悬浮 ICON 是否显示
  },
});
daovoice('update');

if (isChatBtn) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      daovoice('show')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: true // 悬浮 ICON 是否显示
        },
      });
    }
    function chatBtnShow () {
      daovoice('update', {},{
        launcher: { 
        disableLauncherIcon: false // 悬浮 ICON 是否显示
        },
      });
    }
  }
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-shizuku"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>